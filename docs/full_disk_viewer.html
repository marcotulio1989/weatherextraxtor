<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ∞Ô∏è GOES Satellite Viewer - Imagem Completa</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: linear-gradient(90deg, #1a1a2e, #16213e);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #00d4ff;
        }
        .header h1 { color: #00d4ff; font-size: 1.2em; }
        
        .controls {
            background: rgba(0,0,0,0.85);
            padding: 10px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid #333;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        .control-group label {
            font-size: 0.7em;
            color: #888;
            text-transform: uppercase;
        }
        select, button {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #444;
            background: #1a1a2e;
            color: #e0e0e0;
            font-size: 0.85em;
            cursor: pointer;
        }
        button {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: #000;
            font-weight: bold;
            border: none;
        }
        button:hover { box-shadow: 0 3px 10px rgba(0,212,255,0.4); }
        button:disabled { opacity: 0.5; cursor: wait; }
        
        .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .slider-group input { width: 100px; }
        .slider-value { color: #00d4ff; font-weight: bold; min-width: 40px; }
        
        .map-container { flex: 1; position: relative; }
        #map { width: 100%; height: 100%; background: #111; }
        
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            padding: 12px;
            border-radius: 8px;
            font-size: 0.8em;
            z-index: 1000;
            min-width: 200px;
            border: 1px solid #333;
        }
        .info-panel h3 { color: #00d4ff; margin-bottom: 8px; font-size: 0.9em; }
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .info-label { color: #666; }
        .info-value { color: #00d4ff; }
        .info-value.ok { color: #2ecc71; }
        .info-value.err { color: #e74c3c; }
        
        .loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px 50px;
            border-radius: 10px;
            z-index: 9999;
            text-align: center;
        }
        .loading.hidden { display: none; }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid #333;
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .progress { margin-top: 10px; }
        .progress-bar {
            width: 200px; height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #00d4ff;
            width: 0%;
        }
        .progress-text { margin-top: 5px; font-size: 0.8em; color: #888; }
        
        .status-bar {
            background: #111;
            padding: 8px 20px;
            font-size: 0.75em;
            color: #666;
            display: flex;
            justify-content: space-between;
        }
        
        /* Toggle Button para Camadas */
        .toggle-btn {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: linear-gradient(135deg, #2d3748, #1a202c);
            border: 1px solid #444;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .toggle-btn:hover { border-color: #00d4ff; }
        .toggle-btn.active {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            border-color: #00d4ff;
            color: #000;
        }
        .toggle-btn .toggle-indicator {
            width: 36px;
            height: 20px;
            background: #444;
            border-radius: 10px;
            position: relative;
            transition: all 0.3s;
        }
        .toggle-btn.active .toggle-indicator {
            background: rgba(0,0,0,0.3);
        }
        .toggle-btn .toggle-indicator::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #888;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }
        .toggle-btn.active .toggle-indicator::after {
            left: 18px;
            background: #fff;
        }
        
        /* Wind Legend */
        .wind-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            padding: 12px;
            border-radius: 8px;
            z-index: 1000;
            border: 1px solid #333;
            display: none;
        }
        .wind-legend.show { display: block; }
        .wind-legend h4 { 
            color: #00d4ff; 
            margin-bottom: 8px; 
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .wind-legend-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            font-size: 0.75em;
        }
        .wind-legend-color {
            width: 30px;
            height: 4px;
            border-radius: 2px;
        }
        
        /* DEBUG LOG */
        #debugPanel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            max-height: 40vh;
            background: rgba(0,0,0,0.95);
            z-index: 9999;
            display: none;
            flex-direction: column;
        }
        #debugPanel.show { display: flex; }
        #debugHeader {
            background: #222;
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
        }
        #debugHeader button { margin-left: 10px; padding: 5px 10px; font-size: 12px; }
        #debugLog {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #0f0;
            -webkit-user-select: text;
            user-select: text;
            white-space: pre-wrap;
        }
        .test-btn { background: linear-gradient(135deg, #ff6600, #cc3300) !important; }
        
        /* Wind Popup Style */
        .wind-popup .leaflet-popup-content-wrapper {
            background: rgba(0,0,0,0.9);
            color: #fff;
            border: 1px solid #00d4ff;
        }
        .wind-popup .leaflet-popup-tip {
            background: rgba(0,0,0,0.9);
        }
        
        /* Wind Arrow Animation */
        .wind-arrow-head {
            transition: transform 0.3s ease;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>üõ∞Ô∏è GOES Satellite - Imagem Completa</h1>
        <span style="color:#888; font-size:0.85em;">Reproje√ß√£o em tempo real no browser</span>
    </header>
    
    <div class="controls">
        <div class="control-group">
            <label>üõ∞Ô∏è Sat√©lite</label>
            <select id="satellite">
                <option value="goes19">GOES-19</option>
                <option value="goes16">GOES-16</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>üì∑ Produto</label>
            <select id="product">
                <option value="GEOCOLOR" selected>üåç GeoColor (Vis√≠vel/IR)</option>
                <option value="13">üå°Ô∏è IR Limpo (Band 13 - 10.3¬µm)</option>
                <option value="14">üå°Ô∏è IR (Band 14 - 11.2¬µm)</option>
                <option value="08">üíß Vapor d'√Ågua Alto (Band 8)</option>
                <option value="09">üíß Vapor d'√Ågua M√©dio (Band 9)</option>
                <option value="10">üíß Vapor d'√Ågua Baixo (Band 10)</option>
                <option value="02">‚òÄÔ∏è Vis√≠vel (Band 2 - 0.64¬µm)</option>
                <option value="AirMass">üåÄ Air Mass (RGB)</option>
                <option value="Sandwich">ü•™ Sandwich (IR + Vis√≠vel)</option>
                <option value="Dust">üèúÔ∏è Dust (Poeira)</option>
                <option value="DayConvection">‚õàÔ∏è Convec√ß√£o Diurna</option>
                <option value="FireTemperature">üî• Temperatura de Fogo</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>üîß M√©todo de Reproje√ß√£o</label>
            <select id="method">
                <option value="reproject" selected>Reproje√ß√£o REAL</option>
                <option value="direct">Direto (SEM reproje√ß√£o)</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>‚ö° Qualidade</label>
            <select id="quality">
                <option value="low">R√°pida (600px)</option>
                <option value="medium" selected>M√©dia (1200px)</option>
                <option value="high">Alta (2400px)</option>
                <option value="max">M√°xima (4800px)</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>üîç Opacidade</label>
            <div class="slider-group">
                <input type="range" id="opacity" min="0" max="100" value="75">
                <span class="slider-value" id="opacityVal">75%</span>
            </div>
        </div>
        
        <button id="loadBtn" onclick="loadImage()">üåç CARREGAR IMAGEM</button>
        <button id="downloadBtn" onclick="downloadImage()" disabled>üíæ BAIXAR IMAGEM</button>
        <button onclick="fitBounds()">üìç Ver Tudo</button>
        <button onclick="zoomShip()">üö¢ Ir ao Navio</button>
        
        <!-- Toggle DMW Winds -->
        <div class="toggle-btn" id="toggleDMW" onclick="toggleDMWWinds()">
            <span>üå¨Ô∏è Ventos DMW</span>
            <div class="toggle-indicator"></div>
        </div>
        
        <div class="control-group">
            <label>üå¨Ô∏è N√≠vel de Vento</label>
            <select id="windLevel" onchange="if(dmwEnabled) loadDMWWinds()">
                <option value="low" selected>Baixo (&lt;3km)</option>
                <option value="mid">M√©dio (3-7km)</option>
                <option value="high">Alto (&gt;7km)</option>
                <option value="all">Todos</option>
            </select>
        </div>
        
        <button class="test-btn" onclick="testarReprojecao()">üß™ TESTAR</button>
        <button onclick="toggleDebug()">üìã DEBUG</button>
    </div>
    
    <!-- Wind Legend -->
    <div class="wind-legend" id="windLegend">
        <h4>üå¨Ô∏è Ventos DMW (GOES)</h4>
        <div class="wind-legend-row">
            <div class="wind-legend-color" style="background: #00ff00;"></div>
            <span>0-10 kt (Calmo)</span>
        </div>
        <div class="wind-legend-row">
            <div class="wind-legend-color" style="background: #ffff00;"></div>
            <span>10-20 kt (Fraco)</span>
        </div>
        <div class="wind-legend-row">
            <div class="wind-legend-color" style="background: #ffa500;"></div>
            <span>20-30 kt (Moderado)</span>
        </div>
        <div class="wind-legend-row">
            <div class="wind-legend-color" style="background: #ff6600;"></div>
            <span>30-40 kt (Forte)</span>
        </div>
        <div class="wind-legend-row">
            <div class="wind-legend-color" style="background: #ff0000;"></div>
            <span>&gt;40 kt (Muito Forte)</span>
        </div>
        <div style="margin-top: 8px; font-size: 0.7em; color: #888;">
            <span id="windInfo">-</span>
        </div>
    </div>
    
    <!-- DEBUG PANEL -->
    <div id="debugPanel">
        <div id="debugHeader">
            <span>üìã DEBUG LOG (selecione e copie)</span>
            <div>
                <button onclick="copiarDebug()">üìã COPIAR TUDO</button>
                <button onclick="limparDebug()">üóëÔ∏è LIMPAR</button>
                <button onclick="toggleDebug()">‚ùå FECHAR</button>
            </div>
        </div>
        <div id="debugLog"></div>
    </div>
    
    <div class="map-container">
        <div id="map"></div>
        
        <div class="info-panel">
            <h3>üìä Status</h3>
            <div class="info-row">
                <span class="info-label">Sat√©lite:</span>
                <span class="info-value" id="infoSat">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Tipo:</span>
                <span class="info-value" id="infoType">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">M√©todo:</span>
                <span class="info-value" id="infoMethod">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Status:</span>
                <span class="info-value" id="infoStatus">Aguardando</span>
            </div>
            <div class="info-row">
                <span class="info-label">Lat Norte:</span>
                <span class="info-value" id="infoN">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Lat Sul:</span>
                <span class="info-value" id="infoS">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Lon Oeste:</span>
                <span class="info-value" id="infoW">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Lon Leste:</span>
                <span class="info-value" id="infoE">-</span>
            </div>
        </div>
        
        <div class="loading hidden" id="loading">
            <div class="spinner"></div>
            <div id="loadingText">Carregando...</div>
            <div class="progress">
                <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
                <div class="progress-text" id="progressText">0%</div>
            </div>
        </div>
    </div>
    
    <div class="status-bar">
        <span id="statusText">Pronto</span>
        <span id="timestamp">-</span>
    </div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // =========================================================
        // CONFIGURA√á√ÉO
        // =========================================================
        
        const SHIP = { lat: -22.5, lon: -40.5 };
        
        // Vari√°vel global para armazenar o canvas da imagem reprojetada
        let currentCanvas = null;
        
        // DEBUG LOG FUNCTIONS
        function debugLog(msg) {
            const log = document.getElementById('debugLog');
            const time = new Date().toLocaleTimeString();
            log.textContent += `[${time}] ${msg}\n`;
            log.scrollTop = log.scrollHeight;
            console.log(msg);
        }
        
        function toggleDebug() {
            document.getElementById('debugPanel').classList.toggle('show');
        }
        
        function limparDebug() {
            document.getElementById('debugLog').textContent = '';
        }
        
        function copiarDebug() {
            const log = document.getElementById('debugLog').textContent;
            navigator.clipboard.writeText(log).then(() => {
                alert('Log copiado!');
            }).catch(() => {
                // Fallback para tablets
                const ta = document.createElement('textarea');
                ta.value = log;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                alert('Log copiado!');
            });
        }
        
        // TESTE DE REPROJE√á√ÉO SIMPLES
        async function testarReprojecao() {
            document.getElementById('debugPanel').classList.add('show');
            limparDebug();
            
            debugLog('=== INICIANDO TESTE DE REPROJE√á√ÉO ===');
            
            try {
                // TESTE 1: Canvas simples
                debugLog('TESTE 1: Criando canvas vermelho...');
                const canvas1 = document.createElement('canvas');
                canvas1.width = 400;
                canvas1.height = 300;
                const ctx1 = canvas1.getContext('2d');
                ctx1.fillStyle = 'red';
                ctx1.fillRect(0, 0, 400, 300);
                ctx1.fillStyle = 'white';
                ctx1.font = '24px Arial';
                ctx1.fillText('TESTE CANVAS', 100, 150);
                const dataUrl1 = canvas1.toDataURL('image/png');
                debugLog('Canvas criado, dataURL length: ' + dataUrl1.length);
                
                // Adicionar ao mapa
                if (overlay) map.removeLayer(overlay);
                const bounds = [[-60, -90], [15, -25]];
                overlay = L.imageOverlay(dataUrl1, bounds, {opacity: 0.8}).addTo(map);
                debugLog('‚úÖ TESTE 1 OK: Overlay canvas vermelho adicionado!');
                
                await sleep(2000);
                
                // TESTE 2: Carregar imagem Full Disk externa
                debugLog('TESTE 2: Carregando imagem Full Disk da NOAA...');
                const imgUrl = 'https://cdn.star.nesdis.noaa.gov/GOES19/ABI/FD/GEOCOLOR/latest.jpg';
                const img = await loadImg(imgUrl + '?t=' + Date.now());
                debugLog('Imagem carregada: ' + img.width + 'x' + img.height);
                
                // TESTE 3: Fazer reproje√ß√£o simples
                debugLog('TESTE 3: Iniciando reproje√ß√£o...');
                
                // Usar a fun√ß√£o loadImage diretamente
                document.getElementById('satellite').value = 'goes19';
                document.getElementById('method').value = 'reproject';
                await loadImage();
                
                debugLog('=== TODOS OS TESTES OK! ===');
                
            } catch (err) {
                debugLog('‚ùå ERRO: ' + err.message);
                debugLog('Stack: ' + err.stack);
            }
        }
        
        // Fun√ß√£o para gerar URL da imagem baseado no sat√©lite e produto
        function getImageUrl(satellite, product) {
            const sat = satellite.toUpperCase();
            // Usar 5424x5424.jpg que √© a resolu√ß√£o m√°xima dispon√≠vel
            return `https://cdn.star.nesdis.noaa.gov/${sat}/ABI/FD/${product}/5424x5424.jpg`;
        }
        
        // Bounds de sa√≠da para reproje√ß√£o
        // GOES-East est√° em -75.2¬∞ de longitude
        const BOUNDS = {
            local: {
                // Ser√° carregado do JSON
                north: null,
                south: null,
                west: null,
                east: null
            },
            fd: {
                // Bounds: 0¬∞N a 30¬∞S, 60¬∞W a 30¬∞W
                north: 0,
                south: -30,
                west: -60,
                east: -30
            }
        };
        
        let map, overlay = null;
        
        // =========================================================
        // INICIALIZA√á√ÉO
        // =========================================================
        
        function init() {
            map = L.map('map', {
                center: [-20, -50],
                zoom: 4,
                minZoom: 2,
                maxZoom: 10
            });
            
            // Mapa base
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                maxZoom: 19
            }).addTo(map);
            
            // Grid de refer√™ncia
            addGrid();
            
            // Marcador do navio
            addShipMarker();
            
            // Eventos
            document.getElementById('opacity').addEventListener('input', updateOpacity);
        }
        
        function addGrid() {
            // Linhas de latitude
            for (let lat = -60; lat <= 60; lat += 10) {
                L.polyline([[lat, -180], [lat, 180]], {
                    color: lat === 0 ? '#f80' : '#444',
                    weight: lat % 30 === 0 ? 1 : 0.5,
                    opacity: 0.5
                }).addTo(map);
            }
            // Linhas de longitude
            for (let lon = -180; lon <= 180; lon += 10) {
                L.polyline([[-80, lon], [80, lon]], {
                    color: lon === 0 ? '#f80' : '#444',
                    weight: lon % 30 === 0 ? 1 : 0.5,
                    opacity: 0.5
                }).addTo(map);
            }
        }
        
        function addShipMarker() {
            const icon = L.divIcon({
                html: '<div style="font-size:24px;filter:drop-shadow(0 0 5px #0ff);">üö¢</div>',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
            L.marker([SHIP.lat, SHIP.lon], { icon }).addTo(map)
                .bindPopup(`<b>Deepwater Aquila</b><br>${SHIP.lat}¬∞, ${SHIP.lon}¬∞`);
            
            // C√≠rculo de 100 NM
            L.circle([SHIP.lat, SHIP.lon], {
                radius: 100 * 1852,
                color: '#0ff',
                fillOpacity: 0.05,
                weight: 2,
                dashArray: '5,5'
            }).addTo(map);
        }
        
        // =========================================================
        // CARREGAMENTO DE IMAGEM
        // =========================================================
        
        async function loadImage() {
            const sat = document.getElementById('satellite').value;
            const product = document.getElementById('product').value;
            const method = document.getElementById('method').value;
            
            const btn = document.getElementById('loadBtn');
            btn.disabled = true;
            
            showLoading('Carregando imagem...');
            setProgress(10);
            
            try {
                let url = getImageUrl(sat, product);
                let bounds = BOUNDS.fd;
                
                console.log('üõ∞Ô∏è Carregando:', {sat, product, method, url, bounds});
                
                // Atualizar info
                document.getElementById('infoSat').textContent = sat.toUpperCase();
                document.getElementById('infoType').textContent = product;
                document.getElementById('infoMethod').textContent = method;
                
                // Remover overlay anterior
                if (overlay) map.removeLayer(overlay);
                
                setProgress(30);
                
                if (method === 'direct') {
                    showLoading('Carregando overlay direto...');
                    console.log('üìå M√©todo DIRETO (sem reproje√ß√£o)');
                    await loadDirect(url, bounds);
                } else {
                    showLoading('Iniciando REPROJE√á√ÉO...');
                    console.log('üîÑ M√©todo REPROJE√á√ÉO REAL');
                    await loadWithReprojection(url, bounds, product, sat);
                }
                
                // Atualizar bounds no painel
                document.getElementById('infoN').textContent = bounds.north + '¬∞';
                document.getElementById('infoS').textContent = bounds.south + '¬∞';
                document.getElementById('infoW').textContent = bounds.west + '¬∞';
                document.getElementById('infoE').textContent = bounds.east + '¬∞';
                
                document.getElementById('infoStatus').textContent = 'OK';
                document.getElementById('infoStatus').className = 'info-value ok';
                document.getElementById('statusText').textContent = 'Imagem carregada com sucesso';
                document.getElementById('timestamp').textContent = new Date().toLocaleTimeString();
                
                // Habilitar bot√£o de download
                document.getElementById('downloadBtn').disabled = false;
                
                setProgress(100);
                setTimeout(hideLoading, 300);
                
            } catch (err) {
                console.error('‚ùå ERRO:', err);
                document.getElementById('infoStatus').textContent = 'ERRO';
                document.getElementById('infoStatus').className = 'info-value err';
                document.getElementById('statusText').textContent = 'Erro: ' + err.message;
                hideLoading();
            }
            
            btn.disabled = false;
        }
        
        async function loadDirect(url, bounds) {
            // Carregar imagem diretamente com bounds aproximados
            const leafletBounds = [[bounds.south, bounds.west], [bounds.north, bounds.east]];
            
            overlay = L.imageOverlay(url + '?t=' + Date.now(), leafletBounds, {
                opacity: document.getElementById('opacity').value / 100,
                crossOrigin: 'anonymous'
            }).addTo(map);
            
            // No modo direto, n√£o temos canvas reprojetado
            currentCanvas = null;
            
            setProgress(90);
        }
        
        async function loadWithReprojection(url, bounds, type, sat) {
            try {
                // Carregar imagem
                console.log('üîÑ REPROJE√á√ÉO START:', {url, bounds, type, sat});
                const img = await loadImg(url + '?t=' + Date.now());
                console.log('‚úÖ Imagem carregada:', img.width, 'x', img.height);
                setProgress(50);
                
                // Obter qualidade selecionada
                const quality = document.getElementById('quality').value;
                const qualitySettings = {
                    low: { width: 600, interpolate: false },
                    medium: { width: 1200, interpolate: true },
                    high: { width: 2400, interpolate: true },
                    max: { width: 4800, interpolate: true }
                };
                const settings = qualitySettings[quality] || qualitySettings.medium;
                
                showLoading(`Reprojetando (${quality})...`);
                
                // Converter bounds para Web Mercator
                const mercBounds = {
                    minX: lonToMercatorX(bounds.west),
                    maxX: lonToMercatorX(bounds.east),
                    // Mercator inverte: norte tem Y maior
                    minY: latToMercatorY(bounds.south),
                    maxY: latToMercatorY(bounds.north)
                };
                
                // Canvas de sa√≠da - propor√ß√£o baseada em Mercator
                const outWidth = settings.width;
                const outHeight = Math.round(outWidth * (mercBounds.maxY - mercBounds.minY) / (mercBounds.maxX - mercBounds.minX));
                console.log('üìè Canvas sa√≠da:', outWidth, 'x', outHeight, '| Qualidade:', quality);
                console.log('üìê Mercator bounds:', mercBounds);
                
                const canvas = document.createElement('canvas');
                canvas.width = outWidth;
                canvas.height = outHeight;
                const ctx = canvas.getContext('2d');
                
                // Canvas fonte
                const srcCanvas = document.createElement('canvas');
                srcCanvas.width = img.width;
                srcCanvas.height = img.height;
                const srcCtx = srcCanvas.getContext('2d');
                srcCtx.drawImage(img, 0, 0);
                const srcData = srcCtx.getImageData(0, 0, img.width, img.height);
                console.log('üìä srcData:', srcData.width, 'x', srcData.height);
                
                // Canvas destino
                const outData = ctx.createImageData(outWidth, outHeight);
                
                // GOES-East est√° em -75.0¬∞ W
                const sat_lon = -75.0;
                console.log('üõ∞Ô∏è Sat√©lite longitude:', sat_lon);
            
            // Par√¢metros da imagem Full Disk GEOCOLOR
            // O disco terrestre ocupa a maior parte da imagem quadrada
            // Raio angular do limbo: ~8.7¬∞ = 0.1518 rad
            const scanMax = 0.1518;
            const imgRadius = Math.min(img.width, img.height) / 2;
            const scale = imgRadius / scanMax;
            const centerX = img.width / 2;
            const centerY = img.height / 2;
            
            console.log('üéØ Reproje√ß√£o params:', {scanMax, imgRadius, scale, centerX, centerY});
            
            let pixelsVisible = 0;
            
            console.log('üîÑ Iniciando reproje√ß√£o para Web Mercator...');
            
            for (let y = 0; y < outHeight; y++) {
                for (let x = 0; x < outWidth; x++) {
                    // Coordenadas em Web Mercator do pixel de sa√≠da
                    const mercX = mercBounds.minX + (x / outWidth) * (mercBounds.maxX - mercBounds.minX);
                    const mercY = mercBounds.maxY - (y / outHeight) * (mercBounds.maxY - mercBounds.minY);
                    
                    // Converter Mercator para lat/lon
                    const lon = mercatorXToLon(mercX);
                    const lat = mercatorYToLat(mercY);
                    
                    // Converter lat/lon para coordenadas de scan do sat√©lite
                    const scan = latLonToScan(lat, lon, sat_lon);
                    if (!scan) continue; // Ponto fora da vis√£o do sat√©lite
                    
                    // Mapear coordenadas de scan para pixels da imagem fonte
                    const srcX = centerX + scan.x * scale;
                    const srcY = centerY - scan.y * scale;
                    
                    // Verificar limites
                    if (srcX < 0 || srcX >= img.width - 1 || srcY < 0 || srcY >= img.height - 1) continue;
                    
                    // Interpola√ß√£o: bilinear para qualidade, nearest neighbor para velocidade
                    let r, g, b;
                    if (settings.interpolate) {
                        const pixel = bilinear(srcData, srcX, srcY);
                        r = pixel.r; g = pixel.g; b = pixel.b;
                    } else {
                        // Nearest neighbor - mais r√°pido
                        const sx = Math.floor(srcX);
                        const sy = Math.floor(srcY);
                        const srcIdx = (sy * srcData.width + sx) * 4;
                        r = srcData.data[srcIdx];
                        g = srcData.data[srcIdx + 1];
                        b = srcData.data[srcIdx + 2];
                    }
                    
                    const idx = (y * outWidth + x) * 4;
                    outData.data[idx] = r;
                    outData.data[idx + 1] = g;
                    outData.data[idx + 2] = b;
                    outData.data[idx + 3] = 255;
                    pixelsVisible++;
                }
                
                // Atualizar progresso
                if (y % 50 === 0) {
                    setProgress(50 + (y / outHeight) * 45);
                    await sleep(1);
                }
            }
            
            console.log('üìä Reproje√ß√£o completa:', pixelsVisible, 'pixels reprojetados');
            
            ctx.putImageData(outData, 0, 0);
            
            // Armazenar canvas para download
            currentCanvas = canvas;
            
            // Criar overlay
            const dataUrl = canvas.toDataURL('image/png');
            console.log('‚úÖ Imagem reprojetada, tamanho:', dataUrl.length);
            
            const leafletBounds = [[bounds.south, bounds.west], [bounds.north, bounds.east]];
            
            overlay = L.imageOverlay(dataUrl, leafletBounds, {
                opacity: document.getElementById('opacity').value / 100
            }).addTo(map);
            
            // Centralizar no Brasil
            map.fitBounds(leafletBounds);
            
            console.log('‚úÖ Overlay adicionado ao mapa!');
            
            } catch (err) {
                console.error('‚ùå ERRO em loadWithReprojection:', err);
                throw err;
            }
        }
        
        // =========================================================
        // FUN√á√ïES DE PROJE√á√ÉO WEB MERCATOR (EPSG:3857)
        // =========================================================
        
        const EARTH_RADIUS = 6378137; // metros
        
        function lonToMercatorX(lon) {
            return lon * Math.PI / 180 * EARTH_RADIUS;
        }
        
        function latToMercatorY(lat) {
            // Limitar para evitar infinito
            const latClamped = Math.max(-85, Math.min(85, lat));
            const latRad = latClamped * Math.PI / 180;
            return Math.log(Math.tan(Math.PI / 4 + latRad / 2)) * EARTH_RADIUS;
        }
        
        function mercatorXToLon(x) {
            return x / EARTH_RADIUS * 180 / Math.PI;
        }
        
        function mercatorYToLat(y) {
            return (2 * Math.atan(Math.exp(y / EARTH_RADIUS)) - Math.PI / 2) * 180 / Math.PI;
        }
        
        // =========================================================
        // FUN√á√ïES DE PROJE√á√ÉO - GOES-R ABI Fixed Grid
        // Refer√™ncia: GOES-R PUG Volume 3, L1b Products
        // =========================================================
        
        function latLonToScan(lat, lon, sat_lon) {
            // Converte lat/lon para coordenadas de scan do GOES-R ABI
            // Baseado exatamente no GOES-R PUG Volume 3
            
            const DEG2RAD = Math.PI / 180;
            
            // Constantes GRS80/WGS84
            const req = 6378137.0;           // Raio equatorial (m)
            const rpol = 6356752.31414;      // Raio polar (m)
            const H = 42164160.0;            // Dist√¢ncia sat√©lite ao centro da Terra (m)
            const e2 = 1 - (rpol * rpol) / (req * req);  // Excentricidade ao quadrado
            
            const lat_rad = lat * DEG2RAD;
            const lon_rad = lon * DEG2RAD;
            const sat_lon_rad = sat_lon * DEG2RAD;
            
            // Latitude geoc√™ntrica
            const lat_geo = Math.atan((rpol * rpol / (req * req)) * Math.tan(lat_rad));
            
            // Raio geoc√™ntrico
            const rc = rpol / Math.sqrt(1 - e2 * Math.cos(lat_geo) * Math.cos(lat_geo));
            
            // Diferen√ßa de longitude
            const dlon = lon_rad - sat_lon_rad;
            
            // Coordenadas do ponto vistas do sat√©lite
            const sx = H - rc * Math.cos(lat_geo) * Math.cos(dlon);
            const sy = -rc * Math.cos(lat_geo) * Math.sin(dlon);
            const sz = rc * Math.sin(lat_geo);
            
            // Verificar visibilidade - SIMPLIFICADO
            // Um ponto √© vis√≠vel se estiver no mesmo lado da Terra que o sat√©lite
            // e dentro de ~81 graus do ponto subsat√©lite
            const dlon_deg = Math.abs(lon - sat_lon);
            if (dlon_deg > 81 || Math.abs(lat) > 81) return null;
            
            const sn = Math.sqrt(sx * sx + sy * sy + sz * sz);
            
            // √Çngulos de scan
            const x = Math.asin(-sy / sn);
            const y = Math.atan(sz / sx);
            
            return { x, y };
        }
        
        function bilinear(srcData, x, y) {
            const x0 = Math.floor(x);
            const y0 = Math.floor(y);
            const x1 = Math.min(x0 + 1, srcData.width - 1);
            const y1 = Math.min(y0 + 1, srcData.height - 1);
            
            const fx = x - x0;
            const fy = y - y0;
            
            const w00 = (1 - fx) * (1 - fy);
            const w10 = fx * (1 - fy);
            const w01 = (1 - fx) * fy;
            const w11 = fx * fy;
            
            const i00 = (y0 * srcData.width + x0) * 4;
            const i10 = (y0 * srcData.width + x1) * 4;
            const i01 = (y1 * srcData.width + x0) * 4;
            const i11 = (y1 * srcData.width + x1) * 4;
            
            return {
                r: Math.round(srcData.data[i00] * w00 + srcData.data[i10] * w10 + srcData.data[i01] * w01 + srcData.data[i11] * w11),
                g: Math.round(srcData.data[i00+1] * w00 + srcData.data[i10+1] * w10 + srcData.data[i01+1] * w01 + srcData.data[i11+1] * w11),
                b: Math.round(srcData.data[i00+2] * w00 + srcData.data[i10+2] * w10 + srcData.data[i01+2] * w01 + srcData.data[i11+2] * w11)
            };
        }
        
        // =========================================================
        // DOWNLOAD DA IMAGEM
        // =========================================================
        
        function downloadImage() {
            if (!currentCanvas) {
                alert('Nenhuma imagem reprojetada dispon√≠vel. Use o m√©todo de REPROJE√á√ÉO REAL primeiro.');
                return;
            }
            
            try {
                // Gerar nome do arquivo com data/hora e configura√ß√µes
                const sat = document.getElementById('satellite').value.toUpperCase();
                const product = document.getElementById('product').value;
                const quality = document.getElementById('quality').value;
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `${sat}_${product}_${quality}_${timestamp}.png`;
                
                // Converter canvas para blob e fazer download
                currentCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log('‚úÖ Download iniciado:', filename);
                    document.getElementById('statusText').textContent = 'Download da imagem: ' + filename;
                }, 'image/png');
                
            } catch (err) {
                console.error('‚ùå Erro ao fazer download:', err);
                alert('Erro ao fazer download: ' + err.message);
            }
        }
        
        // =========================================================
        // UTILIDADES
        // =========================================================
        
        function loadImg(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Falha ao carregar imagem'));
                img.src = url;
            });
        }
        
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        
        function updateOpacity() {
            const v = document.getElementById('opacity').value;
            document.getElementById('opacityVal').textContent = v + '%';
            if (overlay) overlay.setOpacity(v / 100);
        }
        
        function fitBounds() {
            const b = BOUNDS.fd;
            map.fitBounds([[b.south, b.west], [b.north, b.east]]);
        }
        
        function zoomShip() {
            map.setView([SHIP.lat, SHIP.lon], 6);
        }
        
        function showLoading(text) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loading').classList.remove('hidden');
        }
        
        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }
        
        function setProgress(pct) {
            document.getElementById('progressFill').style.width = pct + '%';
            document.getElementById('progressText').textContent = Math.round(pct) + '%';
        }
        
        // =========================================================
        // DMW - DERIVED MOTION WINDS
        // =========================================================
        
        let dmwEnabled = false;
        let dmwLayer = null;
        let dmwMarkers = [];
        let dmwData = null;
        
        function toggleDMWWinds() {
            const btn = document.getElementById('toggleDMW');
            dmwEnabled = !dmwEnabled;
            
            if (dmwEnabled) {
                btn.classList.add('active');
                document.getElementById('windLegend').classList.add('show');
                loadDMWWinds();
            } else {
                btn.classList.remove('active');
                document.getElementById('windLegend').classList.remove('show');
                clearDMWLayer();
            }
        }
        
        function clearDMWLayer() {
            // Remover marcadores existentes
            dmwMarkers.forEach(m => map.removeLayer(m));
            dmwMarkers = [];
            if (dmwLayer) {
                map.removeLayer(dmwLayer);
                dmwLayer = null;
            }
        }
        
        async function loadDMWWinds() {
            if (!dmwEnabled) return;
            
            const level = document.getElementById('windLevel').value;
            const satellite = document.getElementById('satellite').value;
            
            showLoading('Carregando ventos DMW do GOES...');
            setProgress(10);
            
            try {
                // Buscar dados DMW do GOES via NOAA THREDDS (tem CORS!)
                // URL base do THREDDS catalog para dados GOES em tempo real
                const satNum = satellite.replace('goes', '');
                
                // N√≠veis de press√£o para filtrar
                const levelConfig = {
                    'low': { min: 700, max: 1100, name: 'Baixo N√≠vel (<3km)' },
                    'mid': { min: 400, max: 700, name: 'N√≠vel M√©dio (3-7km)' },
                    'high': { min: 100, max: 400, name: 'Alto N√≠vel (>7km)' },
                    'all': { min: 100, max: 1100, name: 'Todos os N√≠veis' }
                };
                
                const levelInfo = levelConfig[level] || levelConfig['low'];
                
                console.log(`üõ∞Ô∏è Buscando DMW GOES-${satNum}: ${levelInfo.name}`);
                
                // NOAA Unidata THREDDS - Dados GOES em tempo real com suporte JSON
                // https://thredds.ucar.edu/thredds/catalog/satellite/goes/east/products/
                const threddsBase = 'https://thredds.ucar.edu/thredds/ncss/grid/satellite/goes';
                const region = satNum === '18' ? 'west' : 'east';
                
                // Tentar buscar do cat√°logo THREDDS
                // Usando endpoint alternativo que retorna JSON
                const catalogUrl = `https://thredds.ucar.edu/thredds/catalog/satellite/goes/${region}/products/CloudAndMoistureImagery/FullDisk/catalog.json`;
                
                console.log('üì° Verificando cat√°logo THREDDS...');
                
                // Como THREDDS pode n√£o ter dados DMW diretamente acess√≠veis,
                // vamos usar o AWS S3 public bucket com um proxy CORS
                // O corsproxy.io √© um servi√ßo gratuito de proxy CORS
                
                const bucket = `noaa-goes${satNum}`;
                const now = new Date();
                const year = now.getUTCFullYear();
                const doy = getDayOfYear(now);
                const hour = now.getUTCHours().toString().padStart(2, '0');
                
                // Listar arquivos DMW dispon√≠veis via S3 REST API
                const s3ListUrl = `https://${bucket}.s3.amazonaws.com/?list-type=2&prefix=ABI-L2-DMWF/${year}/${doy}/${hour}/&max-keys=10`;
                
                console.log('üîç Buscando arquivos S3:', s3ListUrl);
                setProgress(20);
                
                // Tentar buscar lista de arquivos (S3 tem CORS para listagem)
                let dmwFileKey = null;
                
                try {
                    const listResp = await fetch(s3ListUrl);
                    if (listResp.ok) {
                        const xmlText = await listResp.text();
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                        const keys = xmlDoc.getElementsByTagName('Key');
                        
                        if (keys.length > 0) {
                            // Pegar o arquivo mais recente
                            dmwFileKey = keys[keys.length - 1].textContent;
                            console.log('üìÅ Arquivo DMW encontrado:', dmwFileKey);
                        }
                    }
                } catch (e) {
                    console.log('‚ö†Ô∏è Erro ao listar S3:', e);
                }
                
                // Se n√£o encontrou na hora atual, tentar hora anterior
                if (!dmwFileKey) {
                    const prevHour = (parseInt(hour) - 1 + 24) % 24;
                    const prevHourStr = prevHour.toString().padStart(2, '0');
                    const prevDoy = prevHour === 23 ? doy - 1 : doy;
                    
                    const s3PrevUrl = `https://${bucket}.s3.amazonaws.com/?list-type=2&prefix=ABI-L2-DMWF/${year}/${prevDoy}/${prevHourStr}/&max-keys=10`;
                    
                    try {
                        const listResp = await fetch(s3PrevUrl);
                        if (listResp.ok) {
                            const xmlText = await listResp.text();
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                            const keys = xmlDoc.getElementsByTagName('Key');
                            
                            if (keys.length > 0) {
                                dmwFileKey = keys[keys.length - 1].textContent;
                                console.log('üìÅ Arquivo DMW (hora anterior):', dmwFileKey);
                            }
                        }
                    } catch (e) {
                        console.log('‚ö†Ô∏è Erro ao listar S3 (hora anterior):', e);
                    }
                }
                
                setProgress(40);
                
                if (!dmwFileKey) {
                    throw new Error('Nenhum arquivo DMW dispon√≠vel no momento');
                }
                
                // Baixar arquivo NetCDF via proxy CORS
                // Usando corsproxy.io que √© gratuito e confi√°vel
                const ncUrl = `https://${bucket}.s3.amazonaws.com/${dmwFileKey}`;
                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(ncUrl)}`;
                
                console.log('üì• Baixando NetCDF via proxy:', ncUrl);
                
                const ncResp = await fetch(proxyUrl);
                if (!ncResp.ok) {
                    throw new Error(`Erro ao baixar arquivo: ${ncResp.status}`);
                }
                
                const ncBuffer = await ncResp.arrayBuffer();
                console.log(`‚úÖ Arquivo baixado: ${(ncBuffer.byteLength / 1024 / 1024).toFixed(1)} MB`);
                
                setProgress(60);
                
                // Processar NetCDF usando netcdfjs
                // Carregar biblioteca se n√£o estiver dispon√≠vel
                if (typeof NetCDF === 'undefined') {
                    console.log('üì¶ Carregando biblioteca NetCDF...');
                    await loadScript('https://cdn.jsdelivr.net/npm/netcdfjs@2.0.2/dist/netcdfjs.min.js');
                }
                
                const nc = new NetCDF(ncBuffer);
                console.log('üìä Vari√°veis NetCDF:', nc.variables);
                
                // Extrair dados de vento
                const lat = nc.getDataVariable('lat');
                const lon = nc.getDataVariable('lon');
                const windSpeed = nc.getDataVariable('wind_speed');
                const windDir = nc.getDataVariable('wind_direction');
                const pressure = nc.getDataVariable('pressure');
                
                setProgress(80);
                
                // Limpar camada anterior
                clearDMWLayer();
                dmwLayer = L.layerGroup().addTo(map);
                
                const winds = [];
                const step = Math.max(1, Math.floor(lat.length / 500)); // Limitar a ~500 pontos
                
                for (let i = 0; i < lat.length; i += step) {
                    const p = pressure[i];
                    
                    // Filtrar por n√≠vel de press√£o
                    if (p < levelInfo.min || p > levelInfo.max) continue;
                    
                    const speed = windSpeed[i];
                    const dir = windDir[i];
                    
                    if (isNaN(speed) || isNaN(dir) || speed <= 0) continue;
                    
                    // Converter m/s para knots
                    const speedKt = speed * 1.94384;
                    
                    winds.push({
                        lat: lat[i],
                        lon: lon[i],
                        speed_kt: speedKt,
                        direction: dir,
                        pressure: p
                    });
                    
                    // Cor baseada na velocidade
                    const color = getWindColor(speedKt);
                    
                    // Criar seta de vento
                    const arrow = createWindArrow(lat[i], lon[i], dir, speedKt, color);
                    arrow.addTo(dmwLayer);
                    dmwMarkers.push(arrow);
                }
                
                // Atualizar info
                document.getElementById('windInfo').textContent = 
                    `${winds.length} vetores | ${levelInfo.name}`;
                
                setProgress(100);
                setTimeout(hideLoading, 300);
                
                document.getElementById('statusText').textContent = 
                    `Ventos DMW GOES-${satNum}: ${winds.length} vetores`;
                
            } catch (err) {
                console.error('‚ùå Erro DMW:', err);
                document.getElementById('windInfo').textContent = 'Erro ao carregar';
                document.getElementById('statusText').textContent = 'Erro: ' + err.message;
                hideLoading();
            }
        }
        
        function getDayOfYear(date) {
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay).toString().padStart(3, '0');
        }
        
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        function getWindColor(speedKt) {
            if (speedKt < 10) return '#00ff00';      // Verde - Calmo
            if (speedKt < 20) return '#ffff00';      // Amarelo - Fraco
            if (speedKt < 30) return '#ffa500';      // Laranja - Moderado
            if (speedKt < 40) return '#ff6600';      // Laranja escuro - Forte
            return '#ff0000';                         // Vermelho - Muito forte
        }
        
        function createWindArrow(lat, lon, direction, speed, color) {
            // Tamanho da seta baseado na velocidade (normalizado para visualiza√ß√£o)
            const arrowLength = Math.min(0.3 + speed * 0.01, 0.8);
            
            // Converter dire√ß√£o meteorol√≥gica (de onde vem) para dire√ß√£o vetorial (para onde vai)
            const dirRad = (direction + 180) * Math.PI / 180;
            
            // Calcular ponto final da seta
            const endLat = lat + arrowLength * Math.cos(dirRad);
            const endLon = lon + arrowLength * Math.sin(dirRad) / Math.cos(lat * Math.PI / 180);
            
            // Criar polyline com decorador de seta
            const line = L.polyline([[lat, lon], [endLat, endLon]], {
                color: color,
                weight: 2,
                opacity: 0.8
            });
            
            // Adicionar popup
            line.bindPopup(`
                <div style="text-align:center;">
                    <b>üå¨Ô∏è Vento DMW</b><br>
                    <b>${speed.toFixed(1)} kt</b> (${(speed * 0.514444).toFixed(1)} m/s)<br>
                    Dire√ß√£o: ${direction.toFixed(0)}¬∞<br>
                    Lat: ${lat.toFixed(2)}¬∞ | Lon: ${lon.toFixed(2)}¬∞
                </div>
            `, { className: 'wind-popup' });
            
            // Adicionar cabe√ßa da seta como tri√¢ngulo
            const arrowHead = createArrowHead(endLat, endLon, direction, color);
            
            // Retornar grupo
            return L.layerGroup([line, arrowHead]);
        }
        
        function createArrowHead(lat, lon, direction, color) {
            // Criar marcador com √≠cone de seta rotacionado
            const icon = L.divIcon({
                html: `<div style="
                    width: 0;
                    height: 0;
                    border-left: 5px solid transparent;
                    border-right: 5px solid transparent;
                    border-bottom: 10px solid ${color};
                    transform: rotate(${direction + 180}deg);
                    transform-origin: center center;
                    filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
                "></div>`,
                iconSize: [10, 10],
                iconAnchor: [5, 5],
                className: 'wind-arrow-head'
            });
            
            return L.marker([lat, lon], { icon, interactive: false });
        }
        
        // Recarregar ventos quando mover o mapa
        let dmwReloadTimeout = null;
        
        function setupDMWAutoReload() {
            map.on('moveend', () => {
                if (dmwEnabled) {
                    // Debounce para n√£o recarregar muito frequentemente
                    clearTimeout(dmwReloadTimeout);
                    dmwReloadTimeout = setTimeout(() => {
                        loadDMWWinds();
                    }, 1000);
                }
            });
        }
        
        // =========================================================
        // INIT
        // =========================================================
        
        init();
        setupDMWAutoReload();
    </script>
</body>
</html>
