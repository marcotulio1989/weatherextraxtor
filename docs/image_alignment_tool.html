<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ∞Ô∏è Alinhamento de Imagem Sat√©lite - ECDIS</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a15;
            color: #eee;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Painel de Controle */
        .control-panel {
            width: 340px;
            background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            z-index: 1000;
            flex-shrink: 0;
        }

        .control-panel h1 {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #e94560;
            text-align: center;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }

        .control-section {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(15, 52, 96, 0.5);
            border-radius: 10px;
        }

        .control-section h3 {
            color: #00d9ff;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-size: 0.85em;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e94560, #c23a51);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #0f3460, #16213e);
            color: #00d9ff;
            border: 1px solid #00d9ff;
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894, #00a381);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
            color: #1a1a2e;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* √Årea da Imagem */
        .image-area {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #imageContainer {
            position: relative;
            transform-origin: center center;
        }

        #satelliteImage {
            max-width: none;
            max-height: none;
            display: block;
            image-rendering: auto;
        }

        /* Pontos de controle na imagem */
        .image-point {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #ff00ff;
            border: 3px solid #fff;
            border-radius: 50%;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            box-shadow: 0 0 15px rgba(255,0,255,0.8);
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        .image-point:hover {
            transform: translate(-50%, -50%) scale(1.2);
            background: #00ffff;
        }

        /* Lista de GCPs */
        .gcp-list {
            max-height: 250px;
            overflow-y: auto;
            background: #0a0a15;
            border-radius: 5px;
            padding: 8px;
        }

        .gcp-item {
            padding: 8px;
            margin-bottom: 6px;
            background: rgba(15, 52, 96, 0.7);
            border-radius: 5px;
            font-size: 0.8em;
            border-left: 3px solid #ff00ff;
        }

        .gcp-item .gcp-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .gcp-item .gcp-number {
            background: #ff00ff;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .gcp-item .gcp-coords {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .gcp-item input {
            width: 100%;
            padding: 5px;
            background: #1a1a2e;
            border: 1px solid #0f3460;
            color: #fff;
            border-radius: 3px;
            text-align: center;
            font-size: 0.9em;
        }

        .gcp-item label {
            font-size: 0.75em;
            color: #888;
        }

        .gcp-item button.remove-btn {
            background: #e94560;
            border: none;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-left: auto;
        }

        .gcp-mode-active {
            background: linear-gradient(135deg, #ff00ff, #cc00cc) !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255,0,255,0.5); }
            50% { box-shadow: 0 0 20px rgba(255,0,255,0.8); }
        }

        /* Controles de zoom da imagem */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 500;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(22, 33, 62, 0.9);
            border: 1px solid #0f3460;
            color: #00d9ff;
            font-size: 20px;
            cursor: pointer;
            border-radius: 5px;
        }

        .zoom-btn:hover {
            background: #0f3460;
        }

        .zoom-level {
            text-align: center;
            font-size: 0.8em;
            color: #888;
            padding: 5px;
        }

        /* Info de posi√ß√£o do mouse */
        .mouse-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.85em;
            z-index: 500;
            border: 1px solid #0f3460;
        }

        /* Modal para preview de alinhamento */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #16213e;
            border-radius: 15px;
            width: 95%;
            height: 90%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 15px 20px;
            background: #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            color: #00d9ff;
            font-size: 1.2em;
        }

        .close-modal {
            font-size: 1.5em;
            color: #e94560;
            cursor: pointer;
            background: none;
            border: none;
        }

        #previewMap {
            flex: 1;
            width: 100%;
        }

        /* Status */
        .status-bar {
            font-size: 0.8em;
            color: #888;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }

        .instructions {
            font-size: 0.75em;
            color: #666;
            line-height: 1.4;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Painel de Controle -->
        <div class="control-panel">
            <h1>üõ∞Ô∏è Alinhamento ECDIS</h1>

            <!-- Carregar Imagem -->
            <div class="control-section">
                <h3>üìÅ Carregar Imagem</h3>
                <div class="file-input-wrapper">
                    <button class="btn btn-primary">üìÇ Selecionar Arquivo</button>
                    <input type="file" id="imageInput" accept="image/*">
                </div>
                <input type="text" id="imageUrl" placeholder="Ou cole URL da imagem..." 
                       style="width: 100%; padding: 8px; margin-top: 8px; background: #1a1a2e; border: 1px solid #0f3460; color: #fff; border-radius: 5px; font-size: 0.85em;">
                <button class="btn btn-secondary" onclick="loadImageFromUrl()" style="margin-top: 5px;">üîó Carregar URL</button>
                <div class="status-bar" id="imageStatus">Nenhuma imagem carregada</div>
            </div>

            <!-- Marcar Pontos -->
            <div class="control-section">
                <h3>üìå Pontos de Refer√™ncia (GCP)</h3>
                <button class="btn btn-primary" id="btnGcpMode" onclick="toggleGcpMode()">
                    üéØ Marcar Ponto na Imagem
                </button>
                <p class="instructions" id="gcpInstructions" style="display:none;">
                    ‚ú® Clique na imagem para marcar um ponto.<br>
                    üìç Digite as coordenadas do ECDIS nos campos.<br>
                    üî¢ M√≠nimo 2 pontos para alinhar.
                </p>
                
                <button class="btn" id="btnMeasureMode" onclick="toggleMeasureMode()" style="background:#6c5ce7; margin-top:8px;">
                    üìè Medir Dist√¢ncia (Range & Bearing)
                </button>
                <p class="instructions" id="measureInstructions" style="display:none;">
                    üìç Clique no PRIMEIRO ponto de medi√ß√£o.<br>
                    üìç Clique no SEGUNDO ponto.<br>
                    üìê Ver√° a dist√¢ncia e rumo entre eles.
                </p>
                <div id="measureResult" style="display:none; background:#2a2a4a; padding:12px; border-radius:8px; margin-top:8px; border:2px solid #6c5ce7;">
                </div>
                
                <div class="gcp-list" id="gcpList">
                    <p style="color:#666; font-size:0.85em; text-align:center;">
                        Nenhum ponto marcado
                    </p>
                </div>
                
                <button class="btn btn-warning" onclick="clearAllPoints()" style="margin-top:8px;">
                    üóëÔ∏è Limpar Pontos
                </button>
            </div>

            <!-- A√ß√µes -->
            <div class="control-section">
                <h3>‚ö° A√ß√µes</h3>
                <button class="btn btn-success" onclick="previewAlignment()" id="btnPreview">
                    üó∫Ô∏è Ver Alinhamento no Mapa
                </button>
                <button class="btn" onclick="downloadImage()" style="background:#e17055;">
                    üíæ Baixar Imagem
                </button>
                <button class="btn btn-secondary" onclick="exportAlignment()">
                    üì§ Exportar JSON
                </button>
                <button class="btn btn-secondary" onclick="importAlignment()">
                    üì• Importar JSON
                </button>
            </div>

            <!-- Resumo -->
            <div class="control-section">
                <h3>üìä Resumo</h3>
                <div id="summaryDisplay" class="status-bar">
                    Carregue uma imagem e marque os pontos
                </div>
            </div>
        </div>

        <!-- √Årea da Imagem -->
        <div class="image-area" id="imageArea">
            <div id="imageContainer">
                <img id="satelliteImage" src="" alt="Carregue uma imagem" style="display:none;">
            </div>
            
            <div class="mouse-info" id="mouseInfo">
                Pixel: -- , --
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomImage(1.2)">+</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="zoom-btn" onclick="zoomImage(0.8)">‚àí</button>
                <button class="zoom-btn" onclick="resetZoom()" style="font-size:12px;">‚ü≤</button>
            </div>
        </div>
    </div>

    <!-- Modal de Preview -->
    <div class="modal" id="previewModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üó∫Ô∏è Preview do Alinhamento</h2>
                <button class="close-modal" onclick="closePreview()">√ó</button>
            </div>
            <div id="previewMap"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // ===== ESTADO GLOBAL =====
        let imageElement = null;
        let imageLoaded = false;
        let imageNaturalSize = { width: 0, height: 0 };
        let currentZoom = 1;
        let gcpMode = false;
        let gcpPoints = [];  // {id, pixelX, pixelY, lat, lng, element}
        let gcpCounter = 0;
        let isDragging = false;
        let dragTarget = null;
        let dragOffset = { x: 0, y: 0 };
        let imageOffset = { x: 0, y: 0 };
        let previewMap = null;
        
        // Estado para medi√ß√£o
        let measureMode = false;
        let measurePoints = []; // {pixelX, pixelY, lat, lng}
        let measureMarkers = [];

        // ===== INICIALIZA√á√ÉO =====
        document.addEventListener('DOMContentLoaded', function() {
            imageElement = document.getElementById('satelliteImage');
            setupImageDrag();
            setupMouseTracking();
        });

        // ===== CARREGAR IMAGEM =====
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    loadImage(event.target.result, file.name);
                };
                reader.readAsDataURL(file);
            }
        });

        function loadImageFromUrl() {
            const url = document.getElementById('imageUrl').value.trim();
            if (url) {
                loadImage(url, 'URL');
            }
        }

        function loadImage(src, name) {
            const status = document.getElementById('imageStatus');
            status.innerHTML = '‚è≥ Carregando...';
            status.style.color = '#ffff00';

            imageElement.onload = function() {
                imageNaturalSize = {
                    width: this.naturalWidth,
                    height: this.naturalHeight
                };
                
                imageElement.style.display = 'block';
                imageLoaded = true;
                resetZoom();
                
                status.innerHTML = `‚úÖ ${name}<br>üìê ${imageNaturalSize.width} √ó ${imageNaturalSize.height} px`;
                status.style.color = '#00ff00';
                
                updateSummary();
            };

            imageElement.onerror = function() {
                status.innerHTML = '‚ùå Erro ao carregar imagem';
                status.style.color = '#ff4444';
            };

            imageElement.src = src;
        }

        // ===== ZOOM DA IMAGEM =====
        function zoomImage(factor) {
            currentZoom *= factor;
            currentZoom = Math.max(0.1, Math.min(10, currentZoom));
            applyZoom();
        }

        function resetZoom() {
            if (!imageLoaded) return;
            
            const area = document.getElementById('imageArea');
            const areaRect = area.getBoundingClientRect();
            
            // Calcular zoom para caber na √°rea
            const scaleX = (areaRect.width - 100) / imageNaturalSize.width;
            const scaleY = (areaRect.height - 100) / imageNaturalSize.height;
            currentZoom = Math.min(scaleX, scaleY, 1);
            
            imageOffset = { x: 0, y: 0 };
            applyZoom();
        }

        function applyZoom() {
            const container = document.getElementById('imageContainer');
            container.style.transform = `translate(${imageOffset.x}px, ${imageOffset.y}px) scale(${currentZoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
            updatePointPositions();
        }

        // ===== ARRASTAR IMAGEM =====
        function setupImageDrag() {
            const area = document.getElementById('imageArea');
            
            area.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('image-point')) return;
                if (gcpMode) return;
                
                isDragging = true;
                dragTarget = 'image';
                dragOffset = {
                    x: e.clientX - imageOffset.x,
                    y: e.clientY - imageOffset.y
                };
                area.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                if (dragTarget === 'image') {
                    imageOffset.x = e.clientX - dragOffset.x;
                    imageOffset.y = e.clientY - dragOffset.y;
                    applyZoom();
                } else if (dragTarget && dragTarget.type === 'point') {
                    updatePointDrag(e, dragTarget.point);
                }
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
                dragTarget = null;
                document.getElementById('imageArea').style.cursor = gcpMode ? 'crosshair' : 'grab';
            });
        }

        // ===== RASTREAR MOUSE =====
        function setupMouseTracking() {
            const area = document.getElementById('imageArea');
            
            area.addEventListener('mousemove', function(e) {
                if (!imageLoaded) return;
                
                const pixel = clientToImagePixel(e.clientX, e.clientY);
                if (pixel) {
                    document.getElementById('mouseInfo').innerHTML = 
                        `Pixel: <b>${Math.round(pixel.x)}</b> , <b>${Math.round(pixel.y)}</b>`;
                }
            });

            area.addEventListener('click', function(e) {
                if (gcpMode && !e.target.classList.contains('image-point')) {
                    addGcpPoint(e);
                }
                if (measureMode && !e.target.classList.contains('measure-marker')) {
                    addMeasurePoint(e);
                }
            });
        }

        function clientToImagePixel(clientX, clientY) {
            const container = document.getElementById('imageContainer');
            const rect = container.getBoundingClientRect();
            const imgRect = imageElement.getBoundingClientRect();
            
            // Posi√ß√£o relativa √† imagem escalada
            const relX = clientX - imgRect.left;
            const relY = clientY - imgRect.top;
            
            // Converter para coordenadas de pixel original
            const pixelX = relX / currentZoom;
            const pixelY = relY / currentZoom;
            
            if (pixelX >= 0 && pixelX <= imageNaturalSize.width &&
                pixelY >= 0 && pixelY <= imageNaturalSize.height) {
                return { x: pixelX, y: pixelY };
            }
            return null;
        }

        // ===== GCP POINTS =====
        function toggleGcpMode() {
            gcpMode = !gcpMode;
            const btn = document.getElementById('btnGcpMode');
            const instructions = document.getElementById('gcpInstructions');
            const area = document.getElementById('imageArea');
            
            if (gcpMode) {
                // Desativar modo medi√ß√£o se estiver ativo
                if (measureMode) toggleMeasureMode();
                
                btn.classList.add('gcp-mode-active');
                btn.innerHTML = 'üéØ CLIQUE NA IMAGEM!';
                instructions.style.display = 'block';
                area.style.cursor = 'crosshair';
            } else {
                btn.classList.remove('gcp-mode-active');
                btn.innerHTML = 'üéØ Marcar Ponto na Imagem';
                instructions.style.display = 'none';
                area.style.cursor = 'grab';
            }
        }

        // ===== FUN√á√ïES DE MEDI√á√ÉO (RANGE & BEARING) =====
        function toggleMeasureMode() {
            measureMode = !measureMode;
            const btn = document.getElementById('btnMeasureMode');
            const instructions = document.getElementById('measureInstructions');
            const area = document.getElementById('imageArea');
            
            if (measureMode) {
                // Desativar modo GCP se estiver ativo
                if (gcpMode) toggleGcpMode();
                
                // Limpar medi√ß√£o anterior
                clearMeasurePoints();
                
                btn.style.background = '#00b894';
                btn.innerHTML = 'üìè CLIQUE 2 PONTOS NA IMAGEM!';
                instructions.style.display = 'block';
                area.style.cursor = 'crosshair';
            } else {
                btn.style.background = '#6c5ce7';
                btn.innerHTML = 'üìè Medir Dist√¢ncia (Range & Bearing)';
                instructions.style.display = 'none';
                area.style.cursor = 'grab';
            }
        }

        function clearMeasurePoints() {
            measureMarkers.forEach(m => m.remove());
            measureMarkers = [];
            measurePoints = [];
            document.getElementById('measureResult').style.display = 'none';
            
            // Remover linha de medi√ß√£o se existir
            const existingLine = document.getElementById('measureLine');
            if (existingLine) existingLine.remove();
        }

        function addMeasurePoint(e) {
            if (!imageLoaded) return;
            if (measurePoints.length >= 2) {
                clearMeasurePoints();
            }

            const pixel = clientToImagePixel(e.clientX, e.clientY);
            if (!pixel) return;

            // Calcular coordenada geogr√°fica deste pixel usando alinhamento
            const geo = pixelToGeo(pixel.x, pixel.y);
            if (!geo) {
                alert('Configure pelo menos 2 pontos GCP com coordenadas primeiro!');
                return;
            }

            const pointNum = measurePoints.length + 1;

            // Criar marcador visual
            const marker = document.createElement('div');
            marker.className = 'measure-marker';
            marker.innerHTML = pointNum;
            marker.style.cssText = `
                position: absolute;
                width: 24px;
                height: 24px;
                background: #6c5ce7;
                border: 2px solid white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                font-size: 12px;
                transform: translate(-50%, -50%);
                z-index: 200;
                pointer-events: none;
                left: ${pixel.x * currentZoom}px;
                top: ${pixel.y * currentZoom}px;
            `;
            document.getElementById('imageContainer').appendChild(marker);
            measureMarkers.push(marker);

            measurePoints.push({
                pixelX: pixel.x,
                pixelY: pixel.y,
                lat: geo.lat,
                lng: geo.lng
            });

            // Se temos 2 pontos, calcular e mostrar resultado
            if (measurePoints.length === 2) {
                drawMeasureLine();
                showMeasureResult();
                toggleMeasureMode();
            }
        }

        function pixelToGeo(pixelX, pixelY) {
            // Calcular coordenadas geogr√°ficas a partir do alinhamento GCP
            const validPoints = gcpPoints.filter(p => p.lat !== 0 || p.lng !== 0);
            if (validPoints.length < 2) return null;

            // Usar mesma l√≥gica do calculateAlignment
            let minPixelX = Infinity, maxPixelX = -Infinity;
            let minPixelY = Infinity, maxPixelY = -Infinity;

            validPoints.forEach(p => {
                minPixelX = Math.min(minPixelX, p.pixelX);
                maxPixelX = Math.max(maxPixelX, p.pixelX);
                minPixelY = Math.min(minPixelY, p.pixelY);
                maxPixelY = Math.max(maxPixelY, p.pixelY);
            });

            const pixelRangeX = maxPixelX - minPixelX;
            const pixelRangeY = maxPixelY - minPixelY;

            let minLat = Infinity, maxLat = -Infinity;
            let minLng = Infinity, maxLng = -Infinity;

            validPoints.forEach(p => {
                minLat = Math.min(minLat, p.lat);
                maxLat = Math.max(maxLat, p.lat);
                minLng = Math.min(minLng, p.lng);
                maxLng = Math.max(maxLng, p.lng);
            });

            const latRange = maxLat - minLat;
            const lngRange = maxLng - minLng;

            const scaleX = pixelRangeX > 0 ? lngRange / pixelRangeX : 0;
            const scaleY = pixelRangeY > 0 ? latRange / pixelRangeY : 0;

            const refPoint = validPoints[0];
            const offsetLng = refPoint.lng - (refPoint.pixelX * scaleX);
            const offsetLat = refPoint.lat + (refPoint.pixelY * scaleY);

            return {
                lat: offsetLat - (pixelY * scaleY),
                lng: offsetLng + (pixelX * scaleX)
            };
        }

        function drawMeasureLine() {
            const container = document.getElementById('imageContainer');
            
            // Remover linha anterior
            const existingLine = document.getElementById('measureLine');
            if (existingLine) existingLine.remove();

            const p1 = measurePoints[0];
            const p2 = measurePoints[1];

            const x1 = p1.pixelX * currentZoom;
            const y1 = p1.pixelY * currentZoom;
            const x2 = p2.pixelX * currentZoom;
            const y2 = p2.pixelY * currentZoom;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.id = 'measureLine';
            svg.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 150;
            `;
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="10" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#6c5ce7" />
                    </marker>
                </defs>
                <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                      stroke="#6c5ce7" stroke-width="3" stroke-dasharray="8,4"
                      marker-end="url(#arrowhead)" />
            `;
            container.appendChild(svg);
        }

        function showMeasureResult() {
            const p1 = measurePoints[0];
            const p2 = measurePoints[1];

            // Calcular dist√¢ncia usando f√≥rmula de Haversine
            const distance = haversineDistance(p1.lat, p1.lng, p2.lat, p2.lng);
            
            // Calcular bearing (rumo)
            const bearing = calculateBearing(p1.lat, p1.lng, p2.lat, p2.lng);

            const resultEl = document.getElementById('measureResult');
            resultEl.style.display = 'block';
            resultEl.innerHTML = `
                <div style="text-align:center; margin-bottom:10px;">
                    <span style="font-size:1.5em; color:#6c5ce7;">üìè Resultado da Medi√ß√£o</span>
                </div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; font-size:0.85em;">
                    <div style="background:#1a1a2e; padding:8px; border-radius:4px;">
                        <div style="color:#888; font-size:0.8em;">Ponto 1</div>
                        <div style="color:#00ff00;">${formatCoord(p1.lat, p1.lng)}</div>
                    </div>
                    <div style="background:#1a1a2e; padding:8px; border-radius:4px;">
                        <div style="color:#888; font-size:0.8em;">Ponto 2</div>
                        <div style="color:#00ff00;">${formatCoord(p2.lat, p2.lng)}</div>
                    </div>
                </div>
                <div style="margin-top:12px; padding:12px; background:#1a1a2e; border-radius:8px; text-align:center;">
                    <div style="font-size:1.8em; color:#00ff00; font-weight:bold;">
                        ${distance.toFixed(2)} NM
                    </div>
                    <div style="color:#888; font-size:0.85em;">Dist√¢ncia (${(distance * 1.852).toFixed(2)} km)</div>
                    <div style="margin-top:10px; font-size:1.5em; color:#6c5ce7; font-weight:bold;">
                        ${bearing.toFixed(1)}¬∞
                    </div>
                    <div style="color:#888; font-size:0.85em;">Rumo (Bearing)</div>
                </div>
                <button onclick="clearMeasurePoints()" style="width:100%; margin-top:10px; padding:8px; background:#e74c3c; border:none; border-radius:4px; color:white; cursor:pointer;">
                    üóëÔ∏è Limpar Medi√ß√£o
                </button>
            `;
        }

        function formatCoord(lat, lng) {
            const latDir = lat >= 0 ? 'N' : 'S';
            const lngDir = lng >= 0 ? 'E' : 'W';
            return `${Math.abs(lat).toFixed(6)}¬∞${latDir}, ${Math.abs(lng).toFixed(6)}¬∞${lngDir}`;
        }

        function haversineDistance(lat1, lng1, lat2, lng2) {
            // Raio da Terra em milhas n√°uticas
            const R = 3440.065; // NM
            
            const dLat = toRad(lat2 - lat1);
            const dLng = toRad(lng2 - lng1);
            
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }

        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLng = toRad(lng2 - lng1);
            const lat1Rad = toRad(lat1);
            const lat2Rad = toRad(lat2);
            
            const y = Math.sin(dLng) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                      Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);
            
            let bearing = toDeg(Math.atan2(y, x));
            return (bearing + 360) % 360; // Normalizar para 0-360
        }

        function toRad(deg) {
            return deg * Math.PI / 180;
        }

        function toDeg(rad) {
            return rad * 180 / Math.PI;
        }

        function addGcpPoint(e) {
            if (!imageLoaded) {
                alert('Carregue uma imagem primeiro!');
                return;
            }

            const pixel = clientToImagePixel(e.clientX, e.clientY);
            if (!pixel) return;

            gcpCounter++;
            const id = gcpCounter;

            // Criar elemento visual
            const pointEl = document.createElement('div');
            pointEl.className = 'image-point';
            pointEl.innerHTML = id;
            pointEl.dataset.id = id;
            document.getElementById('imageContainer').appendChild(pointEl);

            // Posicionar
            pointEl.style.left = (pixel.x * currentZoom) + 'px';
            pointEl.style.top = (pixel.y * currentZoom) + 'px';

            // Permitir arrastar
            setupPointDrag(pointEl);

            // Adicionar ao array
            const point = {
                id: id,
                pixelX: pixel.x,
                pixelY: pixel.y,
                lat: 0,
                lng: 0,
                element: pointEl
            };
            gcpPoints.push(point);

            updateGcpList();
            updateSummary();
            
            // Desativar modo ap√≥s adicionar
            toggleGcpMode();
        }

        function setupPointDrag(pointEl) {
            pointEl.addEventListener('mousedown', function(e) {
                e.stopPropagation();
                isDragging = true;
                const id = parseInt(pointEl.dataset.id);
                const point = gcpPoints.find(p => p.id === id);
                dragTarget = { type: 'point', point: point };
            });
        }

        function updatePointDrag(e, point) {
            const pixel = clientToImagePixel(e.clientX, e.clientY);
            if (pixel) {
                point.pixelX = pixel.x;
                point.pixelY = pixel.y;
                point.element.style.left = (pixel.x * currentZoom) + 'px';
                point.element.style.top = (pixel.y * currentZoom) + 'px';
                updateGcpList();
            }
        }

        function updatePointPositions() {
            gcpPoints.forEach(point => {
                point.element.style.left = (point.pixelX * currentZoom) + 'px';
                point.element.style.top = (point.pixelY * currentZoom) + 'px';
            });
            
            // Atualizar posi√ß√£o dos marcadores de medi√ß√£o
            measureMarkers.forEach((marker, i) => {
                if (measurePoints[i]) {
                    marker.style.left = (measurePoints[i].pixelX * currentZoom) + 'px';
                    marker.style.top = (measurePoints[i].pixelY * currentZoom) + 'px';
                }
            });
            
            // Redesenhar linha de medi√ß√£o se existir
            if (measurePoints.length === 2) {
                drawMeasureLine();
            }
        }

        function updateGcpList() {
            const listEl = document.getElementById('gcpList');
            
            if (gcpPoints.length === 0) {
                listEl.innerHTML = '<p style="color:#666; font-size:0.85em; text-align:center;">Nenhum ponto marcado</p>';
                return;
            }
            
            let html = '';
            gcpPoints.forEach(point => {
                html += `
                    <div class="gcp-item" data-id="${point.id}">
                        <div class="gcp-header">
                            <span class="gcp-number">${point.id}</span>
                            <span style="color:#888; font-size:0.8em;">Pixel: ${Math.round(point.pixelX)}, ${Math.round(point.pixelY)}</span>
                            <button class="remove-btn" onclick="removePoint(${point.id})">√ó</button>
                        </div>
                        <div class="gcp-coords">
                            <div>
                                <label>Latitude</label>
                                <input type="number" step="0.000001" value="${point.lat}" 
                                       placeholder="-22.123456"
                                       onchange="updatePointCoord(${point.id}, 'lat', this.value)">
                            </div>
                            <div>
                                <label>Longitude</label>
                                <input type="number" step="0.000001" value="${point.lng}" 
                                       placeholder="-41.567890"
                                       onchange="updatePointCoord(${point.id}, 'lng', this.value)">
                            </div>
                        </div>
                    </div>
                `;
            });
            
            listEl.innerHTML = html;
        }

        function updatePointCoord(id, field, value) {
            const point = gcpPoints.find(p => p.id === id);
            if (point) {
                point[field] = parseFloat(value) || 0;
                updateSummary();
            }
        }

        function removePoint(id) {
            const index = gcpPoints.findIndex(p => p.id === id);
            if (index !== -1) {
                gcpPoints[index].element.remove();
                gcpPoints.splice(index, 1);
                updateGcpList();
                updateSummary();
            }
        }

        function clearAllPoints() {
            gcpPoints.forEach(p => p.element.remove());
            gcpPoints = [];
            gcpCounter = 0;
            updateGcpList();
            updateSummary();
        }

        // ===== CALCULAR ALINHAMENTO =====
        function calculateAlignment() {
            if (gcpPoints.length < 2) {
                return null;
            }

            // Verificar se todos os pontos t√™m coordenadas
            const validPoints = gcpPoints.filter(p => p.lat !== 0 || p.lng !== 0);
            if (validPoints.length < 2) {
                return null;
            }

            // Calcular transforma√ß√£o linear simples (escala + offset)
            // Usando os pontos para calcular bounds geogr√°ficos

            let minPixelX = Infinity, maxPixelX = -Infinity;
            let minPixelY = Infinity, maxPixelY = -Infinity;
            let minLat = Infinity, maxLat = -Infinity;
            let minLng = Infinity, maxLng = -Infinity;

            validPoints.forEach(p => {
                minPixelX = Math.min(minPixelX, p.pixelX);
                maxPixelX = Math.max(maxPixelX, p.pixelX);
                minPixelY = Math.min(minPixelY, p.pixelY);
                maxPixelY = Math.max(maxPixelY, p.pixelY);
                minLat = Math.min(minLat, p.lat);
                maxLat = Math.max(maxLat, p.lat);
                minLng = Math.min(minLng, p.lng);
                maxLng = Math.max(maxLng, p.lng);
            });

            // Calcular escala (graus por pixel)
            const pixelRangeX = maxPixelX - minPixelX;
            const pixelRangeY = maxPixelY - minPixelY;
            const latRange = maxLat - minLat;
            const lngRange = maxLng - minLng;

            // Escala
            const scaleX = pixelRangeX > 0 ? lngRange / pixelRangeX : 0;
            const scaleY = pixelRangeY > 0 ? latRange / pixelRangeY : 0;

            // Extrapolar para os cantos da imagem
            // Pixel (0,0) est√° no topo-esquerdo
            // Lat aumenta para cima (Norte), Y de pixel aumenta para baixo
            
            // Calcular offset usando um ponto de refer√™ncia
            const refPoint = validPoints[0];
            const offsetLng = refPoint.lng - (refPoint.pixelX * scaleX);
            const offsetLat = refPoint.lat + (refPoint.pixelY * scaleY); // + porque Y √© invertido

            // Calcular bounds da imagem completa
            const north = offsetLat;  // Y=0
            const south = offsetLat - (imageNaturalSize.height * scaleY);
            const west = offsetLng;   // X=0
            const east = offsetLng + (imageNaturalSize.width * scaleX);

            return {
                bounds: { north, south, east, west },
                scale: { x: scaleX, y: scaleY },
                gcpPoints: validPoints.map(p => ({
                    pixelX: p.pixelX,
                    pixelY: p.pixelY,
                    lat: p.lat,
                    lng: p.lng
                })),
                imageSize: imageNaturalSize
            };
        }

        function updateSummary() {
            const el = document.getElementById('summaryDisplay');
            const validPoints = gcpPoints.filter(p => p.lat !== 0 || p.lng !== 0);
            
            if (!imageLoaded) {
                el.innerHTML = 'Carregue uma imagem';
                return;
            }
            
            if (gcpPoints.length === 0) {
                el.innerHTML = `üìê Imagem: ${imageNaturalSize.width}√ó${imageNaturalSize.height}px<br>üìå Marque pontos de refer√™ncia`;
                return;
            }

            let html = `üìê Imagem: ${imageNaturalSize.width}√ó${imageNaturalSize.height}px<br>`;
            html += `üìå Pontos: ${validPoints.length} com coordenadas / ${gcpPoints.length} total<br>`;

            const alignment = calculateAlignment();
            if (alignment) {
                html += `<br><b style="color:#00ff00;">‚úÖ Pronto para alinhar!</b><br>`;
                html += `N: ${alignment.bounds.north.toFixed(6)}¬∞<br>`;
                html += `S: ${alignment.bounds.south.toFixed(6)}¬∞<br>`;
                html += `E: ${alignment.bounds.east.toFixed(6)}¬∞<br>`;
                html += `W: ${alignment.bounds.west.toFixed(6)}¬∞`;
            } else {
                html += `<span style="color:#ffaa00;">‚ö†Ô∏è Adicione coordenadas aos pontos</span>`;
            }

            el.innerHTML = html;
        }

        // ===== PREVIEW NO MAPA =====
        function previewAlignment() {
            const alignment = calculateAlignment();
            
            if (!alignment) {
                alert('Voc√™ precisa de pelo menos 2 pontos com coordenadas para ver o alinhamento!');
                return;
            }

            document.getElementById('previewModal').style.display = 'flex';

            // Inicializar mapa se n√£o existir
            setTimeout(() => {
                if (!previewMap) {
                    previewMap = L.map('previewMap', {
                        zoomControl: true
                    });

                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap'
                    }).addTo(previewMap);
                }

                // Limpar camadas anteriores
                previewMap.eachLayer(layer => {
                    if (layer instanceof L.ImageOverlay || layer instanceof L.Marker) {
                        previewMap.removeLayer(layer);
                    }
                });

                // Adicionar overlay da imagem
                const bounds = L.latLngBounds(
                    [alignment.bounds.south, alignment.bounds.west],
                    [alignment.bounds.north, alignment.bounds.east]
                );

                L.imageOverlay(imageElement.src, bounds, {
                    opacity: 0.8
                }).addTo(previewMap);

                // Adicionar marcadores dos GCPs
                alignment.gcpPoints.forEach((p, i) => {
                    L.marker([p.lat, p.lng])
                        .bindPopup(`GCP ${i+1}: ${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`)
                        .addTo(previewMap);
                });

                previewMap.fitBounds(bounds);
                previewMap.invalidateSize();
            }, 100);
        }

        function closePreview() {
            document.getElementById('previewModal').style.display = 'none';
        }

        // ===== BAIXAR IMAGEM =====
        function downloadImage() {
            if (!imageLoaded || !imageElement.src) {
                alert('Carregue uma imagem primeiro!');
                return;
            }

            // Criar link de download
            const a = document.createElement('a');
            a.href = imageElement.src;
            
            // Extrair nome do arquivo ou gerar um
            let filename = 'satellite_image.png';
            if (imageElement.src.startsWith('data:')) {
                // √â uma imagem carregada localmente (base64)
                const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
                filename = `satellite_${timestamp}.png`;
            } else {
                // Tenta extrair nome da URL
                const urlParts = imageElement.src.split('/');
                const lastPart = urlParts[urlParts.length - 1].split('?')[0];
                if (lastPart && lastPart.includes('.')) {
                    filename = lastPart;
                }
            }
            
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // ===== EXPORTAR/IMPORTAR =====
        function exportAlignment() {
            const alignment = calculateAlignment();
            if (!alignment) {
                alert('Configure os pontos de refer√™ncia primeiro!');
                return;
            }

            const data = {
                timestamp: new Date().toISOString(),
                ...alignment
            };

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `alignment_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importAlignment() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            const data = JSON.parse(event.target.result);
                            applyImportedAlignment(data);
                        } catch (err) {
                            alert('Erro ao ler arquivo: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function applyImportedAlignment(data) {
            if (data.gcpPoints) {
                clearAllPoints();
                data.gcpPoints.forEach(p => {
                    gcpCounter++;
                    const id = gcpCounter;
                    
                    const pointEl = document.createElement('div');
                    pointEl.className = 'image-point';
                    pointEl.innerHTML = id;
                    pointEl.dataset.id = id;
                    document.getElementById('imageContainer').appendChild(pointEl);
                    pointEl.style.left = (p.pixelX * currentZoom) + 'px';
                    pointEl.style.top = (p.pixelY * currentZoom) + 'px';
                    setupPointDrag(pointEl);

                    gcpPoints.push({
                        id: id,
                        pixelX: p.pixelX,
                        pixelY: p.pixelY,
                        lat: p.lat,
                        lng: p.lng,
                        element: pointEl
                    });
                });
                updateGcpList();
                updateSummary();
            }
        }

        // Scroll para zoom
        document.getElementById('imageArea').addEventListener('wheel', function(e) {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            zoomImage(factor);
        });
    </script>
</body>
</html>
