
<!DOCTYPE html>
<html>
<head>
    <title>Monitor de Vento - Tempo Real - Deepwater Aquila</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; padding: 0; 
            background: #0a0a0a; 
            font-family: 'Consolas', 'Monaco', monospace; 
            color: #e0e0e0; 
        }
        
        /* Layout Principal */
        .container {
            display: flex;
            height: 100vh;
        }
        
        /* Painel Lateral */
        .sidebar {
            width: 380px;
            background: #111;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 15px;
        }
        
        /* Mapa */
        #map { 
            flex: 1;
            height: 100vh;
        }
        
        /* Estilos do Painel */
        h1 {
            font-size: 16px;
            color: #00ffcc;
            border-bottom: 2px solid #00ffcc;
            padding-bottom: 10px;
            margin: 0 0 15px 0;
        }
        
        h2 {
            font-size: 13px;
            color: #ff9900;
            margin: 20px 0 10px 0;
            text-transform: uppercase;
        }
        
        .section {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .section-title {
            font-size: 12px;
            color: #00ffcc;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .status-indicator.active { background: #00ff00; }
        .status-indicator.loading { background: #ffff00; animation: pulse 1s infinite; }
        .status-indicator.error { background: #ff0000; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Inputs */
        label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
        }
        
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 3px;
            font-family: inherit;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        input:focus {
            outline: none;
            border-color: #00ffcc;
        }
        
        button {
            padding: 8px 16px;
            background: #00ffcc;
            color: #000;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        button:hover {
            background: #00ddaa;
        }
        
        button.secondary {
            background: #444;
            color: #fff;
        }
        
        button.secondary:hover {
            background: #555;
        }
        
        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        /* Toggle Button para Sat√©lite */
        .toggle-btn {
            flex: 1;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #555;
            color: #888;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        
        .toggle-btn:hover {
            background: #444;
            color: #ccc;
        }
        
        .toggle-btn.active {
            background: #00cc99;
            border-color: #00ffcc;
            color: #000;
        }
        
        /* Log de Status */
        .log-area {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-size: 11px;
            border-radius: 3px;
        }
        
        .log-entry {
            margin-bottom: 4px;
            padding-left: 10px;
            border-left: 2px solid #444;
        }
        
        .log-entry.info { border-left-color: #00ffcc; }
        .log-entry.success { border-left-color: #00ff00; }
        .log-entry.error { border-left-color: #ff0000; }
        .log-entry.warning { border-left-color: #ffff00; }
        
        /* Dados de Vento */
        .wind-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .stat-box {
            background: #222;
            padding: 10px;
            text-align: center;
            border-radius: 3px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #00ffcc;
        }
        
        .stat-label {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        /* Legenda */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        /* Checkbox customizado */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .checkbox-item input {
            width: 16px;
            height: 16px;
        }
        
        /* Fonte info */
        .source-info {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }
        
        /* Estilos para setas de vento DMW */
        .dmw-wind-arrow {
            background: transparent !important;
            border: none !important;
        }
        
        .source-info a {
            color: #00aaff;
        }
        
        /* Info Icon com Tooltip */
        .input-with-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .input-with-info input {
            flex: 1;
            margin-bottom: 0;
        }
        
        .info-icon {
            width: 20px;
            height: 20px;
            background: #0088ff;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            position: relative;
            flex-shrink: 0;
        }
        
        .info-icon:hover {
            background: #00aaff;
        }
        
        .info-tooltip {
            display: none;
            position: absolute;
            left: 30px;
            top: -10px;
            background: #222;
            border: 1px solid #00aaff;
            border-radius: 6px;
            padding: 12px;
            width: 280px;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        .info-icon:hover .info-tooltip {
            display: block;
        }
        
        .info-tooltip h4 {
            color: #00ffcc;
            margin: 0 0 8px 0;
            font-size: 12px;
        }
        
        .info-tooltip p {
            color: #ccc;
            font-size: 11px;
            margin: 6px 0;
            line-height: 1.4;
        }
        
        .info-tooltip ol {
            color: #aaa;
            font-size: 11px;
            margin: 8px 0;
            padding-left: 16px;
            line-height: 1.6;
        }
        
        .info-tooltip a {
            color: #00aaff;
            text-decoration: underline;
        }
        
        .info-tooltip .highlight {
            background: #333;
            padding: 4px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #ffcc00;
        }
    </style>
</head>
<body>

<div class="container">
    <!-- PAINEL LATERAL -->
    <div class="sidebar">
        <h1>üõ∞Ô∏è SCATTEROMETER MONITOR</h1>
        
        <!-- POSI√á√ÉO DO NAVIO -->
        <div class="section">
            <div class="section-title">
                <span class="status-indicator active"></span>
                POSI√á√ÉO: Deepwater Aquila
            </div>
            <div class="wind-stats">
                <div class="stat-box">
                    <div class="stat-value">-22.5¬∞</div>
                    <div class="stat-label">LATITUDE</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">-40.5¬∞</div>
                    <div class="stat-label">LONGITUDE</div>
                </div>
            </div>
        </div>
        
        <!-- ESTAT√çSTICAS DE VENTO -->
        <div class="section">
            <div class="section-title">
                <span class="status-indicator" id="wind-status"></span>
                DADOS DE VENTO
            </div>
            
            <!-- M√©dia Multi-Modelo com Pesos Din√¢micos -->
            <div style="background:#1a2a1a; border:1px solid #00aa00; border-radius:4px; padding:10px; margin-bottom:10px;">
                <div style="font-size:10px; color:#00ff00; margin-bottom:5px;">üåç M√âDIA PONDERADA (5 MODELOS)</div>
                <div style="display:flex; gap:10px; align-items:center;">
                    <div style="text-align:center;">
                        <div style="font-size:24px; font-weight:bold; color:#00ffcc;" id="avg-model-speed">--</div>
                        <div style="font-size:9px; color:#888;">Velocidade (kn)</div>
                    </div>
                    <div style="text-align:center;">
                        <div style="font-size:24px; font-weight:bold; color:#00ffcc;" id="avg-model-dir">--</div>
                        <div style="font-size:9px; color:#888;">Dire√ß√£o (¬∞)</div>
                    </div>
                </div>
                
                <!-- Valores individuais dos modelos -->
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; font-size:9px;">
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:3px;">
                        <div><span style="color:#4488ff;">GFS:</span> <span id="gfs-value">--</span> <span id="gfs-weight" style="color:#ffaa00;"></span></div>
                        <div><span style="color:#ff8844;">ECMWF:</span> <span id="ecmwf-value">--</span> <span id="ecmwf-weight" style="color:#ffaa00;"></span></div>
                        <div><span style="color:#44ff88;">ICON:</span> <span id="icon-value">--</span> <span id="icon-weight" style="color:#ffaa00;"></span></div>
                        <div><span style="color:#ff44ff;">MeteoFR:</span> <span id="meteofr-value">--</span> <span id="meteofr-weight" style="color:#ffaa00;"></span></div>
                        <div><span style="color:#ffff44;">JMA:</span> <span id="jma-value">--</span> <span id="jma-weight" style="color:#ffaa00;"></span></div>
                    </div>
                    <div style="margin-top:5px; font-size:9px; color:#666;" id="weight-reason">
                        Pesos iguais (sem hist√≥rico)
                    </div>
                </div>
            </div>
            
            <div class="wind-stats">
                <div class="stat-box">
                    <div class="stat-value" id="avg-wind">--</div>
                    <div class="stat-label">VENTO M√âDIO (kn)</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="max-wind">--</div>
                    <div class="stat-label">VENTO M√ÅX (kn)</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="data-points">--</div>
                    <div class="stat-label">PONTOS</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="data-age">--</div>
                    <div class="stat-label">IDADE</div>
                </div>
            </div>
            
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#00ff00"></div> &lt;10 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#88ff00"></div> 10-15 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#ffff00"></div> 15-20 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff9900"></div> 20-25 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff0000"></div> 25-30 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff00ff"></div> &gt;30 kn</div>
            </div>
            <div style="margin-top:10px; font-size:10px; color:#888; border-top:1px solid #333; padding-top:8px;">
                <div>‚óÜ = Dado de Escater√¥metro (sat√©lite)</div>
                <div style="margin-top:4px;">Escater√¥metros: √≠cone maior com borda</div>
                <div>Open-Meteo: √≠cone menor (modelo)</div>
            </div>
        </div>
        
        <!-- FONTES DE DADOS -->
        <h2>üì° FONTES DE DADOS</h2>
        
        <!-- Open-Meteo (Background - Modelo) -->
        <div class="section" style="border-left: 3px solid #666;">
            <div class="section-title">
                <span class="status-indicator" id="openmeteo-status"></span>
                OPEN-METEO (Modelo)
            </div>
            <p class="source-info">‚úÖ GRATUITO - Dados de fundo, atualiza a cada 15 min</p>
            <p class="source-info">√çcones menores - Modelo num√©rico (n√£o sat√©lite)</p>
            <button onclick="fetchOpenMeteoData()">üîÑ Atualizar Open-Meteo</button>
            <button class="secondary" onclick="clearOpenMeteoData()">üóëÔ∏è Limpar</button>
        </div>
        
        <h2>ÔøΩ TEMPO REAL (< 60 min)</h2>
        
        <!-- Aviso sobre escater√¥metros -->
        <div class="section" style="border-left: 3px solid #ff6600; background: #1a1000;">
            <div class="section-title" style="color: #ff9900;">
                ‚ö†Ô∏è Sobre Escater√¥metros
            </div>
            <p class="source-info" style="color: #ff9900;">Dados de sat√©lite (ASCAT, CYGNSS) t√™m atraso de 2-6h.</p>
            <p class="source-info">Para dados em tempo real usamos:</p>
            <p class="source-info">‚Ä¢ <strong>Open-Meteo</strong> - Modelos meteorol√≥gicos (acima)</p>
            <p class="source-info">‚ö†Ô∏è Escater√¥metros removidos (atraso > 60min)</p>
        </div>
        
        <!-- Escater√¥metros - DESABILITADO (atraso > 60min) -->
        <!-- 
        <div class="section" style="border-left: 3px solid #333; opacity: 0.5;">
            <div class="section-title">
                <span class="status-indicator" id="cmems-status"></span>
                COPERNICUS MARINE (CMEMS) - ATRASO 2-6h
            </div>
            <p class="source-info">Desabilitado: dados de sat√©lite t√™m atraso > 60 min</p>
        </div>
        -->
        
        <!-- NASA Earthdata - DESABILITADO (atraso > 60min) -->
        <!--
        <div class="section" style="border-left: 3px solid #333; opacity: 0.5;">
            <div class="section-title">
                <span class="status-indicator" id="nasa-status"></span>
                NASA EARTHDATA (CYGNSS) - ATRASO 2-6h
            </div>
            <p class="source-info">Desabilitado: dados de sat√©lite t√™m atraso > 60 min</p>
        </div>
        -->
        
        <!-- Camadas do Mapa -->
        <h2>ÔøΩÔ∏è CAMADAS</h2>
        <div class="section">
            <div class="checkbox-group">
                <label class="checkbox-item">
                    <input type="checkbox" id="layer-arrows" checked onchange="toggleLayer('arrows')">
                    Setas de Vento
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" id="layer-grid" onchange="toggleLayer('grid')">
                    Grade de Coordenadas
                </label>
            </div>
        </div>
        
        <!-- Sat√©lite em Tempo Real -->
        <h2>üõ∞Ô∏è SAT√âLITE (Reproje√ß√£o REAL)</h2>
        <div class="section" style="border-left: 3px solid #00ff00;">
            <div class="section-title">
                <span class="status-indicator" id="satellite-status"></span>
                <span id="satellite-name">GOES-19</span> - Reproje√ß√£o em tempo real
            </div>
            <p class="source-info">‚úÖ Imagem Full Disk reprojetada para Web Mercator</p>
            
            <!-- Toggle de Sat√©lite -->
            <label>üõ∞Ô∏è Sat√©lite:</label>
            <div class="toggle-container" style="display:flex; gap:5px; margin-bottom:10px;">
                <button id="btn-goes19" class="toggle-btn active" onclick="selectSatellite('goes19')">GOES-19</button>
                <button id="btn-goes16" class="toggle-btn" onclick="selectSatellite('goes16')">GOES-16</button>
            </div>
            
            <!-- Produto -->
            <label>üì∑ Produto:</label>
            <select id="satellite-product" style="width:100%; margin-bottom:10px; padding:6px; background:#222; color:#fff; border:1px solid #444; border-radius:3px;">
                <option value="GEOCOLOR" selected>üåç GeoColor (Vis√≠vel/IR)</option>
                <option value="13">üå°Ô∏è IR Limpo (Band 13)</option>
                <option value="14">üå°Ô∏è IR (Band 14)</option>
                <option value="08">üíß Vapor d'√Ågua Alto (Band 8)</option>
                <option value="09">üíß Vapor d'√Ågua M√©dio (Band 9)</option>
                <option value="02">‚òÄÔ∏è Vis√≠vel (Band 2)</option>
                <option value="AirMass">üåÄ Air Mass (RGB)</option>
                <option value="Sandwich">ü•™ Sandwich (IR + Vis√≠vel)</option>
            </select>
            
            <!-- Qualidade -->
            <label>‚ö° Qualidade:</label>
            <select id="satellite-quality" style="width:100%; margin-bottom:10px; padding:6px; background:#222; color:#fff; border:1px solid #444; border-radius:3px;">
                <option value="low">R√°pida (600px)</option>
                <option value="medium" selected>M√©dia (1200px)</option>
                <option value="high">Alta (2400px)</option>
                <option value="max">M√°xima (4800px)</option>
            </select>
            
            <label>üîç Opacidade: <span id="opacity-value">75%</span></label>
            <input type="range" id="satellite-opacity" min="0" max="100" value="75" 
                   style="width:100%; margin-bottom:8px;" 
                   oninput="updateSatelliteOpacity(this.value)">
            
            <!-- Toggle Auto-Extra√ß√£o -->
            <label>üîÑ Auto-Extra√ß√£o (5 min):</label>
            <div class="toggle-container" style="display:flex; gap:5px; margin-bottom:10px;">
                <button id="btn-autoextract-on" class="toggle-btn active" onclick="toggleAutoExtract(true)">‚úÖ LIGADO</button>
                <button id="btn-autoextract-off" class="toggle-btn" onclick="toggleAutoExtract(false)">‚ùå DESLIGADO</button>
            </div>
            
            <div style="display:flex; gap:5px; margin-top:5px;">
                <button onclick="loadSatelliteWithReprojection()" style="flex:1;">üåç CARREGAR</button>
                <button class="secondary" onclick="toggleSatelliteLayer()">üëÅÔ∏è On/Off</button>
            </div>
            
            <!-- Progress Bar -->
            <div id="satellite-progress" style="display:none; margin-top:10px;">
                <div style="background:#333; border-radius:3px; height:6px; overflow:hidden;">
                    <div id="satellite-progress-bar" style="width:0%; height:100%; background:#00d4ff; transition:width 0.2s;"></div>
                </div>
                <div id="satellite-progress-text" style="font-size:10px; color:#888; margin-top:3px;">0%</div>
            </div>
            
            <div id="satellite-info" style="margin-top:8px; font-size:10px; color:#888;"></div>
        </div>
        
        <!-- VENTOS DMW (GOES) -->
        <h2>üå¨Ô∏è VENTOS DMW (GOES)</h2>
        <div class="section" style="border-left: 3px solid #ff9900;">
            <div class="section-title">
                <span class="status-indicator" id="dmw-status"></span>
                Derived Motion Winds - Sat√©lite GOES
            </div>
            <p class="source-info">Ventos derivados do movimento das nuvens</p>
            
            <!-- Toggle DMW -->
            <label>üå¨Ô∏è Ativar DMW:</label>
            <div class="toggle-container" style="display:flex; gap:5px; margin-bottom:10px;">
                <button id="btn-dmw-on" class="toggle-btn" onclick="toggleDMW(true)">‚úÖ LIGADO</button>
                <button id="btn-dmw-off" class="toggle-btn active" onclick="toggleDMW(false)">‚ùå DESLIGADO</button>
            </div>
            
            <!-- N√≠vel de Vento -->
            <label>üìä N√≠vel de Altitude:</label>
            <select id="dmw-level" style="width:100%; margin-bottom:10px; padding:6px; background:#222; color:#fff; border:1px solid #444; border-radius:3px;" onchange="loadDMWWinds()">
                <option value="low" selected>Baixo N√≠vel (&lt;3km) - 700-1000 hPa</option>
                <option value="mid">N√≠vel M√©dio (3-7km) - 400-700 hPa</option>
                <option value="high">Alto N√≠vel (&gt;7km) - 100-400 hPa</option>
                <option value="all">Todos os N√≠veis</option>
            </select>
            
            <button onclick="loadDMWWinds()" style="width:100%; margin-bottom:10px;">üîÑ ATUALIZAR DMW</button>
            
            <!-- Info do arquivo -->
            <div id="dmw-info" style="font-size:10px; color:#888; margin-bottom:8px;">
                üìÖ Aguardando...
            </div>
            
            <!-- Info de pr√≥xima atualiza√ß√£o -->
            <div id="dmw-next-update" style="font-size:10px; color:#ff9900; margin-bottom:8px; display:none;">
                ‚è∞ Pr√≥xima atualiza√ß√£o: --:05
            </div>
            
            <!-- Legenda de Intensidade -->
            <div style="background:#111; padding:8px; border-radius:4px; font-size:10px;">
                <div style="color:#00ffcc; margin-bottom:5px; font-weight:bold;">üìä Intensidade do Vento:</div>
                <div style="display:flex; align-items:center; gap:5px; margin:2px 0;">
                    <span style="display:inline-block; width:12px; height:12px; background:#00ff00; border-radius:2px;"></span>
                    <span>0-10 kt - Calmo</span>
                </div>
                <div style="display:flex; align-items:center; gap:5px; margin:2px 0;">
                    <span style="display:inline-block; width:12px; height:12px; background:#ffff00; border-radius:2px;"></span>
                    <span>10-20 kt - Fraco</span>
                </div>
                <div style="display:flex; align-items:center; gap:5px; margin:2px 0;">
                    <span style="display:inline-block; width:12px; height:12px; background:#ffa500; border-radius:2px;"></span>
                    <span>20-30 kt - Moderado</span>
                </div>
                <div style="display:flex; align-items:center; gap:5px; margin:2px 0;">
                    <span style="display:inline-block; width:12px; height:12px; background:#ff6600; border-radius:2px;"></span>
                    <span>30-40 kt - Forte</span>
                </div>
                <div style="display:flex; align-items:center; gap:5px; margin:2px 0;">
                    <span style="display:inline-block; width:12px; height:12px; background:#ff0000; border-radius:2px;"></span>
                    <span>&gt;40 kt - Muito Forte</span>
                </div>
            </div>
        </div>
        
        <!-- Log -->
        <h2>üìã LOG</h2>
        <div class="log-area" id="log-area">
            <div class="log-entry info">Sistema iniciado...</div>
        </div>
        
        <!-- A√ß√µes -->
        <div style="margin-top: 15px;">
            <button onclick="fetchAllSources()">üîÑ BUSCAR TODOS</button>
            <button class="secondary" onclick="clearData()">üóëÔ∏è Limpar</button>
            <button class="secondary" onclick="exportData()">üì• Exportar CSV</button>
        </div>
        
    </div>
    
    <!-- MAPA -->
    <div id="map"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
    // =========================================================================
    // CONFIGURA√á√ÉO
    // =========================================================================
    // Raio para visualiza√ß√£o do mapa (c√≠rculo visual)
    const RAIO_VISUAL_NM = 100;  // Raio do c√≠rculo visual no mapa
    const RAIO_VISUAL_GRAUS = RAIO_VISUAL_NM / 60;
    
    // Raio para busca de dados Open-Meteo (igual ao visual para cobrir todo c√≠rculo)
    const RAIO_NM = 100;  // Raio em milhas n√°uticas para busca de dados
    const RAIO_GRAUS = RAIO_NM / 60;  // 1 grau = 60 NM
    
    // IMPORTANTE: Idade m√°xima dos dados em MINUTOS
    // Dados com mais de 60 min ser√£o descartados
    const MAX_DATA_AGE_MINUTES = 60;
    
    const CONFIG = {
        shipLat: -22.5,
        shipLon: -40.5,
        latMin: -22.5 - RAIO_GRAUS,
        latMax: -22.5 + RAIO_GRAUS,
        lonMin: -40.5 - RAIO_GRAUS,
        lonMax: -40.5 + RAIO_GRAUS,
        shipName: "Deepwater Aquila"
    };
    
    // Bounds da imagem de sat√©lite reprojetada (√°rea de interesse)
    // IMPORTANTE: Definir aqui para ser usada por loadDMWWinds antes de ser redefinida abaixo
    const REPROJECTION_BOUNDS = {
        north: 0,
        south: -30,
        west: -60,
        east: -30
    };
    
    let map;
    let windDataPoints = [];  // Armazena todos os dados de vento
    let windLayerGroup;
    let gridLayer;
    
    // =========================================================================
    // INICIALIZA√á√ÉO DO MAPA
    // =========================================================================
    function initMap() {
        map = L.map('map', {
            center: [CONFIG.shipLat, CONFIG.shipLon],
            zoom: 7,
            zoomControl: false
        });

        L.control.zoom({ position: 'topright' }).addTo(map);
        L.control.scale({ position: 'bottomright', imperial: false }).addTo(map);

        // Mapa Base Escuro
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19
        }).addTo(map);
        
        // Grupos de camadas
        windLayerGroup = L.layerGroup().addTo(map);
        gridLayer = L.layerGroup();
        
        log('info', 'üìç Adicionando √≠cone do navio...');

        // √çcone do Navio
        const shipIcon = L.divIcon({
            className: 'ship-icon',
            html: `<svg viewBox="0 0 24 24" width="50" height="50">
                <circle cx="12" cy="12" r="10" fill="rgba(0,255,204,0.3)" stroke="#00ffcc" stroke-width="2"/>
                <circle cx="12" cy="12" r="4" fill="#00ffcc"/>
            </svg>`,
            iconSize: [50, 50],
            iconAnchor: [25, 25]
        });
        L.marker([CONFIG.shipLat, CONFIG.shipLon], { icon: shipIcon })
            .bindPopup(`<b>${CONFIG.shipName}</b><br>Lat: ${CONFIG.shipLat}<br>Lon: ${CONFIG.shipLon}`)
            .addTo(map);
        
        // √Årea de interesse (C√çRCULO VISUAL - 100 NM)
        L.circle([CONFIG.shipLat, CONFIG.shipLon], {
            radius: RAIO_VISUAL_NM * 1852,  // Converter NM para metros
            color: "#00ffcc",
            weight: 1,
            fillOpacity: 0.05,
            dashArray: '5, 5'
        }).addTo(map);
        
        log('info', 'üó∫Ô∏è Mapa base carregado');
        
        // Criar grade
        createGrid();
        
        // Carregar credenciais salvas
        loadSavedCredentials();
        
        log('success', '‚úÖ Mapa inicializado');
        log('info', `üìè √Årea visual: ${RAIO_VISUAL_NM} NM | Grid dados: ${RAIO_NM} NM`);
        
        // Carregar sat√©lite primeiro (500ms)
        log('info', 'üõ∞Ô∏è Iniciando carregamento de sat√©lite...');
        setTimeout(() => loadSatelliteLayer(), 500);
        
        // Buscar dados Open-Meteo (1 segundo)
        log('info', 'üå¨Ô∏è Iniciando busca de dados de vento...');
        setTimeout(() => fetchOpenMeteoData(), 1500);
        
        // Atualiza√ß√£o autom√°tica do Open-Meteo a cada 15 minutos
        setInterval(() => {
            log('info', '‚è∞ Atualiza√ß√£o autom√°tica (15 min)...');
            fetchOpenMeteoData();
        }, 15 * 60 * 1000);  // 15 minutos
        
        // Verifica√ß√£o autom√°tica de nova imagem de sat√©lite a cada 5 minutos
        setInterval(async () => {
            if (!isLoadingSatellite && satelliteEnabled && autoExtractEnabled) {
                const needsUpdate = await shouldLoadSatellite(false);
                if (needsUpdate) {
                    log('info', 'üõ∞Ô∏è Detectada nova imagem de sat√©lite, atualizando...');
                    loadSatelliteWithReprojection(true);
                }
            }
        }, 5 * 60 * 1000);  // 5 minutos
    }
    
    // =========================================================================
    // CAMADA DE SAT√âLITE (Imagem pr√©-processada)
    // =========================================================================
    let satelliteEnabled = true;
    let satelliteLayer = null;
    let satelliteRefreshInterval = null;
    let satelliteData = null;
    let currentSatellite = 'goes19';  // Sat√©lite padr√£o
    let currentSatelliteTimestamp = null;  // Timestamp da imagem carregada
    let isLoadingSatellite = false;  // Flag para evitar carregamentos simult√¢neos
    let pendingSatelliteLayer = null;  // Camada sendo carregada em background
    let autoExtractEnabled = true;  // Auto-extra√ß√£o ligada por padr√£o
    
    // =========================================================================
    // CAMADA DMW (Derived Motion Winds)
    // =========================================================================
    let dmwEnabled = false;
    let dmwLayer = null;
    let dmwData = null;
    let dmwMarkers = [];
    let dmwAutoRefreshInterval = null;
    let lastDMWHour = -1;  // Para controlar atualiza√ß√£o por hora
    
    function toggleDMW(enabled) {
        dmwEnabled = enabled;
        
        // Atualizar bot√µes
        document.getElementById('btn-dmw-on').classList.toggle('active', enabled);
        document.getElementById('btn-dmw-off').classList.toggle('active', !enabled);
        
        // Atualizar status
        const statusEl = document.getElementById('dmw-status');
        
        if (enabled) {
            log('success', '‚úÖ DMW LIGADO - Carregando ventos...');
            statusEl.className = 'status-indicator loading';
            loadDMWWinds();
            
            // Iniciar verifica√ß√£o autom√°tica a cada minuto
            startDMWAutoRefresh();
        } else {
            log('info', '‚ùå DMW DESLIGADO');
            statusEl.className = 'status-indicator';
            clearDMWLayer();
            
            // Parar verifica√ß√£o autom√°tica
            stopDMWAutoRefresh();
        }
    }
    
    function startDMWAutoRefresh() {
        // Verificar a cada minuto se est√° no minuto 5
        if (dmwAutoRefreshInterval) {
            clearInterval(dmwAutoRefreshInterval);
        }
        
        // Mostrar pr√≥xima atualiza√ß√£o
        updateNextDMWTime();
        document.getElementById('dmw-next-update').style.display = 'block';
        
        dmwAutoRefreshInterval = setInterval(() => {
            if (!dmwEnabled) return;
            
            const now = new Date();
            const minute = now.getMinutes();
            const hour = now.getHours();
            
            // Atualizar info de pr√≥xima atualiza√ß√£o
            updateNextDMWTime();
            
            // Atualizar no minuto 5 de cada hora (12:05, 13:05, etc)
            // E apenas se ainda n√£o atualizou nessa hora
            if (minute === 5 && hour !== lastDMWHour) {
                lastDMWHour = hour;
                log('info', `üîÑ DMW: Atualiza√ß√£o autom√°tica (${hour}:05)`);
                loadDMWWinds();
            }
        }, 60 * 1000);  // Verificar a cada 1 minuto
        
        log('info', '‚è∞ DMW: Auto-refresh ativado (atualiza em XX:05)');
    }
    
    function updateNextDMWTime() {
        const now = new Date();
        let nextHour = now.getHours();
        
        // Se j√° passou do minuto 5, pr√≥xima √© na pr√≥xima hora
        if (now.getMinutes() >= 5) {
            nextHour = (nextHour + 1) % 24;
        }
        
        const nextUpdateEl = document.getElementById('dmw-next-update');
        if (nextUpdateEl) {
            nextUpdateEl.textContent = `‚è∞ Pr√≥xima atualiza√ß√£o: ${String(nextHour).padStart(2, '0')}:05`;
        }
    }
    
    function stopDMWAutoRefresh() {
        if (dmwAutoRefreshInterval) {
            clearInterval(dmwAutoRefreshInterval);
            dmwAutoRefreshInterval = null;
        }
        lastDMWHour = -1;
        document.getElementById('dmw-next-update').style.display = 'none';
    }
    
    function clearDMWLayer() {
        if (dmwLayer) {
            dmwLayer.clearLayers();
            map.removeLayer(dmwLayer);
            dmwLayer = null;
        }
        dmwMarkers = [];
    }
    
    async function loadDMWWinds() {
        if (!dmwEnabled) return;
        
        const level = document.getElementById('dmw-level').value;
        const statusEl = document.getElementById('dmw-status');
        const infoEl = document.getElementById('dmw-info');
        
        statusEl.className = 'status-indicator loading';
        log('info', 'üå¨Ô∏è Carregando dados DMW do GOES...');
        
        try {
            // N√≠veis de press√£o para filtrar
            const levelConfig = {
                'low': { min: 700, max: 1100, name: 'Baixo N√≠vel (<3km)' },
                'mid': { min: 400, max: 700, name: 'N√≠vel M√©dio (3-7km)' },
                'high': { min: 100, max: 400, name: 'Alto N√≠vel (>7km)' },
                'all': { min: 100, max: 1100, name: 'Todos os N√≠veis' }
            };
            
            const levelInfo = levelConfig[level] || levelConfig['low'];
            
            // Tentar usar API do servidor primeiro, depois fallback para arquivo JSON
            let dmwData = null;
            let usingApi = false;
            
            // Usar os mesmos bounds da imagem de sat√©lite reprojetada
            // para garantir que os vetores fiquem dentro da √°rea vis√≠vel
            const latMin = REPROJECTION_BOUNDS.south;  // -30
            const latMax = REPROJECTION_BOUNDS.north;  // 0
            const lonMin = REPROJECTION_BOUNDS.west;   // -60
            const lonMax = REPROJECTION_BOUNDS.east;   // -30
            
            try {
                // Tentar API do servidor
                const apiUrl = `/api/dmw?satellite=goes19&level=${level}&lat_min=${latMin}&lat_max=${latMax}&lon_min=${lonMin}&lon_max=${lonMax}`;
                const response = await fetch(apiUrl);
                if (response.ok) {
                    dmwData = await response.json();
                    usingApi = true;
                    log('info', 'üì° Usando API do servidor para DMW');
                }
            } catch (apiErr) {
                console.log('API n√£o dispon√≠vel, tentando arquivo JSON...');
            }
            
            // Fallback para arquivo JSON est√°tico
            if (!dmwData) {
                const jsonUrl = 'dmw_latest.json';
                const response = await fetch(jsonUrl);
                
                if (!response.ok) {
                    throw new Error(`Dados DMW n√£o encontrados (${response.status})`);
                }
                
                dmwData = await response.json();
            }
            
            log('success', `‚úÖ DMW carregado: ${dmwData.count || (dmwData.winds ? dmwData.winds.length : 0)} vetores totais`);
            
            // Limpar camada anterior
            clearDMWLayer();
            dmwLayer = L.layerGroup().addTo(map);
            
            const winds = [];
            const allWinds = dmwData.winds || [];
            
            // Limitar quantidade de vetores para n√£o poluir o mapa
            // Subsample: mostrar no m√°ximo ~200 vetores
            const maxVectors = 200;
            const step = allWinds.length > maxVectors ? Math.ceil(allWinds.length / maxVectors) : 1;
            
            for (let i = 0; i < allWinds.length; i += step) {
                const w = allWinds[i];
                
                // Sempre filtrar por √°rea (bounds da imagem de sat√©lite)
                if (w.lat < latMin || w.lat > latMax) continue;
                if (w.lon < lonMin || w.lon > lonMax) continue;
                
                // Filtrar por n√≠vel de press√£o (se n√£o foi filtrado pela API)
                if (!usingApi && w.pressure_hpa !== undefined) {
                    if (w.pressure_hpa < levelInfo.min || w.pressure_hpa > levelInfo.max) continue;
                }
                
                winds.push(w);
                
                // Cor baseada na velocidade
                const color = getDMWColor(w.speed_kt);
                
                // Criar seta de vento
                const arrow = createDMWArrow(w.lat, w.lon, w.direction, w.speed_kt, color);
                arrow.addTo(dmwLayer);
                dmwMarkers.push(arrow);
            }
            
            // Atualizar info com hor√°rio do arquivo
            const timestamp = dmwData.timestamp ? new Date(dmwData.timestamp) : new Date();
            const scanTime = dmwData.scan_time || timestamp.toISOString();
            infoEl.innerHTML = `üìÖ <strong>${winds.length}</strong> vetores | ${levelInfo.name}<br>` +
                              `üõ∞Ô∏è GOES: ${new Date(scanTime).toLocaleString('pt-BR')}`;
            
            statusEl.className = 'status-indicator active';
            log('success', `‚úÖ DMW: ${winds.length} vetores na √°rea`);
            
        } catch (err) {
            console.error('‚ùå Erro DMW:', err);
            log('error', 'Erro DMW: ' + err.message);
            statusEl.className = 'status-indicator error';
            infoEl.textContent = '‚ùå Erro ao carregar dados';
        }
    }
    
    function getDMWColor(speedKt) {
        if (speedKt < 10) return '#00ff00';      // Verde - Calmo
        if (speedKt < 20) return '#ffff00';      // Amarelo - Fraco
        if (speedKt < 30) return '#ffa500';      // Laranja - Moderado
        if (speedKt < 40) return '#ff6600';      // Laranja escuro - Forte
        return '#ff0000';                         // Vermelho - Muito forte
    }
    
    function createDMWArrow(lat, lon, direction, speed, color) {
        // Tamanho da seta baseado na velocidade (20-32 px)
        const size = Math.min(20 + speed * 0.3, 32);
        
        // DIRE√á√ÉO: Valor indica DE ONDE o vento vem (conven√ß√£o meteorol√≥gica)
        // Seta aponta PARA ONDE o vento vai (rota√ß√£o +180¬∞)
        const arrowRotation = (direction + 180) % 360;
        
        // Criar HTML da seta usando SVG (formato de seta real)
        const arrowHtml = `
            <div style="transform: rotate(${arrowRotation}deg); width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center;">
                <svg viewBox="0 0 24 24" width="${size - 4}" height="${size - 4}">
                    <path fill="${color}" stroke="#000" stroke-width="0.5" d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
                </svg>
            </div>
            <div style="text-align:center; font-size:9px; font-weight:bold; color:${color}; text-shadow: 1px 1px 2px black; margin-top:-2px;">
                ${speed.toFixed(0)}
            </div>
        `;

        const icon = L.divIcon({
            className: 'dmw-wind-arrow',
            html: arrowHtml,
            iconSize: [size, size + 12],
            iconAnchor: [size/2, (size + 12)/2]
        });
        
        // Popup com informa√ß√µes
        const popup = `<b>üå¨Ô∏è Vento DMW (GOES)</b><br>
                       <b>Velocidade:</b> ${speed.toFixed(1)} kt<br>
                       <b>Dire√ß√£o:</b> ${direction.toFixed(0)}¬∞ (de onde vem)<br>
                       <b>Lat:</b> ${lat.toFixed(3)}¬∞<br>
                       <b>Lon:</b> ${lon.toFixed(3)}¬∞`;

        return L.marker([lat, lon], { icon: icon })
            .bindPopup(popup);
    }

    // Fun√ß√£o para ligar/desligar auto-extra√ß√£o
    function toggleAutoExtract(enabled) {
        autoExtractEnabled = enabled;
        
        // Atualizar bot√µes
        document.getElementById('btn-autoextract-on').classList.toggle('active', enabled);
        document.getElementById('btn-autoextract-off').classList.toggle('active', !enabled);
        
        if (enabled) {
            log('success', '‚úÖ Auto-extra√ß√£o de sat√©lite LIGADA (verifica a cada 5 min)');
        } else {
            log('warning', '‚ùå Auto-extra√ß√£o de sat√©lite DESLIGADA');
        }
    }
    
    function selectSatellite(satId) {
        currentSatellite = satId;
        
        // Atualizar bot√µes
        document.querySelectorAll('.toggle-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById('btn-' + satId).classList.add('active');
        
        // Atualizar nome no t√≠tulo
        const nameEl = document.getElementById('satellite-name');
        if (nameEl) {
            nameEl.textContent = satId === 'goes19' ? 'GOES-19' : 'GOES-16';
        }
        
        // Carregar novo sat√©lite
        loadSatelliteLayer();
        log('info', `üõ∞Ô∏è Sat√©lite alterado para ${satId.toUpperCase()}`);
    }
    
    // =========================================================================
    // REPROJE√á√ÉO REAL - GOES Full Disk para Web Mercator
    // =========================================================================
    
    // REPROJECTION_BOUNDS j√° definido acima, pr√≥ximo ao CONFIG
    
    // Fun√ß√£o para gerar URL da imagem Full Disk
    function getFullDiskUrl(satellite, product) {
        const sat = satellite.toUpperCase();
        return `https://cdn.star.nesdis.noaa.gov/${sat}/ABI/FD/${product}/5424x5424.jpg`;
    }
    
    // FUN√á√ïES DE PROJE√á√ÉO WEB MERCATOR (EPSG:3857)
    const EARTH_RADIUS = 6378137;
    
    function lonToMercatorX(lon) {
        return lon * Math.PI / 180 * EARTH_RADIUS;
    }
    
    function latToMercatorY(lat) {
        const latClamped = Math.max(-85, Math.min(85, lat));
        const latRad = latClamped * Math.PI / 180;
        return Math.log(Math.tan(Math.PI / 4 + latRad / 2)) * EARTH_RADIUS;
    }
    
    function mercatorXToLon(x) {
        return x / EARTH_RADIUS * 180 / Math.PI;
    }
    
    function mercatorYToLat(y) {
        return (2 * Math.atan(Math.exp(y / EARTH_RADIUS)) - Math.PI / 2) * 180 / Math.PI;
    }
    
    // GOES-R ABI Fixed Grid - converte lat/lon para coordenadas de scan
    function latLonToScan(lat, lon, sat_lon) {
        const DEG2RAD = Math.PI / 180;
        const req = 6378137.0;
        const rpol = 6356752.31414;
        const H = 42164160.0;
        const e2 = 1 - (rpol * rpol) / (req * req);
        
        const lat_rad = lat * DEG2RAD;
        const lon_rad = lon * DEG2RAD;
        const sat_lon_rad = sat_lon * DEG2RAD;
        
        const lat_geo = Math.atan((rpol * rpol / (req * req)) * Math.tan(lat_rad));
        const rc = rpol / Math.sqrt(1 - e2 * Math.cos(lat_geo) * Math.cos(lat_geo));
        const dlon = lon_rad - sat_lon_rad;
        
        const sx = H - rc * Math.cos(lat_geo) * Math.cos(dlon);
        const sy = -rc * Math.cos(lat_geo) * Math.sin(dlon);
        const sz = rc * Math.sin(lat_geo);
        
        const dlon_deg = Math.abs(lon - sat_lon);
        if (dlon_deg > 81 || Math.abs(lat) > 81) return null;
        
        const sn = Math.sqrt(sx * sx + sy * sy + sz * sz);
        const x = Math.asin(-sy / sn);
        const y = Math.atan(sz / sx);
        
        return { x, y };
    }
    
    // Interpola√ß√£o bilinear para qualidade
    function bilinearInterpolate(srcData, x, y) {
        const x0 = Math.floor(x);
        const y0 = Math.floor(y);
        const x1 = Math.min(x0 + 1, srcData.width - 1);
        const y1 = Math.min(y0 + 1, srcData.height - 1);
        
        const fx = x - x0;
        const fy = y - y0;
        
        const w00 = (1 - fx) * (1 - fy);
        const w10 = fx * (1 - fy);
        const w01 = (1 - fx) * fy;
        const w11 = fx * fy;
        
        const i00 = (y0 * srcData.width + x0) * 4;
        const i10 = (y0 * srcData.width + x1) * 4;
        const i01 = (y1 * srcData.width + x0) * 4;
        const i11 = (y1 * srcData.width + x1) * 4;
        
        return {
            r: Math.round(srcData.data[i00] * w00 + srcData.data[i10] * w10 + srcData.data[i01] * w01 + srcData.data[i11] * w11),
            g: Math.round(srcData.data[i00+1] * w00 + srcData.data[i10+1] * w10 + srcData.data[i01+1] * w01 + srcData.data[i11+1] * w11),
            b: Math.round(srcData.data[i00+2] * w00 + srcData.data[i10+2] * w10 + srcData.data[i01+2] * w01 + srcData.data[i11+2] * w11)
        };
    }
    
    // Carregar imagem com Promise
    function loadImageAsync(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error('Falha ao carregar imagem'));
            img.src = url;
        });
    }
    
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    
    function setReprojectionProgress(pct, text) {
        const bar = document.getElementById('satellite-progress-bar');
        const txt = document.getElementById('satellite-progress-text');
        const container = document.getElementById('satellite-progress');
        if (bar) bar.style.width = pct + '%';
        if (txt) txt.textContent = text || (Math.round(pct) + '%');
        if (container) container.style.display = 'block';
    }
    
    function hideReprojectionProgress() {
        const container = document.getElementById('satellite-progress');
        if (container) container.style.display = 'none';
    }
    
    // Fun√ß√£o para verificar timestamp da imagem no servidor
    async function checkSatelliteTimestamp(satellite, product) {
        try {
            const url = getFullDiskUrl(satellite, product);
            // Fazer HEAD request para pegar Last-Modified
            const response = await fetch(url, { method: 'HEAD', mode: 'cors' });
            const lastModified = response.headers.get('Last-Modified');
            if (lastModified) {
                return new Date(lastModified);
            }
            // Fallback: usar timestamp atual
            return new Date();
        } catch (e) {
            console.warn('N√£o foi poss√≠vel verificar timestamp:', e);
            return null;
        }
    }
    
    // Fun√ß√£o para verificar se precisa atualizar a imagem
    async function shouldLoadSatellite(forceLoad = false) {
        if (forceLoad) return true;
        if (!satelliteLayer) return true;  // N√£o tem imagem carregada
        if (!currentSatelliteTimestamp) return true;  // N√£o sabe o hor√°rio
        
        const satId = currentSatellite;
        const product = document.getElementById('satellite-product')?.value || 'GEOCOLOR';
        
        try {
            const serverTimestamp = await checkSatelliteTimestamp(satId, product);
            if (serverTimestamp && serverTimestamp > currentSatelliteTimestamp) {
                log('info', `üîÑ Nova imagem dispon√≠vel: ${serverTimestamp.toLocaleTimeString()}`);
                return true;
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    // FUN√á√ÉO PRINCIPAL: Carregar sat√©lite com reproje√ß√£o real
    async function loadSatelliteWithReprojection(forceLoad = true) {
        // Verificar se j√° est√° carregando
        if (isLoadingSatellite) {
            log('warning', '‚è≥ J√° existe um carregamento em andamento...');
            return;
        }
        
        // Verificar se precisa carregar (a menos que seja for√ßado)
        if (!forceLoad) {
            const needsLoad = await shouldLoadSatellite(false);
            if (!needsLoad) {
                log('info', '‚úì Imagem de sat√©lite est√° atualizada');
                return;
            }
        }
        
        const satId = currentSatellite;
        const product = document.getElementById('satellite-product')?.value || 'GEOCOLOR';
        const quality = document.getElementById('satellite-quality')?.value || 'medium';
        const opacity = (document.getElementById('satellite-opacity')?.value || 75) / 100;
        
        isLoadingSatellite = true;
        setStatus('satellite-status', 'loading');
        log('info', `üõ∞Ô∏è Iniciando reproje√ß√£o REAL: ${satId.toUpperCase()} - ${product}`);
        setReprojectionProgress(5, 'Iniciando...');
        
        try {
            // N√ÉO remover camada anterior - manter vis√≠vel enquanto carrega nova
            
            // URL da imagem Full Disk
            const url = getFullDiskUrl(satId, product);
            log('info', `üì° Carregando imagem Full Disk...`);
            setReprojectionProgress(10, 'Baixando imagem...');
            
            // Carregar imagem
            const img = await loadImageAsync(url + '?t=' + Date.now());
            log('info', `‚úÖ Imagem carregada: ${img.width}x${img.height}`);
            setReprojectionProgress(30, 'Imagem carregada');
            
            // Configura√ß√µes de qualidade
            const qualitySettings = {
                low: { width: 600, interpolate: false },
                medium: { width: 1200, interpolate: true },
                high: { width: 2400, interpolate: true },
                max: { width: 4800, interpolate: true }
            };
            const settings = qualitySettings[quality] || qualitySettings.medium;
            
            log('info', `üîÑ Reprojetando (${quality}: ${settings.width}px)...`);
            setReprojectionProgress(35, `Reprojetando (${quality})...`);
            
            // Bounds para reproje√ß√£o
            const bounds = REPROJECTION_BOUNDS;
            
            // Converter bounds para Web Mercator
            const mercBounds = {
                minX: lonToMercatorX(bounds.west),
                maxX: lonToMercatorX(bounds.east),
                minY: latToMercatorY(bounds.south),
                maxY: latToMercatorY(bounds.north)
            };
            
            // Canvas de sa√≠da
            const outWidth = settings.width;
            const outHeight = Math.round(outWidth * (mercBounds.maxY - mercBounds.minY) / (mercBounds.maxX - mercBounds.minX));
            
            const canvas = document.createElement('canvas');
            canvas.width = outWidth;
            canvas.height = outHeight;
            const ctx = canvas.getContext('2d');
            
            // Canvas fonte
            const srcCanvas = document.createElement('canvas');
            srcCanvas.width = img.width;
            srcCanvas.height = img.height;
            const srcCtx = srcCanvas.getContext('2d');
            srcCtx.drawImage(img, 0, 0);
            const srcData = srcCtx.getImageData(0, 0, img.width, img.height);
            
            // Canvas destino
            const outData = ctx.createImageData(outWidth, outHeight);
            
            // GOES-East longitude
            const sat_lon = -75.0;
            
            // Par√¢metros da imagem Full Disk
            const scanMax = 0.1518;
            const imgRadius = Math.min(img.width, img.height) / 2;
            const scale = imgRadius / scanMax;
            const centerX = img.width / 2;
            const centerY = img.height / 2;
            
            let pixelsVisible = 0;
            
            // Loop de reproje√ß√£o
            for (let y = 0; y < outHeight; y++) {
                for (let x = 0; x < outWidth; x++) {
                    const mercX = mercBounds.minX + (x / outWidth) * (mercBounds.maxX - mercBounds.minX);
                    const mercY = mercBounds.maxY - (y / outHeight) * (mercBounds.maxY - mercBounds.minY);
                    
                    const lon = mercatorXToLon(mercX);
                    const lat = mercatorYToLat(mercY);
                    
                    const scan = latLonToScan(lat, lon, sat_lon);
                    if (!scan) continue;
                    
                    const srcX = centerX + scan.x * scale;
                    const srcY = centerY - scan.y * scale;
                    
                    if (srcX < 0 || srcX >= img.width - 1 || srcY < 0 || srcY >= img.height - 1) continue;
                    
                    let r, g, b;
                    if (settings.interpolate) {
                        const pixel = bilinearInterpolate(srcData, srcX, srcY);
                        r = pixel.r; g = pixel.g; b = pixel.b;
                    } else {
                        const sx = Math.floor(srcX);
                        const sy = Math.floor(srcY);
                        const srcIdx = (sy * srcData.width + sx) * 4;
                        r = srcData.data[srcIdx];
                        g = srcData.data[srcIdx + 1];
                        b = srcData.data[srcIdx + 2];
                    }
                    
                    const idx = (y * outWidth + x) * 4;
                    outData.data[idx] = r;
                    outData.data[idx + 1] = g;
                    outData.data[idx + 2] = b;
                    outData.data[idx + 3] = 255;
                    pixelsVisible++;
                }
                
                // Atualizar progresso
                if (y % 50 === 0) {
                    setReprojectionProgress(35 + (y / outHeight) * 60, `Reprojetando... ${Math.round(y / outHeight * 100)}%`);
                    await sleep(1);
                }
            }
            
            log('info', `üìä Reproje√ß√£o completa: ${pixelsVisible} pixels`);
            setReprojectionProgress(95, 'Finalizando...');
            
            ctx.putImageData(outData, 0, 0);
            
            // Criar overlay (em mem√≥ria primeiro)
            const dataUrl = canvas.toDataURL('image/png');
            const leafletBounds = [[bounds.south, bounds.west], [bounds.north, bounds.east]];
            
            // Criar nova camada em background
            const newLayer = L.imageOverlay(dataUrl, leafletBounds, {
                opacity: opacity,
                zIndex: 1
            });
            
            // Pr√©-carregar imagem antes de exibir
            const preloadImg = new Image();
            preloadImg.src = dataUrl;
            await new Promise((resolve) => {
                preloadImg.onload = resolve;
                preloadImg.onerror = resolve;
            });
            
            // Capturar timestamp da imagem
            const imageTimestamp = new Date();
            try {
                const serverTs = await checkSatelliteTimestamp(satId, product);
                if (serverTs) currentSatelliteTimestamp = serverTs;
                else currentSatelliteTimestamp = imageTimestamp;
            } catch (e) {
                currentSatelliteTimestamp = imageTimestamp;
            }
            
            // AGORA sim: remover camada antiga e adicionar nova (troca suave)
            if (satelliteLayer) {
                map.removeLayer(satelliteLayer);
            }
            satelliteLayer = newLayer;
            satelliteLayer.addTo(map);
            
            setReprojectionProgress(100, 'Conclu√≠do!');
            setTimeout(hideReprojectionProgress, 1000);
            
            // Atualizar info com timestamp do arquivo
            const infoEl = document.getElementById('satellite-info');
            const timestampStr = currentSatelliteTimestamp ? 
                currentSatelliteTimestamp.toLocaleString('pt-BR', { 
                    day: '2-digit', month: '2-digit', year: 'numeric',
                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                }) : 'N/A';
            if (infoEl) {
                infoEl.innerHTML = `üì° ${satId.toUpperCase()} ${product}<br>üîÑ Reproje√ß√£o REAL (${quality})<br>üìä ${pixelsVisible.toLocaleString()} pixels<br>üïê Arquivo: ${timestampStr}<br>‚è∞ Carregado: ${new Date().toLocaleTimeString()}`;
            }
            
            log('success', `‚úÖ Reproje√ß√£o conclu√≠da: ${satId.toUpperCase()} ${product}`);
            log('info', `üïê Hor√°rio do arquivo: ${timestampStr}`);
            setStatus('satellite-status', 'active');
            isLoadingSatellite = false;  // Liberar flag
            
        } catch (error) {
            log('error', `‚ùå Erro: ${error.message}`);
            console.error('‚ùå [REPROJECTION] Erro:', error);
            setStatus('satellite-status', 'error');
            hideReprojectionProgress();
            isLoadingSatellite = false;  // Liberar flag em caso de erro
        }
    }
    
    // Fun√ß√£o legada para compatibilidade - carrega s√≥ se necess√°rio ou se n√£o tiver imagem
    async function loadSatelliteLayer() {
        // Na inicializa√ß√£o, carregar se n√£o tiver imagem
        if (!satelliteLayer) {
            await loadSatelliteWithReprojection(true);
        } else {
            // Verificar se h√° imagem mais recente
            await loadSatelliteWithReprojection(false);
        }
    }
    
    function updateSatelliteOpacity(value) {
        document.getElementById('opacity-value').textContent = value + '%';
        if (satelliteLayer) {
            satelliteLayer.setOpacity(value / 100);
        }
    }
    
    function toggleSatelliteLayer() {
        satelliteEnabled = !satelliteEnabled;
        if (satelliteEnabled) {
            loadSatelliteLayer();
            log('info', 'üõ∞Ô∏è Camada de sat√©lite ativada');
        } else {
            if (satelliteLayer) map.removeLayer(satelliteLayer);
            setStatus('satellite-status', '');
            log('info', 'üõ∞Ô∏è Camada de sat√©lite desativada');
        }
    }
    
    // =========================================================================
    // GRADE DE COORDENADAS
    // =========================================================================
    function createGrid() {
        for (let lat = -30; lat <= -15; lat += 1) {
            L.polyline([[lat, CONFIG.lonMin - 2], [lat, CONFIG.lonMax + 2]], {
                color: '#333',
                weight: 1,
                opacity: 0.5
            }).addTo(gridLayer);
            
            L.marker([lat, CONFIG.lonMin - 1], {
                icon: L.divIcon({
                    className: 'grid-label',
                    html: `<span style="color:#666;font-size:10px">${lat}¬∞</span>`
                })
            }).addTo(gridLayer);
        }
        
        for (let lon = -50; lon <= -35; lon += 1) {
            L.polyline([[CONFIG.latMin - 2, lon], [CONFIG.latMax + 2, lon]], {
                color: '#333',
                weight: 1,
                opacity: 0.5
            }).addTo(gridLayer);
        }
    }
    
    // =========================================================================
    // TOGGLE DE CAMADAS
    // =========================================================================
    function toggleLayer(layer) {
        const checkbox = document.getElementById(`layer-${layer}`);
        switch(layer) {
            case 'arrows':
                if (checkbox.checked) windLayerGroup.addTo(map);
                else map.removeLayer(windLayerGroup);
                break;
            case 'grid':
                if (checkbox.checked) gridLayer.addTo(map);
                else map.removeLayer(gridLayer);
                break;
        }
    }
    
    // =========================================================================
    // BUSCAR DADOS - NOAA ERDDAP (GRATUITO!)
    // =========================================================================
    
    // Lista de datasets NOAA ERDDAP dispon√≠veis (em ordem de prefer√™ncia)
    const NOAA_DATASETS = [
        {
            id: 'erdQCwindproducts1day',
            name: 'MetOp-C ASCAT 1-Day (2020-presente)',
            vars: ['wind_speed', 'wind_direction']
        },
        {
            id: 'erdQCwindproducts3day',
            name: 'MetOp-C ASCAT 3-Day Composite',
            vars: ['wind_speed', 'wind_direction']
        },
        {
            id: 'erdNavgem05D10mWind',
            name: 'NAVGEM 0.5¬∞ 10m Wind (modelo)',
            vars: ['u_wind', 'v_wind']
        }
    ];
    
    async function fetchNOAAData() {
        setStatus('noaa-status', 'loading');
        log('info', 'üì° Buscando dados NOAA ERDDAP (ASCAT Metop-C)...');
        
        const baseUrl = 'https://coastwatch.pfeg.noaa.gov/erddap/griddap';
        
        // Tentar datasets em ordem de prefer√™ncia
        for (const dataset of NOAA_DATASETS) {
            log('info', `üîç Tentando: ${dataset.name}...`);
            
            // Dados de sat√©lite t√™m atraso de ~24h no processamento
            // Buscar de 4 dias atr√°s at√© 1 dia atr√°s
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000);
            const fourDaysAgo = new Date(now.getTime() - 4 * 24 * 60 * 60 * 1000);
            
            const startTime = fourDaysAgo.toISOString().split('.')[0] + 'Z';
            const endTime = oneDayAgo.toISOString().split('.')[0] + 'Z';
            
            // Construir URL baseado nas vari√°veis do dataset
            // Nota: erdQCwindproducts tem dimens√£o altitude (10m)
            let erddapUrl;
            if (dataset.vars.includes('wind_speed')) {
                // Dataset com wind_speed e wind_direction diretos (com altitude)
                erddapUrl = `${baseUrl}/${dataset.id}.json?` +
                    `wind_speed[(${startTime}):1:(${endTime})]` +
                    `[(10.0)]` +  // altitude 10m
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]` +
                    `,wind_direction[(${startTime}):1:(${endTime})]` +
                    `[(10.0)]` +  // altitude 10m
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]`;
            } else {
                // Dataset com componentes u/v (pode ter altitude ou n√£o)
                erddapUrl = `${baseUrl}/${dataset.id}.json?` +
                    `${dataset.vars[0]}[(${startTime}):1:(${endTime})]` +
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]` +
                    `,${dataset.vars[1]}[(${startTime}):1:(${endTime})]` +
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]`;
            }
            
            try {
                // Usar proxy local para evitar CORS
                const url = `/api/noaa?url=${encodeURIComponent(erddapUrl)}`;
                log('info', 'Buscando via proxy local...');
                
                const response = await fetch(url, { timeout: 30000 });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    log('warning', `Dataset ${dataset.id} indispon√≠vel: ${response.status} - ${errorData.reason || ''}`);
                    continue; // Tentar pr√≥ximo dataset
                }
                
                const data = await response.json();
                
                // Verificar se h√° dados v√°lidos
                if (data && data.table && data.table.rows && data.table.rows.length > 0) {
                    log('success', `‚úÖ Dados obtidos de ${dataset.name}: ${data.table.rows.length} pontos`);
                    processNOAAData(data, dataset.vars.includes('wind_speed'));
                    setStatus('noaa-status', 'active');
                    return; // Sucesso!
                } else {
                    log('warning', `Dataset ${dataset.id} sem dados para a √°rea/per√≠odo`);
                }
                
            } catch (error) {
                log('warning', `Erro no dataset ${dataset.id}: ${error.message}`);
                continue; // Tentar pr√≥ximo
            }
        }
        
        // Se todos falharam, usar Open-Meteo como fallback
        log('warning', '‚ö†Ô∏è Nenhum dataset NOAA dispon√≠vel, usando Open-Meteo como fallback');
        setStatus('noaa-status', 'error');
        await fetchOpenMeteoWindGrid();
    }
    
    // Fallback: buscar grid de vento do Open-Meteo
    async function fetchOpenMeteoWindGrid() {
        log('info', 'üîÑ Buscando grid de vento Open-Meteo...');
        
        // Criar grid de pontos na √°rea
        const lats = [];
        const lons = [];
        const step = 0.5;
        
        for (let lat = CONFIG.latMin; lat <= CONFIG.latMax; lat += step) {
            lats.push(lat.toFixed(2));
        }
        for (let lon = CONFIG.lonMin; lon <= CONFIG.lonMax; lon += step) {
            lons.push(lon.toFixed(2));
        }
        
        // Criar todas as combina√ß√µes
        const queryLats = [];
        const queryLons = [];
        for (const lat of lats) {
            for (const lon of lons) {
                queryLats.push(lat);
                queryLons.push(lon);
            }
        }
        
        // Limitar a 50 pontos (limite da API)
        const maxPoints = 50;
        const selectedLats = queryLats.slice(0, maxPoints);
        const selectedLons = queryLons.slice(0, maxPoints);
        
        const url = `https://api.open-meteo.com/v1/forecast?` +
            `latitude=${selectedLats.join(',')}&` +
            `longitude=${selectedLons.join(',')}&` +
            `current=wind_speed_10m,wind_direction_10m&` +
            `wind_speed_unit=kn`;
        
        try {
            const response = await fetch(url);
            const data = await response.json();
            
            let count = 0;
            if (Array.isArray(data)) {
                data.forEach(point => {
                    if (point.current) {
                        addWindPoint({
                            lat: point.latitude,
                            lon: point.longitude,
                            speed: point.current.wind_speed_10m,
                            direction: point.current.wind_direction_10m,
                            time: new Date(),
                            source: 'Open-Meteo Grid'
                        });
                        count++;
                    }
                });
            } else if (data.current) {
                addWindPoint({
                    lat: data.latitude,
                    lon: data.longitude,
                    speed: data.current.wind_speed_10m,
                    direction: data.current.wind_direction_10m,
                    time: new Date(),
                    source: 'Open-Meteo Grid'
                });
                count = 1;
            }
            
            log('success', `‚úÖ Grid Open-Meteo: ${count} pontos`);
            updateWindDisplay();
            setStatus('noaa-status', 'active');
            
        } catch (error) {
            log('error', `Erro Open-Meteo Grid: ${error.message}`);
        }
    }
    
    // =========================================================================
    // OPEN-METEO (MULTI-MODELO) COM PESOS DIN√ÇMICOS
    // =========================================================================
    
    // Lista de modelos dispon√≠veis
    const MODELS = ['gfs_seamless', 'ecmwf_ifs025', 'icon_seamless', 'meteofrance_seamless', 'jma_seamless'];
    const MODEL_NAMES = {
        'gfs_seamless': 'GFS',
        'ecmwf_ifs025': 'ECMWF', 
        'icon_seamless': 'ICON',
        'meteofrance_seamless': 'MeteoFR',
        'jma_seamless': 'JMA'
    };
    
    // Armazena dados de todos os modelos
    let modelData = {};
    MODELS.forEach(m => modelData[m] = { speed: null, direction: null });
    
    // Pesos din√¢micos (iniciam iguais)
    let modelWeights = {};
    MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
    
    // Hist√≥rico de previs√µes para compara√ß√£o
    let forecastHistory = [];
    
    // Carregar hist√≥rico do localStorage
    function loadForecastHistory() {
        try {
            const saved = localStorage.getItem('forecastHistoryMulti');
            if (saved) {
                forecastHistory = JSON.parse(saved);
                const cutoff = Date.now() - 24 * 60 * 60 * 1000;
                forecastHistory = forecastHistory.filter(h => h.timestamp > cutoff);
                log('info', `üìä Hist√≥rico carregado: ${forecastHistory.length} registros`);
                calculateDynamicWeights();
            }
        } catch (e) {
            forecastHistory = [];
        }
    }
    
    function saveForecastHistory() {
        try {
            localStorage.setItem('forecastHistoryMulti', JSON.stringify(forecastHistory));
        } catch (e) {}
    }
    
    function directionError(predicted, actual) {
        if (predicted === null || actual === null) return 180;
        let diff = Math.abs(predicted - actual);
        if (diff > 180) diff = 360 - diff;
        return diff;
    }
    
    // Calcular pesos baseado no erro hist√≥rico de TODOS os modelos
    function calculateDynamicWeights() {
        if (forecastHistory.length < 2) {
            MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
            document.getElementById('weight-reason').textContent = 'Pesos iguais (hist√≥rico insuficiente)';
            return;
        }
        
        let modelErrors = {};
        MODELS.forEach(m => modelErrors[m] = 0);
        let comparisons = 0;
        
        for (let i = 1; i < forecastHistory.length; i++) {
            const prev = forecastHistory[i - 1];
            const curr = forecastHistory[i];
            
            MODELS.forEach(model => {
                if (prev[model] && curr[model] && prev[model].speed !== null && curr[model].speed !== null) {
                    const speedErr = Math.abs(prev[model].speed - curr[model].speed) / 20;
                    const dirErr = directionError(prev[model].direction, curr[model].direction) / 180;
                    modelErrors[model] += (speedErr + dirErr) / 2;
                }
            });
            comparisons++;
        }
        
        if (comparisons === 0) {
            MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
            return;
        }
        
        // Normalizar erros
        MODELS.forEach(m => modelErrors[m] /= comparisons);
        
        // Converter erros em pesos (menor erro = maior peso)
        let totalInvError = 0;
        MODELS.forEach(m => {
            const invErr = 1 / (modelErrors[m] + 0.01); // +0.01 para evitar divis√£o por zero
            modelWeights[m] = invErr;
            totalInvError += invErr;
        });
        
        // Normalizar pesos
        MODELS.forEach(m => modelWeights[m] /= totalInvError);
        
        // Limitar entre 5% e 40%
        MODELS.forEach(m => {
            modelWeights[m] = Math.max(0.05, Math.min(0.40, modelWeights[m]));
        });
        
        // Renormalizar
        let sum = 0;
        MODELS.forEach(m => sum += modelWeights[m]);
        MODELS.forEach(m => modelWeights[m] /= sum);
        
        // Encontrar melhor modelo
        let bestModel = MODELS[0];
        let lowestError = modelErrors[MODELS[0]];
        MODELS.forEach(m => {
            if (modelErrors[m] < lowestError) {
                lowestError = modelErrors[m];
                bestModel = m;
            }
        });
        
        document.getElementById('weight-reason').innerHTML = 
            `‚öñÔ∏è ${comparisons} compara√ß√µes | Melhor: <span style="color:#00ff00;">${MODEL_NAMES[bestModel]}</span>`;
        
        log('info', `‚öñÔ∏è Pesos: ${MODELS.map(m => MODEL_NAMES[m] + ':' + (modelWeights[m]*100).toFixed(0) + '%').join(' | ')}`);
    }
    
    function addToForecastHistory(data) {
        const record = { timestamp: Date.now() };
        MODELS.forEach(m => {
            record[m] = data[m] ? { speed: data[m].speed, direction: data[m].direction } : { speed: null, direction: null };
        });
        
        forecastHistory.push(record);
        if (forecastHistory.length > 96) forecastHistory = forecastHistory.slice(-96);
        
        saveForecastHistory();
        calculateDynamicWeights();
    }
    
    async function fetchOpenMeteoData() {
        setStatus('openmeteo-status', 'loading');
        log('info', 'üåê Buscando 5 modelos (Open-Meteo)...');
        
        try {
            if (forecastHistory.length === 0) loadForecastHistory();
            
            // Limpar dados anteriores
            windDataPoints = windDataPoints.filter(p => 
                !p.source.includes('GFS') && !p.source.includes('ECMWF') && 
                !p.source.includes('ICON') && !p.source.includes('MeteoFR') && 
                !p.source.includes('JMA') && p.source !== 'Open-Meteo'
            );
            
            // Usar endpoint /forecast com par√¢metro models para todos
            // Isso garante dados 'current' dispon√≠veis para todos os modelos
            const promises = MODELS.map(async model => {
                try {
                    // Endpoint unificado com par√¢metro models
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.shipLat}&longitude=${CONFIG.shipLon}&current=wind_speed_10m,wind_direction_10m&models=${model}&wind_speed_unit=kn`;
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.current && data.current.wind_speed_10m !== undefined) {
                        modelData[model] = {
                            speed: data.current.wind_speed_10m,
                            direction: data.current.wind_direction_10m
                        };
                        log('info', `  ‚úì ${MODEL_NAMES[model]}: ${data.current.wind_speed_10m.toFixed(1)} kn`);
                    } else {
                        log('warning', `  ‚úó ${MODEL_NAMES[model]}: sem dados current`);
                    }
                } catch (e) {
                    log('warning', `  ‚úó ${MODEL_NAMES[model]}: ${e.message}`);
                }
            });
            
            await Promise.all(promises);
            
            // Adicionar ao hist√≥rico
            addToForecastHistory(modelData);
            
            // Atualizar display
            updateModelAverage();
            
            // Criar grid de pontos para o mapa (50 NM)
            await fetchGridPoints();
            
            updateWindDisplay();
            setStatus('openmeteo-status', 'active');
            
            const activeModels = MODELS.filter(m => modelData[m].speed !== null).length;
            log('success', `‚úÖ ${activeModels} modelos carregados - Pr√≥xima atualiza√ß√£o em 15 min`);
            
        } catch (error) {
            log('error', '‚ùå Erro: ' + error.message);
            setStatus('openmeteo-status', 'error');
        }
    }
    
    async function fetchGridPoints() {
        // Grid CIRCULAR com espa√ßamento ajustado para o raio de 100NM
        // Usando 0.25¬∞ (~15 NM) para melhor distribui√ß√£o no c√≠rculo maior
        const step = 0.25;  // Espa√ßamento maior para cobrir 100 NM sem sobrecarregar
        const raioGraus = RAIO_GRAUS;
        
        let queryLats = [];
        let queryLons = [];
        
        // Calcular quantos passos cabem no raio
        const numSteps = Math.floor(raioGraus / step);
        
        // Iterar de -numSteps a +numSteps (garante simetria perfeita)
        for (let i = -numSteps; i <= numSteps; i++) {
            for (let j = -numSteps; j <= numSteps; j++) {
                const lat = CONFIG.shipLat + (i * step);
                const lon = CONFIG.shipLon + (j * step);
                
                // Dist√¢ncia do centro em passos
                const dist = Math.sqrt(i*i + j*j) * step;
                
                // S√≥ incluir se dentro do c√≠rculo
                if (dist <= raioGraus) {
                    queryLats.push(lat.toFixed(3));
                    queryLons.push(lon.toFixed(3));
                }
            }
        }
        
        log('info', `üìç Grid circular: ${queryLats.length} pontos (step ${step}¬∞, raio ${RAIO_NM} NM)`);
        
        // Usar forecast API com modelo padr√£o para o grid
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${queryLats.join(',')}&longitude=${queryLons.join(',')}&current=wind_speed_10m,wind_direction_10m&wind_speed_unit=kn`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        let addedCount = 0;
        
        if (Array.isArray(data)) {
            data.forEach((point, idx) => {
                // Usar coordenadas SOLICITADAS, n√£o as retornadas pela API
                const lat = parseFloat(queryLats[idx]);
                const lon = parseFloat(queryLons[idx]);
                
                if (point.current && point.current.wind_speed_10m !== null) {
                    addWindPoint({
                        lat: lat,
                        lon: lon,
                        speed: point.current.wind_speed_10m,
                        direction: point.current.wind_direction_10m,
                        time: new Date(),
                        source: 'Modelo (Open-Meteo)'
                    });
                    addedCount++;
                }
            });
        } else if (data.current && data.current.wind_speed_10m !== null) {
            addWindPoint({
                lat: parseFloat(queryLats[0]),
                lon: parseFloat(queryLons[0]),
                speed: data.current.wind_speed_10m,
                direction: data.current.wind_direction_10m,
                time: new Date(),
                source: 'Modelo (Open-Meteo)'
            });
            addedCount++;
        }
        
        log('info', `üìç Pontos adicionados: ${addedCount}/${queryLats.length}`);
    }
    
    function updateModelAverage() {
        // Atualizar valores individuais na UI
        const uiMap = {
            'gfs_seamless': 'gfs',
            'ecmwf_ifs025': 'ecmwf',
            'icon_seamless': 'icon',
            'meteofrance_seamless': 'meteofr',
            'jma_seamless': 'jma'
        };
        
        let validModels = 0;
        let weightedSpeed = 0;
        let weightedDirX = 0;
        let weightedDirY = 0;
        
        MODELS.forEach(model => {
            const uiKey = uiMap[model];
            const data = modelData[model];
            const weight = modelWeights[model];
            
            // Atualizar UI
            const valEl = document.getElementById(`${uiKey}-value`);
            const weightEl = document.getElementById(`${uiKey}-weight`);
            
            if (data && data.speed !== null) {
                valEl.textContent = `${data.speed.toFixed(1)} kn / ${data.direction.toFixed(0)}¬∞`;
                weightEl.textContent = `(${(weight * 100).toFixed(0)}%)`;
                
                // Acumular para m√©dia ponderada
                weightedSpeed += data.speed * weight;
                const rad = data.direction * Math.PI / 180;
                weightedDirX += Math.cos(rad) * weight;
                weightedDirY += Math.sin(rad) * weight;
                validModels++;
            } else {
                valEl.textContent = '--';
                weightEl.textContent = '';
            }
        });
        
        // Calcular m√©dia ponderada
        if (validModels > 0) {
            let avgDir = Math.atan2(weightedDirY, weightedDirX) * 180 / Math.PI;
            if (avgDir < 0) avgDir += 360;
            
            document.getElementById('avg-model-speed').textContent = weightedSpeed.toFixed(1);
            document.getElementById('avg-model-dir').textContent = avgDir.toFixed(0) + '¬∞';
            
            log('info', `üåç M√©dia Ponderada (${validModels} modelos): ${weightedSpeed.toFixed(1)} kn de ${avgDir.toFixed(0)}¬∞`);
        }
    }
    
    function clearOpenMeteoData() {
        windDataPoints = windDataPoints.filter(p => 
            !p.source.includes('GFS') && !p.source.includes('ECMWF') && 
            !p.source.includes('ICON') && !p.source.includes('Modelo') && 
            p.source !== 'Open-Meteo'
        );
        MODELS.forEach(m => modelData[m] = { speed: null, direction: null });
        document.getElementById('avg-model-speed').textContent = '--';
        document.getElementById('avg-model-dir').textContent = '--';
        updateWindDisplay();
        setStatus('openmeteo-status', '');
        log('info', 'üóëÔ∏è Dados de modelos removidos');
    }
    
    function processNOAAData(data, hasDirectSpeed = false) {
        if (!data.table || !data.table.rows) {
            log('warning', 'Dados NOAA vazios');
            return;
        }
        
        const rows = data.table.rows;
        const columnNames = data.table.columnNames || [];
        let count = 0;
        
        // Detectar formato das colunas
        const hasWindSpeed = columnNames.includes('wind_speed');
        const hasWindDirection = columnNames.includes('wind_direction');
        
        rows.forEach(row => {
            // Detectar estrutura baseado no n√∫mero de colunas
            // Com altitude: [time, altitude, lat, lon, wind_speed, wind_direction]
            // Sem altitude: [time, lat, lon, wind_speed, wind_direction]
            const hasAltitude = columnNames.includes('altitude');
            const offset = hasAltitude ? 1 : 0;
            
            const time = new Date(row[0]);
            const lat = row[1 + offset];
            const lon = row[2 + offset];
            
            let speed, direction;
            
            if (hasDirectSpeed || hasWindSpeed) {
                // Formato com wind_speed e wind_direction diretos
                speed = row[3 + offset];  // j√° em m/s
                direction = row[4 + offset];  // j√° em graus
                
                if (speed !== null && direction !== null) {
                    speed = speed * 1.94384;  // m/s para knots
                }
            } else {
                // Formato com componentes u/v
                const u = row[3 + offset];  // componente x
                const v = row[4 + offset];  // componente y
                
                if (u !== null && v !== null) {
                    // Calcular velocidade e dire√ß√£o
                    speed = Math.sqrt(u*u + v*v) * 1.94384;  // m/s para knots
                    direction = (Math.atan2(-u, -v) * 180 / Math.PI + 360) % 360;
                }
            }
            
            if (speed !== null && direction !== null && !isNaN(speed) && !isNaN(direction)) {
                addWindPoint({
                    lat: lat,
                    lon: lon,
                    speed: speed,
                    direction: direction,
                    time: time,
                    source: 'NOAA ASCAT'
                });
                count++;
            }
        });
        
        updateWindDisplay();
        log('success', `‚úÖ NOAA: ${count} pontos carregados`);
    }
    
    // =========================================================================
    // BUSCAR DADOS - COPERNICUS MARINE
    // =========================================================================
    async function fetchCopernicusData() {
        const user = document.getElementById('cmems-user').value;
        const pass = document.getElementById('cmems-pass').value;
        
        if (!user || !pass) {
            log('warning', 'CMEMS: Insira usu√°rio e senha');
            return;
        }
        
        setStatus('cmems-status', 'loading');
        log('info', 'Buscando dados Copernicus Marine...');
        
        // CMEMS usa WMS/WCS - precisamos de uma abordagem diferente
        // Para uso real, seria necess√°rio usar o copernicusmarine Python client
        // Aqui vamos mostrar como seria a URL
        
        const datasetId = 'WIND_GLO_PHY_L4_NRT_012_004';  // Global wind L4
        
        log('info', `Dataset: ${datasetId}`);
        log('warning', 'CMEMS requer autentica√ß√£o OAuth - use o Python client');
        log('info', 'Comando: pip install copernicusmarine');
        log('info', 'copernicusmarine subset -i ' + datasetId);
        
        // Mostrar instru√ß√µes
        alert(`Para acessar dados Copernicus Marine:

1. Instale o cliente Python:
   pip install copernicusmarine

2. Configure credenciais:
   copernicusmarine login

3. Baixe dados de vento:
   copernicusmarine subset \
     --dataset-id WIND_GLO_PHY_L4_NRT_012_004 \
     --variable eastward_wind \
     --variable northward_wind \
     --minimum-longitude ${CONFIG.lonMin} \
     --maximum-longitude ${CONFIG.lonMax} \
     --minimum-latitude ${CONFIG.latMin} \
     --maximum-latitude ${CONFIG.latMax}`);
        
        setStatus('cmems-status', 'error');
    }
    
    // =========================================================================
    // BUSCAR DADOS - NASA EARTHDATA
    // =========================================================================
    async function fetchNASAData() {
        const user = document.getElementById('nasa-user').value;
        const pass = document.getElementById('nasa-pass').value;
        
        if (!user || !pass) {
            log('warning', 'NASA: Insira usu√°rio e senha');
            return;
        }
        
        setStatus('nasa-status', 'loading');
        log('info', 'Buscando dados NASA Earthdata (CYGNSS)...');
        
        // NASA Earthdata tamb√©m requer autentica√ß√£o especial
        // CYGNSS √© um constela√ß√£o de 8 sat√©lites que mede vento oce√¢nico
        
        log('info', 'Datasets dispon√≠veis:');
        log('info', '- CYGNSS L2 Ocean Surface Wind Speed');
        log('info', '- QuikSCAT Level 2B (hist√≥rico)');
        log('info', '- RapidSCAT Level 2B (hist√≥rico)');
        
        log('warning', 'NASA Earthdata requer token de autentica√ß√£o');
        log('info', 'Use: https://search.earthdata.nasa.gov');
        
        setStatus('nasa-status', 'error');
    }
    
    // =========================================================================
    // FUN√á√ïES DE VISUALIZA√á√ÉO
    // =========================================================================
    function addWindPoint(point) {
        windDataPoints.push(point);
    }
    
    function updateWindDisplay() {
        windLayerGroup.clearLayers();
        
        if (windDataPoints.length === 0) return;
        
        const now = new Date();
        const maxAgeMs = MAX_DATA_AGE_MINUTES * 60 * 1000;  // Converter para milissegundos
        
        // FILTRAR dados que est√£o dentro do limite de idade (60 min)
        const recentPoints = windDataPoints.filter(point => {
            const ageMs = now - point.time;
            return ageMs <= maxAgeMs;
        });
        
        // Contar quantos foram descartados
        const discardedCount = windDataPoints.length - recentPoints.length;
        if (discardedCount > 0) {
            log('warning', `‚ö†Ô∏è ${discardedCount} pontos descartados (mais de ${MAX_DATA_AGE_MINUTES} min de atraso)`);
        }
        
        // Atualizar array global apenas com dados recentes
        windDataPoints = recentPoints;
        
        if (windDataPoints.length === 0) {
            log('warning', `‚ùå Nenhum dado com menos de ${MAX_DATA_AGE_MINUTES} min de idade`);
            document.getElementById('avg-wind').textContent = '--';
            document.getElementById('max-wind').textContent = '--';
            document.getElementById('data-points').textContent = '0';
            document.getElementById('data-age').textContent = '--';
            setStatus('wind-status', 'error');
            return;
        }
        
        let totalSpeed = 0;
        let maxSpeed = 0;
        let latestTime = new Date(0);
        
        windDataPoints.forEach(point => {
            // Desenhar seta
            drawWindArrow(point.lat, point.lon, point.direction, point.speed, point.source);
            
            // Estat√≠sticas
            totalSpeed += point.speed;
            if (point.speed > maxSpeed) maxSpeed = point.speed;
            if (point.time > latestTime) latestTime = point.time;
        });
        
        // Atualizar painel
        const avgSpeed = totalSpeed / windDataPoints.length;
        const ageMinutes = (now - latestTime) / (1000 * 60);  // Idade em minutos
        
        document.getElementById('avg-wind').textContent = avgSpeed.toFixed(1);
        document.getElementById('max-wind').textContent = maxSpeed.toFixed(1);
        document.getElementById('data-points').textContent = windDataPoints.length;
        document.getElementById('data-age').textContent = ageMinutes.toFixed(0) + ' min';
        
        // Status baseado na idade
        if (ageMinutes <= 30) {
            setStatus('wind-status', 'active');
        } else if (ageMinutes <= MAX_DATA_AGE_MINUTES) {
            setStatus('wind-status', 'loading');  // Amarelo para dados entre 30-60 min
        } else {
            setStatus('wind-status', 'error');
        }
    }
    
    function drawWindArrow(lat, lon, direction, speed, source) {
        // Cor baseada na velocidade
        let color;
        if (speed < 10) color = '#00ff00';
        else if (speed < 15) color = '#88ff00';
        else if (speed < 20) color = '#ffff00';
        else if (speed < 25) color = '#ff9900';
        else if (speed < 30) color = '#ff0000';
        else color = '#ff00ff';
        
        // ESCATER√îMETROS: √≠cone maior, borda destacada, zIndex alto
        const isScatterometer = source.includes('ASCAT') || source.includes('NOAA') || 
                                source.includes('CYGNSS') || source.includes('Copernicus') ||
                                source.includes('Scatterometer');
        
        const size = isScatterometer ? 36 : 22;
        const fontSize = isScatterometer ? '11px' : '9px';
        const borderStyle = isScatterometer ? `border: 2px solid ${color}; border-radius: 50%; background: rgba(0,0,0,0.7); padding: 3px;` : '';
        const zIndex = isScatterometer ? 1000 : 100;
        
        // DIRE√á√ÉO: Valor indica DE ONDE o vento vem (conven√ß√£o meteorol√≥gica)
        // Seta aponta PARA ONDE o vento vai (rota√ß√£o +180¬∞)
        // Ex: Vento de 0¬∞ (Norte) -> seta aponta para Sul (180¬∞)
        const arrowRotation = (direction + 180) % 360;  // Rotaciona 180¬∞
        
        const arrowHtml = `
            <div style="${borderStyle} transform: rotate(${arrowRotation}deg); width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center;">
                <svg viewBox="0 0 24 24" width="${size - 8}" height="${size - 8}">
                    <path fill="${color}" stroke="${isScatterometer ? '#fff' : 'none'}" stroke-width="${isScatterometer ? 1 : 0}" d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
                </svg>
            </div>
            <div style="text-align:center; font-size:${fontSize}; font-weight:bold; color:${color}; text-shadow: 1px 1px 2px black;">
                ${speed.toFixed(0)}${isScatterometer ? '‚óÜ' : ''}
            </div>
        `;

        const icon = L.divIcon({
            className: 'wind-arrow' + (isScatterometer ? ' scatterometer' : ' openmeteo'),
            html: arrowHtml,
            iconSize: [size, size + 12],
            iconAnchor: [size/2, (size + 12)/2]
        });

        L.marker([lat, lon], { icon: icon, zIndexOffset: zIndex })
            .bindPopup(`
                <b>Dados de Vento</b><br>
                Velocidade: ${speed.toFixed(1)} kn<br>
                Dire√ß√£o: ${direction.toFixed(0)}¬∞<br>
                Fonte: ${source}<br>
                Lat: ${lat.toFixed(3)}<br>
                Lon: ${lon.toFixed(3)}
            `)
            .addTo(windLayerGroup);
    }
    
    // =========================================================================
    // FUN√á√ïES AUXILIARES
    // =========================================================================
    function log(type, message) {
        const logArea = document.getElementById('log-area');
        const time = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${time}] ${message}`;
        logArea.appendChild(entry);
        logArea.scrollTop = logArea.scrollHeight;
    }
    
    function setStatus(elementId, status) {
        const el = document.getElementById(elementId);
        if (el) {
            el.className = 'status-indicator ' + status;
        }
    }
    
    function saveCmemsCredentials() {
        const user = document.getElementById('cmems-user').value;
        const pass = document.getElementById('cmems-pass').value;
        localStorage.setItem('cmems-user', user);
        localStorage.setItem('cmems-pass', pass);
        log('success', 'Credenciais CMEMS salvas');
    }
    
    function saveNasaCredentials() {
        const user = document.getElementById('nasa-user').value;
        const pass = document.getElementById('nasa-pass').value;
        localStorage.setItem('nasa-user', user);
        localStorage.setItem('nasa-pass', pass);
        log('success', 'Credenciais NASA salvas');
    }
    
    function loadSavedCredentials() {
        // Credenciais desabilitadas - escater√¥metros t√™m atraso > 60 min
        // Apenas Open-Meteo (tempo real) est√° habilitado
    }
    
    function fetchAllSources() {
        log('info', `‚è±Ô∏è Limite de idade: ${MAX_DATA_AGE_MINUTES} minutos`);
        log('info', 'üåê Buscando dados em TEMPO REAL...');
        fetchOpenMeteoData();
        // NOTA: Dados de escater√¥metro satelital (NOAA ASCAT, NASA CYGNSS, Copernicus)
        // t√™m atraso m√≠nimo de 2-6 horas no processamento.
        // Apenas Open-Meteo fornece dados com < 60 min de atraso.
        // NDBC B√≥ias n√£o cobrem costa brasileira (Bacia de Campos)
        log('info', '‚úÖ Fonte: Open-Meteo (tempo real)');
    }
    
    function clearData() {
        windDataPoints = [];
        windLayerGroup.clearLayers();
        document.getElementById('avg-wind').textContent = '--';
        document.getElementById('max-wind').textContent = '--';
        document.getElementById('data-points').textContent = '--';
        document.getElementById('data-age').textContent = '--';
        setStatus('wind-status', '');
        log('info', 'Dados limpos');
    }
    
    function exportData() {
        if (windDataPoints.length === 0) {
            log('warning', 'Nenhum dado para exportar');
            return;
        }
        
        let csv = 'latitude,longitude,wind_speed_kn,wind_direction,source,timestamp\n';
        windDataPoints.forEach(p => {
            csv += `${p.lat},${p.lon},${p.speed.toFixed(2)},${p.direction.toFixed(1)},${p.source},${p.time.toISOString()}\n`;
        });
        
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `scatterometer_data_${new Date().toISOString().slice(0,10)}.csv`;
        a.click();
        
        log('success', 'Dados exportados para CSV');
    }
    
    // =========================================================================
    // INICIAR
    // =========================================================================
    initMap();
</script>

</body>
</html>
