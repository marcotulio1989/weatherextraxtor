
<!DOCTYPE html>
<html>
<head>
    <title>Monitor de Vento - Tempo Real - Deepwater Aquila</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; padding: 0; 
            background: #0a0a0a; 
            font-family: 'Consolas', 'Monaco', monospace; 
            color: #e0e0e0; 
        }
        
        /* Layout Principal */
        .container {
            display: flex;
            height: 100vh;
        }
        
        /* Painel Lateral */
        .sidebar {
            width: 380px;
            background: #111;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 15px;
        }
        
        /* Mapa */
        #map { 
            flex: 1;
            height: 100vh;
        }
        
        /* Estilos do Painel */
        h1 {
            font-size: 16px;
            color: #00ffcc;
            border-bottom: 2px solid #00ffcc;
            padding-bottom: 10px;
            margin: 0 0 15px 0;
        }
        
        h2 {
            font-size: 13px;
            color: #ff9900;
            margin: 20px 0 10px 0;
            text-transform: uppercase;
        }
        
        .section {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .section-title {
            font-size: 12px;
            color: #00ffcc;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Se√ß√µes Colaps√°veis */
        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 8px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            user-select: none;
        }
        
        .collapsible-header:hover {
            color: #00ffcc;
        }
        
        .collapsible-header h2 {
            margin: 0;
            font-size: 13px;
            color: #ff9900;
            text-transform: uppercase;
        }
        
        .collapsible-arrow {
            font-size: 12px;
            transition: transform 0.3s;
            color: #888;
        }
        
        .collapsible-header.collapsed .collapsible-arrow {
            transform: rotate(-90deg);
        }
        
        .collapsible-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s;
            opacity: 1;
        }
        
        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .status-indicator.active { background: #00ff00; }
        .status-indicator.loading { background: #ffff00; animation: pulse 1s infinite; }
        .status-indicator.error { background: #ff0000; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Inputs */
        label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
        }
        
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 3px;
            font-family: inherit;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        input:focus {
            outline: none;
            border-color: #00ffcc;
        }
        
        button {
            padding: 8px 16px;
            background: #00ffcc;
            color: #000;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        button:hover {
            background: #00ddaa;
        }
        
        button.secondary {
            background: #444;
            color: #fff;
        }
        
        button.secondary:hover {
            background: #555;
        }
        
        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        /* Toggle Button para Sat√©lite */
        .toggle-btn {
            flex: 1;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #555;
            color: #888;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        
        .toggle-btn:hover {
            background: #444;
            color: #ccc;
        }
        
        .toggle-btn.active {
            background: #00cc99;
            border-color: #00ffcc;
            color: #000;
        }
        
        /* Log de Status */
        .log-area {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-size: 11px;
            border-radius: 3px;
        }
        
        .log-entry {
            margin-bottom: 4px;
            padding-left: 10px;
            border-left: 2px solid #444;
        }
        
        .log-entry.info { border-left-color: #00ffcc; }
        .log-entry.success { border-left-color: #00ff00; }
        .log-entry.error { border-left-color: #ff0000; }
        .log-entry.warning { border-left-color: #ffff00; }
        
        /* Dados de Vento */
        .wind-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .stat-box {
            background: #222;
            padding: 10px;
            text-align: center;
            border-radius: 3px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #00ffcc;
        }
        
        .stat-label {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        /* Legenda */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        /* Checkbox customizado */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .checkbox-item input {
            width: 16px;
            height: 16px;
        }
        
        /* Fonte info */
        .source-info {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }
        
        /* Estilos para setas de vento DMW - com anima√ß√£o ondulante */
        .dmw-wind-arrow {
            background: transparent !important;
            border: none !important;
            /* Anima√ß√£o aplicada via keyframes acima */
        }
        
        .source-info a {
            color: #00aaff;
        }
        
        /* Forecast Tabs - Tabela Horizontal GIGANTE para visualiza√ß√£o de 10m */
        .forecast-tabs-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #000;
            border-bottom: 4px solid #00ffcc;
            padding: 5px 5px 10px 5px;
            z-index: 2000;
        }
        
        /* Linha 1: T√≠tulo + Per√≠odo */
        .forecast-row-1 {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 0 5px;
        }
        
        .forecast-title {
            color: #00ffcc;
            font-size: 18px;
            font-weight: bold;
            white-space: nowrap;
        }
        
        .forecast-period-tabs {
            display: flex;
            gap: 8px;
        }
        
        .forecast-period-btn {
            padding: 8px 20px;
            background: #333;
            border: 2px solid #555;
            color: #888;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.2s;
        }
        
        .forecast-period-btn:hover {
            background: #444;
            color: #ccc;
        }
        
        .forecast-period-btn.active {
            background: #00cc99;
            border-color: #00ffcc;
            color: #000;
        }
        
        .forecast-status {
            font-size: 14px;
            color: #666;
            white-space: nowrap;
        }
        
        /* Tabela de Forecast - FULL WIDTH */
        .forecast-grid-container {
            overflow-x: auto;
            scrollbar-width: thin;
            scrollbar-color: #444 #1a1a1a;
            width: 100%;
        }
        
        .forecast-grid-container::-webkit-scrollbar {
            height: 8px;
        }
        
        .forecast-grid-container::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .forecast-grid-container::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        
        .forecast-grid {
            display: grid;
            grid-template-rows: auto auto auto auto;
            gap: 2px;
            width: 100%;
        }
        
        .forecast-row {
            display: flex;
            align-items: center;
            width: 100%;
        }
        
        .forecast-row-label {
            width: 90px;
            flex-shrink: 0;
            font-size: 16px;
            color: #ffcc00;
            padding-right: 10px;
            text-align: right;
            font-weight: bold;
        }
        
        .forecast-row-data {
            display: flex;
            flex: 1;
            gap: 2px;
        }
        
        .forecast-cell {
            flex: 1;
            min-width: 40px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            border-radius: 3px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .forecast-cell:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .forecast-cell.selected {
            outline: 3px solid #fff;
            outline-offset: -2px;
        }
        
        /* C√©lulas de Hor√°rio */
        .forecast-cell.hour {
            background: #2a2a3a;
            color: #88ccff;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* C√©lulas de Vento com cores por intensidade */
        /* Escala: Verde < 20kn, Amarelo 25-35kn, Vermelho > 35kn */
        .forecast-cell.wind-calm { background: #006600; color: #fff; }     /* 0-10 kn: Verde escuro */
        .forecast-cell.wind-light { background: #00aa00; color: #fff; }    /* 10-15 kn: Verde m√©dio */
        .forecast-cell.wind-moderate { background: #00dd00; color: #000; } /* 15-20 kn: Verde claro */
        .forecast-cell.wind-fresh { background: #aadd00; color: #000; }    /* 20-25 kn: Verde-amarelo */
        .forecast-cell.wind-strong { background: #ffdd00; color: #000; }   /* 25-30 kn: Amarelo */
        .forecast-cell.wind-gale { background: #ff9900; color: #000; }     /* 30-35 kn: Laranja */
        .forecast-cell.wind-storm { background: #ff3300; color: #fff; }    /* 35-45 kn: Vermelho */
        .forecast-cell.wind-violent { background: #cc00cc; color: #fff; }  /* > 45 kn: Roxo */
        
        /* C√©lulas de Dire√ß√£o */
        .forecast-cell.direction {
            background: #1a2a4a;
            color: #88ccff;
            font-size: 26px;
        }
        
        /* Info do ponto selecionado */
        .forecast-selected-info {
            display: none;
            align-items: center;
            gap: 25px;
            margin-top: 8px;
            padding: 8px 15px;
            background: rgba(0,100,100,0.3);
            border-radius: 4px;
            font-size: 18px;
        }
        
        .forecast-selected-info.visible {
            display: flex;
        }
        
        .forecast-selected-info .item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .forecast-selected-info .item .val {
            color: #00ffcc;
            font-weight: bold;
            font-size: 22px;
        }
        
        .forecast-weights {
            margin-left: auto;
            display: flex;
            gap: 15px;
            font-size: 14px;
        }
        
        /* Bot√£o toggle info */
        .forecast-toggle-info {
            background: transparent;
            border: 2px solid #444;
            color: #888;
            padding: 6px 15px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 15px;
        }
        
        .forecast-toggle-info:hover {
            background: #333;
            color: #ccc;
        }
        
        .forecast-toggle-info.active {
            background: #00666688;
            border-color: #00ffcc;
            color: #00ffcc;
        }
        
        /* Ajustar layout para dar espa√ßo para o header GRANDE */
        .sidebar {
            margin-top: 210px;
            height: calc(100vh - 210px);
        }
        
        #map {
            margin-top: 210px;
            height: calc(100vh - 210px) !important;
        }
        
        /* Canvas Layer para gradiente L2 */
        .leaflet-canvas-layer {
            position: absolute;
            pointer-events: none;
            z-index: 250;
        }
        
        /* Info Icon com Tooltip */
        .input-with-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .input-with-info input {
            flex: 1;
            margin-bottom: 0;
        }
        
        .info-icon {
            width: 20px;
            height: 20px;
            background: #0088ff;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            position: relative;
            flex-shrink: 0;
        }
        
        .info-icon:hover {
            background: #00aaff;
        }
        
        .info-tooltip {
            display: none;
            position: absolute;
            left: 30px;
            top: -10px;
            background: #222;
            border: 1px solid #00aaff;
            border-radius: 6px;
            padding: 12px;
            width: 280px;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        .info-icon:hover .info-tooltip {
            display: block;
        }
        
        .info-tooltip h4 {
            color: #00ffcc;
            margin: 0 0 8px 0;
            font-size: 12px;
        }
        
        .info-tooltip p {
            color: #ccc;
            font-size: 11px;
            margin: 6px 0;
            line-height: 1.4;
        }
        
        .info-tooltip ol {
            color: #aaa;
            font-size: 11px;
            margin: 8px 0;
            padding-left: 16px;
            line-height: 1.6;
        }
        
        .info-tooltip a {
            color: #00aaff;
            text-decoration: underline;
        }
        
        .info-tooltip .highlight {
            background: #333;
            padding: 4px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #ffcc00;
        }
    </style>
</head>
<body>

<!-- ABA DE PREVIS√ÉO NO TOPO - FULL WIDTH -->
<div class="forecast-tabs-container" id="forecast-container">
    <!-- LINHA 1: T√≠tulo + Status -->
    <div class="forecast-row-1">
        <div class="forecast-title">üåä PREVIS√ÉO DE VENTO</div>
        <div class="forecast-status" id="forecast-status">‚è∞ 15min</div>
        <button class="forecast-toggle-info" id="forecast-toggle-btn" onclick="toggleForecastInfo()">‚ñº Detalhes</button>
    </div>
    
    <!-- TABELA DE FORECAST -->
    <div class="forecast-grid-container">
        <div class="forecast-grid" id="forecast-grid">
            <!-- Linha de Hor√°rios -->
            <div class="forecast-row">
                <div class="forecast-row-label">Hora</div>
                <div class="forecast-row-data" id="forecast-hours"></div>
            </div>
            <!-- Linha de Velocidade -->
            <div class="forecast-row">
                <div class="forecast-row-label">üí® Vento</div>
                <div class="forecast-row-data" id="forecast-winds"></div>
            </div>
            <!-- Linha de Rajada -->
            <div class="forecast-row">
                <div class="forecast-row-label">‚ö° Rajada</div>
                <div class="forecast-row-data" id="forecast-gusts"></div>
            </div>
            <!-- Linha de Dire√ß√£o -->
            <div class="forecast-row">
                <div class="forecast-row-label">üß≠ Dire√ß√£o</div>
                <div class="forecast-row-data" id="forecast-dirs"></div>
            </div>
        </div>
    </div>
    
    <!-- Info do Ponto Selecionado -->
    <div class="forecast-selected-info" id="forecast-selected-info">
        <div class="item">üìÖ <span class="val" id="forecast-datetime">--</span></div>
        <div class="item">üí® <span class="val" id="forecast-speed">--</span> kn</div>
        <div class="item">‚ö° <span class="val" id="forecast-gust">--</span> kn</div>
        <div class="item">üß≠ <span class="val" id="forecast-dir">--</span>¬∞</div>
    </div>
</div>

<div class="container">
    <!-- PAINEL LATERAL -->
    <div class="sidebar">
        
        <!-- SELETOR DE PER√çODO -->
        <div class="section" style="padding:8px;">
            <div style="display:flex; gap:5px;">
                <button class="forecast-period-btn active" onclick="selectForecastPeriod(24)" style="flex:1;">24h</button>
                <button class="forecast-period-btn" onclick="selectForecastPeriod(48)" style="flex:1;">48h</button>
                <button class="forecast-period-btn" onclick="selectForecastPeriod(72)" style="flex:1;">72h</button>
            </div>
        </div>
        
        <!-- CONTROLE DE ZOOM -->
        <div class="section" style="padding:8px;">
            <div style="display:flex; align-items:center; gap:8px;">
                <span style="font-size:11px; color:#888;">üîç Zoom:</span>
                <button onclick="changeZoom(-1)" style="width:28px; height:28px; font-size:16px; padding:0;">‚àí</button>
                <input type="number" id="zoom-input" value="7" min="3" max="18" 
                       style="width:50px; height:28px; text-align:center; font-size:14px; font-weight:bold; background:#222; color:#fff; border:1px solid #444; border-radius:4px;"
                       onchange="setZoom(this.value)">
                <button onclick="changeZoom(1)" style="width:28px; height:28px; font-size:16px; padding:0;">+</button>
            </div>
        </div>
        
        <!-- POSI√á√ÉO DO NAVIO -->
        <div class="section">
            <div class="section-title">
                <span class="status-indicator active"></span>
                POSI√á√ÉO: Deepwater Aquila
            </div>
            <div class="wind-stats">
                <div class="stat-box">
                    <div class="stat-value">-22.5¬∞</div>
                    <div class="stat-label">LATITUDE</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">-40.5¬∞</div>
                    <div class="stat-label">LONGITUDE</div>
                </div>
            </div>
        </div>
        
        <!-- ESTAT√çSTICAS DE VENTO (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üìä DADOS DE VENTO</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section">
                <!-- M√©dia Multi-Modelo -->
                <div style="background:#1a2a1a; border:1px solid #00aa00; border-radius:4px; padding:10px; margin-bottom:10px;">
                    <div style="font-size:10px; color:#00ff00; margin-bottom:5px;">üåç VENTO ATUAL</div>
                    <div style="display:flex; gap:10px; align-items:center;">
                        <div style="text-align:center;">
                            <div style="font-size:24px; font-weight:bold; color:#00ffcc;" id="avg-model-speed">--</div>
                            <div style="font-size:9px; color:#888;">Velocidade (kn)</div>
                        </div>
                        <div style="text-align:center;">
                            <div style="font-size:24px; font-weight:bold; color:#00ffcc;" id="avg-model-dir">--</div>
                            <div style="font-size:9px; color:#888;">Dire√ß√£o (¬∞)</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- FONTES DE DADOS (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üì° FONTES DE DADOS</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #666;">
                <div class="section-title">
                    <span class="status-indicator" id="openmeteo-status"></span>
                    OPEN-METEO (Modelo)
                </div>
                <p class="source-info">‚úÖ GRATUITO - Atualiza 15 min</p>
                <button onclick="fetchOpenMeteoData()">üîÑ Atualizar</button>
                <button class="secondary" onclick="clearOpenMeteoData()">üóëÔ∏è Limpar</button>
            </div>
        </div>
        
        <!-- CALIBRA√á√ÉO DE MODELOS (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>‚öñÔ∏è CALIBRA√á√ÉO</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #ffcc00;">
                <div class="section-title">
                    <span class="status-indicator active"></span>
                    Pesos Din√¢micos (Cumulativo)
                </div>
                
                <!-- Info de vetores DMW/SCAT no raio de 20nm -->
                <div id="observed-vectors-info" style="font-size:9px; color:#888; margin-bottom:6px; background:#0a0a0a; padding:6px; border-radius:4px;">
                    <div>üìç Vetores no raio 20nm:</div>
                    <div style="margin-top:3px;">
                        üå¨Ô∏è DMW: <b id="dmw-vectors-count">0</b> (<span id="dmw-weight-pct">0%</span>) | 
                        üõ∞Ô∏è SCAT: <b id="scat-vectors-count">0</b> (<span id="scat-weight-pct">0%</span>)
                    </div>
                </div>
                
                <!-- Resumo da calibra√ß√£o -->
                <div id="weight-reason" style="font-size:9px; color:#888; margin-bottom:8px; background:#0a0a0a; padding:6px; border-radius:4px;">
                    ‚è≥ Aguardando calibra√ß√£o...
                </div>
                
                <!-- Tabela de estat√≠sticas por modelo -->
                <div style="background:#111; border:1px solid #333; border-radius:4px; overflow:hidden; margin-bottom:8px;">
                    <table style="width:100%; font-size:8px; border-collapse:collapse;">
                        <thead>
                            <tr style="background:#222;">
                                <th style="padding:3px; text-align:left; color:#888;">Mod</th>
                                <th colspan="3" style="padding:3px; text-align:center; color:#88ccff; border-left:1px solid #444;">Velocidade</th>
                                <th colspan="3" style="padding:3px; text-align:center; color:#ffcc88; border-left:1px solid #444;">Dire√ß√£o</th>
                            </tr>
                            <tr style="background:#1a1a1a;">
                                <th style="padding:2px;"></th>
                                <th style="padding:2px; text-align:center; color:#888; font-size:7px; border-left:1px solid #444;">‚úì/‚úó</th>
                                <th style="padding:2px; text-align:center; color:#88ccff; font-size:7px;">Sc</th>
                                <th style="padding:2px; text-align:center; color:#00ffcc; font-size:7px;">%</th>
                                <th style="padding:2px; text-align:center; color:#888; font-size:7px; border-left:1px solid #444;">‚úì/‚úó</th>
                                <th style="padding:2px; text-align:center; color:#ffcc88; font-size:7px;">Sc</th>
                                <th style="padding:2px; text-align:center; color:#00ffcc; font-size:7px;">%</th>
                            </tr>
                        </thead>
                        <tbody id="calibration-table">
                            <tr><td style="padding:2px; color:#aaa;">GFS</td><td id="calib-spd-count-gfs_seamless" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-spd-score-gfs_seamless" style="text-align:center; color:#88ccff;">100</td><td id="calib-spd-weight-gfs_seamless" style="text-align:center; color:#00ffcc;">20</td><td id="calib-dir-count-gfs_seamless" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-dir-score-gfs_seamless" style="text-align:center; color:#ffcc88;">100</td><td id="calib-dir-weight-gfs_seamless" style="text-align:center; color:#00ffcc;">20</td></tr>
                            <tr><td style="padding:2px; color:#aaa;">ECMWF</td><td id="calib-spd-count-ecmwf_ifs025" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-spd-score-ecmwf_ifs025" style="text-align:center; color:#88ccff;">100</td><td id="calib-spd-weight-ecmwf_ifs025" style="text-align:center; color:#00ffcc;">20</td><td id="calib-dir-count-ecmwf_ifs025" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-dir-score-ecmwf_ifs025" style="text-align:center; color:#ffcc88;">100</td><td id="calib-dir-weight-ecmwf_ifs025" style="text-align:center; color:#00ffcc;">20</td></tr>
                            <tr><td style="padding:2px; color:#aaa;">ICON</td><td id="calib-spd-count-icon_seamless" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-spd-score-icon_seamless" style="text-align:center; color:#88ccff;">100</td><td id="calib-spd-weight-icon_seamless" style="text-align:center; color:#00ffcc;">20</td><td id="calib-dir-count-icon_seamless" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-dir-score-icon_seamless" style="text-align:center; color:#ffcc88;">100</td><td id="calib-dir-weight-icon_seamless" style="text-align:center; color:#00ffcc;">20</td></tr>
                            <tr><td style="padding:2px; color:#aaa;">MFR</td><td id="calib-spd-count-meteofrance_seamless" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-spd-score-meteofrance_seamless" style="text-align:center; color:#88ccff;">100</td><td id="calib-spd-weight-meteofrance_seamless" style="text-align:center; color:#00ffcc;">20</td><td id="calib-dir-count-meteofrance_seamless" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-dir-score-meteofrance_seamless" style="text-align:center; color:#ffcc88;">100</td><td id="calib-dir-weight-meteofrance_seamless" style="text-align:center; color:#00ffcc;">20</td></tr>
                            <tr><td style="padding:2px; color:#aaa;">JMA</td><td id="calib-spd-count-jma_seamless" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-spd-score-jma_seamless" style="text-align:center; color:#88ccff;">100</td><td id="calib-spd-weight-jma_seamless" style="text-align:center; color:#00ffcc;">20</td><td id="calib-dir-count-jma_seamless" style="text-align:center; color:#888; border-left:1px solid #333;">0/0</td><td id="calib-dir-score-jma_seamless" style="text-align:center; color:#ffcc88;">100</td><td id="calib-dir-weight-jma_seamless" style="text-align:center; color:#00ffcc;">20</td></tr>
                        </tbody>
                    </table>
                </div>
                
                <div style="font-size:8px; color:#666; margin-bottom:8px;">
                    Vel: acerto &lt;3kt | Dir: acerto &lt;20¬∞
                </div>
                
                <button class="secondary" onclick="testCalibration()" style="width:100%; font-size:10px; margin-bottom:5px; background:#ff9900; color:#000;">
                    üß™ TEST CALIBRATION
                </button>
                
                <button class="secondary" onclick="testRandomWeights()" style="width:100%; font-size:10px; margin-bottom:5px; background:#ff00ff; color:#000;">
                    üé≤ TESTAR PESOS ALEAT√ìRIOS
                </button>
                
                <button class="secondary" onclick="resetCalibration()" style="width:100%; font-size:10px;">
                    üîÑ Resetar Calibra√ß√£o
                </button>
            </div>
        </div>
        
        <!-- Sat√©lite (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üõ∞Ô∏è SAT√âLITE</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #00ff00;">
                <div class="section-title">
                    <span class="status-indicator" id="satellite-status"></span>
                    <span id="satellite-name">GOES-19</span>
                </div>
                
                <div style="display:flex; gap:5px; margin-bottom:8px;">
                    <button id="btn-goes19" class="toggle-btn active" onclick="selectSatellite('goes19')" style="flex:1;">GOES-19</button>
                    <button id="btn-goes16" class="toggle-btn" onclick="selectSatellite('goes16')" style="flex:1;">GOES-16</button>
                </div>
                
                <select id="satellite-product" style="width:100%; margin-bottom:6px; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:3px; font-size:11px;">
                    <option value="GEOCOLOR" selected>üåç GeoColor</option>
                    <option value="13">üå°Ô∏è IR (Band 13)</option>
                    <option value="08">üíß Vapor d'√Ågua</option>
                    <option value="AirMass">üåÄ Air Mass</option>
                </select>
                
                <select id="satellite-quality" style="width:100%; margin-bottom:6px; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:3px; font-size:11px;">
                    <option value="low">R√°pida</option>
                    <option value="medium" selected>M√©dia</option>
                    <option value="high">Alta</option>
                </select>
                
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                    <span style="font-size:10px;">Opacidade:</span>
                    <input type="range" id="satellite-opacity" min="0" max="100" value="75" style="flex:1;" oninput="updateSatelliteOpacity(this.value)">
                    <span id="opacity-value" style="font-size:10px;">75%</span>
                </div>
                
                <div style="display:flex; gap:5px; margin-bottom:6px;">
                    <button id="btn-autoextract-on" class="toggle-btn active" onclick="toggleAutoExtract(true)" style="flex:1; font-size:10px;">Auto ‚úÖ</button>
                    <button id="btn-autoextract-off" class="toggle-btn" onclick="toggleAutoExtract(false)" style="flex:1; font-size:10px;">Auto ‚ùå</button>
                </div>
                
                <div style="display:flex; gap:5px;">
                    <button onclick="loadSatelliteWithReprojection()" style="flex:1;">üåç CARREGAR</button>
                    <button class="secondary" onclick="toggleSatelliteLayer()">üëÅÔ∏è</button>
                </div>
                
                <div id="satellite-progress" style="display:none; margin-top:8px;">
                    <div style="background:#333; border-radius:3px; height:4px; overflow:hidden;">
                        <div id="satellite-progress-bar" style="width:0%; height:100%; background:#00d4ff;"></div>
                    </div>
                    <div id="satellite-progress-text" style="font-size:9px; color:#888; margin-top:2px;">0%</div>
                </div>
                <div id="satellite-info" style="margin-top:6px; font-size:9px; color:#888;"></div>
            </div>
        </div>
        
        <!-- VENTOS DMW (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üå¨Ô∏è VENTOS DMW</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #ff9900;">
                <div class="section-title">
                    <span class="status-indicator" id="dmw-status"></span>
                    Derived Motion Winds
                </div>
                
                <div style="display:flex; gap:5px; margin-bottom:8px;">
                    <button id="btn-dmw-on" class="toggle-btn" onclick="toggleDMW(true)" style="flex:1;">‚úÖ ON</button>
                    <button id="btn-dmw-off" class="toggle-btn active" onclick="toggleDMW(false)" style="flex:1;">‚ùå OFF</button>
                </div>
                
                <select id="dmw-level" style="width:100%; margin-bottom:6px; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:3px; font-size:11px;" onchange="loadDMWWinds()">
                    <option value="low" selected>Baixo (&lt;3km)</option>
                    <option value="mid">M√©dio (3-7km)</option>
                    <option value="high">Alto (&gt;7km)</option>
                    <option value="all">Todos</option>
                </select>
                
                <button onclick="loadDMWWinds()" style="width:100%; margin-bottom:6px;">üîÑ ATUALIZAR</button>
                
                <div id="dmw-info" style="font-size:9px; color:#888;">üìÖ Aguardando...</div>
                <div id="dmw-next-update" style="font-size:9px; color:#ff9900; display:none;">‚è∞ --:05</div>
            </div>
        </div>
        
        <!-- VENTOS SCATTEROMETER (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üõ∞Ô∏è VENTOS SCAT</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #00aaff;">
                <div class="section-title">
                    <span class="status-indicator" id="scat-status"></span>
                    Scatterometer (ASCAT)
                </div>
                
                <div style="display:flex; gap:5px; margin-bottom:8px;">
                    <button id="btn-scat-on" class="toggle-btn" onclick="toggleSCAT(true)" style="flex:1;">‚úÖ ON</button>
                    <button id="btn-scat-off" class="toggle-btn active" onclick="toggleSCAT(false)" style="flex:1;">‚ùå OFF</button>
                </div>
                
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                    <label style="font-size:10px; color:#888;">Auto-check (1h):</label>
                    <input type="checkbox" id="scat-auto-refresh" onclick="toggleScatAutoRefresh()">
                    <span id="scat-next-update" style="font-size:9px; color:#00aaff;"></span>
                </div>
                
                <button onclick="loadScatWinds()" style="width:100%; margin-bottom:6px;">üîÑ ATUALIZAR</button>
                
                <div id="scat-info" style="font-size:9px; color:#888;">üìÖ Aguardando...</div>
                <div id="scat-timestamp" style="font-size:9px; color:#00aaff;"></div>
            </div>
        </div>
        
        <!-- PRODUTOS L2 (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üìä PRODUTOS L2</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #00d4ff;">
                <div class="section-title">
                    <span class="status-indicator" id="l2-status"></span>
                    CAPE, LI, TPW, Nuvens
                </div>
                
                <div style="display:flex; gap:5px; margin-bottom:8px;">
                    <button id="btn-l2-on" class="toggle-btn" onclick="toggleL2(true)" style="flex:1;">‚úÖ ON</button>
                    <button id="btn-l2-off" class="toggle-btn active" onclick="toggleL2(false)" style="flex:1;">‚ùå OFF</button>
                </div>
                
                <!-- Modo de visualiza√ß√£o: √Årea ou Marcadores -->
                <div style="display:flex; gap:5px; margin-bottom:8px;">
                    <button id="btn-l2-area" class="toggle-btn active" onclick="toggleL2DisplayMode('area')" style="flex:1; font-size:10px;">üé® √Årea</button>
                    <button id="btn-l2-markers" class="toggle-btn" onclick="toggleL2DisplayMode('markers')" style="flex:1; font-size:10px;">‚≠ï Pontos</button>
                </div>
                
                <select id="l2-variable" style="width:100%; margin-bottom:6px; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:3px; font-size:11px;" onchange="updateL2Display(); createL2Legend(this.value);">
                    <option value="CAPE" selected>‚ö° CAPE</option>
                    <option value="LI">üå°Ô∏è LI</option>
                    <option value="TPW">üíß TPW</option>
                    <option value="HT">‚òÅÔ∏è Altura</option>
                    <option value="Phase">üßä Fase</option>
                </select>
                
                <!-- Controle de Opacidade -->
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                    <label style="font-size:10px; color:#888; width:60px;">Opacidade:</label>
                    <input type="range" id="l2-opacity" min="10" max="100" value="70" 
                           style="flex:1; height:4px; cursor:pointer;"
                           oninput="updateL2Opacity(this.value)">
                    <span id="l2-opacity-value" style="font-size:10px; color:#00d4ff; width:35px;">70%</span>
                </div>
                
                <button onclick="loadL2Data()" style="width:100%; margin-bottom:6px;">üîÑ CARREGAR</button>
                
                <div id="l2-info" style="font-size:9px; color:#888;">üìÖ Aguardando...</div>
                
                <div id="l2-ship-data" style="display:none; background:#0a1a2a; padding:8px; border-radius:4px; margin-top:6px;">
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:3px; font-size:9px;">
                        <div>‚ö° <span id="l2-ship-cape" style="color:#ffcc00;">--</span></div>
                        <div>üå°Ô∏è <span id="l2-ship-li" style="color:#00ff88;">--</span></div>
                        <div>üíß <span id="l2-ship-tpw" style="color:#00ccff;">--</span></div>
                        <div>‚òÅÔ∏è <span id="l2-ship-ht" style="color:#ff88ff;">--</span></div>
                    </div>
                </div>
            </div>
        </div>
        <div id="l2-legend-cape" style="display:none;"></div>
        
        <!-- LOG (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üìã LOG</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="log-area" id="log-area" style="height:100px;">
                <div class="log-entry info">Sistema iniciado...</div>
            </div>
            <!-- A√ß√µes -->
            <div style="margin-top: 10px; display:flex; gap:5px;">
                <button onclick="fetchAllSources()" style="flex:1;">üîÑ ATUALIZAR</button>
                <button class="secondary" onclick="clearData()">üóëÔ∏è</button>
            </div>
        </div>
        
    </div>
    
    <!-- MAPA -->
    <div id="map"></div>
    
    <!-- Scatterometer Legend (posicionado no mapa) -->
    <div id="scatLegend" style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0,0,0,0.9);
        padding: 12px;
        border-radius: 8px;
        z-index: 1000;
        border: 1px solid #00aaff;
        display: none;
        font-size: 11px;
        color: #e0e0e0;
    ">
        <h4 style="color: #00aaff; margin: 0 0 8px 0; font-size: 12px;">üõ∞Ô∏è Ventos Scatterometer</h4>
        <div style="font-size: 10px; color: #aaa; margin-bottom: 6px;">ASCAT (MetOp-B/C)</div>
        <div style="display:flex; align-items:center; gap:6px; padding:2px 0;"><div style="width:25px;height:4px;background:#00ff00;border-radius:2px;"></div><span>0-10 kt (Calmo)</span></div>
        <div style="display:flex; align-items:center; gap:6px; padding:2px 0;"><div style="width:25px;height:4px;background:#88ff00;border-radius:2px;"></div><span>10-15 kt (Leve)</span></div>
        <div style="display:flex; align-items:center; gap:6px; padding:2px 0;"><div style="width:25px;height:4px;background:#ffff00;border-radius:2px;"></div><span>15-20 kt (Moderado)</span></div>
        <div style="display:flex; align-items:center; gap:6px; padding:2px 0;"><div style="width:25px;height:4px;background:#ff9900;border-radius:2px;"></div><span>20-25 kt (Fresco)</span></div>
        <div style="display:flex; align-items:center; gap:6px; padding:2px 0;"><div style="width:25px;height:4px;background:#ff0000;border-radius:2px;"></div><span>25-30 kt (Forte)</span></div>
        <div style="display:flex; align-items:center; gap:6px; padding:2px 0;"><div style="width:25px;height:4px;background:#ff00ff;border-radius:2px;"></div><span>&gt;30 kt (Muito Forte)</span></div>
        <div style="margin-top:8px; padding-top:6px; border-top:1px solid #333;">
            <span id="scatInfoLegend" style="color:#888;">-</span>
        </div>
        <div style="margin-top:4px; color:#00aaff;">üìÖ <span id="scatTimestampLegend">--</span></div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
    // =========================================================================
    // CONFIGURA√á√ÉO
    // =========================================================================
    // Raio para visualiza√ß√£o do mapa (c√≠rculo visual)
    const RAIO_VISUAL_NM = 100;  // Raio do c√≠rculo visual no mapa
    const RAIO_VISUAL_GRAUS = RAIO_VISUAL_NM / 60;
    
    // Raio para busca de dados Open-Meteo (igual ao visual para cobrir todo c√≠rculo)
    const RAIO_NM = 100;  // Raio em milhas n√°uticas para busca de dados
    const RAIO_GRAUS = RAIO_NM / 60;  // 1 grau = 60 NM
    
    // Raio para observa√ß√£o de vetores DMW/SCAT (calibra√ß√£o)
    const RAIO_OBSERVACAO_NM = 20;  // Raio em milhas n√°uticas para calibra√ß√£o
    const RAIO_OBSERVACAO_GRAUS = RAIO_OBSERVACAO_NM / 60;  // ~0.33 graus
    
    // IMPORTANTE: Idade m√°xima dos dados em MINUTOS
    // Dados com mais de 60 min ser√£o descartados
    const MAX_DATA_AGE_MINUTES = 60;
    
    const CONFIG = {
        shipLat: -22.5,
        shipLon: -40.5,
        latMin: -22.5 - RAIO_GRAUS,
        latMax: -22.5 + RAIO_GRAUS,
        lonMin: -40.5 - RAIO_GRAUS,
        lonMax: -40.5 + RAIO_GRAUS,
        shipName: "Deepwater Aquila"
    };
    
    // Bounds da imagem de sat√©lite reprojetada (√°rea de interesse)
    // IMPORTANTE: Definir aqui para ser usada por loadDMWWinds antes de ser redefinida abaixo
    const REPROJECTION_BOUNDS = {
        north: 0,
        south: -30,
        west: -60,
        east: -30
    };
    
    // Pol√≠gono simplificado da costa brasileira para filtrar pontos em terra
    // Pontos com longitude menor (mais a oeste) que a costa s√£o considerados em terra
    // Formato: [lat, lon_costa] - se lon do ponto < lon_costa, est√° em terra
    const COSTA_BRASIL = [
        [-30.0, -51.0],   // RS - extremo sul
        [-29.0, -49.5],   // SC
        [-28.0, -48.5],   // SC
        [-27.0, -48.5],   // SC - Florian√≥polis
        [-26.0, -48.5],   // SC - Joinville
        [-25.5, -48.5],   // PR - Paranagu√°
        [-25.0, -47.5],   // PR/SP
        [-24.5, -46.5],   // SP - Santos
        [-24.0, -46.0],   // SP
        [-23.5, -45.0],   // SP - Ubatuba
        [-23.0, -44.0],   // RJ - Angra
        [-22.5, -43.0],   // RJ - Rio
        [-22.0, -41.0],   // RJ - Cabo Frio
        [-21.5, -40.5],   // RJ/ES
        [-21.0, -40.0],   // ES - Vit√≥ria
        [-20.0, -40.0],   // ES
        [-19.0, -39.5],   // ES/BA
        [-18.0, -39.0],   // BA - Porto Seguro
        [-17.0, -39.0],   // BA
        [-16.0, -38.5],   // BA
        [-15.0, -38.5],   // BA - Salvador
        [-14.0, -38.5],   // BA
        [-13.0, -38.5],   // BA
        [-12.0, -38.0],   // BA
        [-11.0, -37.0],   // SE/AL
        [-10.0, -36.0],   // AL
        [-9.0, -35.0],    // PE
        [-8.0, -34.5],    // PE - Recife
        [-7.0, -34.5],    // PB - Jo√£o Pessoa
        [-6.0, -35.0],    // RN - Natal
        [-5.0, -35.5],    // RN
        [-4.0, -37.5],    // CE
        [-3.0, -38.5],    // CE - Fortaleza
        [-2.0, -42.0],    // PI/MA
        [-1.0, -44.0],    // MA
        [0.0, -48.0],     // PA - Bel√©m
    ];
    
    // Fun√ß√£o para verificar se ponto est√° no oceano (n√£o em terra)
    function isOverOcean(lat, lon) {
        // Se est√° muito a leste, certamente √© oceano
        if (lon > -30) return true;
        
        // Encontrar a latitude mais pr√≥xima na tabela da costa
        let coastLon = -60; // Default: muito a oeste = terra
        
        for (let i = 0; i < COSTA_BRASIL.length - 1; i++) {
            const [lat1, lon1] = COSTA_BRASIL[i];
            const [lat2, lon2] = COSTA_BRASIL[i + 1];
            
            // Se a latitude est√° entre dois pontos da costa
            if (lat >= lat1 && lat < lat2) {
                // Interpolar a longitude da costa
                const t = (lat - lat1) / (lat2 - lat1);
                coastLon = lon1 + t * (lon2 - lon1);
                break;
            } else if (lat < COSTA_BRASIL[0][0]) {
                // Abaixo do ponto mais ao sul
                coastLon = COSTA_BRASIL[0][1];
                break;
            } else if (lat >= COSTA_BRASIL[COSTA_BRASIL.length - 1][0]) {
                // Acima do ponto mais ao norte
                coastLon = COSTA_BRASIL[COSTA_BRASIL.length - 1][1];
                break;
            }
        }
        
        // Adicionar margem de 0.5 graus para evitar pontos muito pr√≥ximos √† costa
        return lon > coastLon + 0.5;
    }
    
    let map;
    let windDataPoints = [];  // Armazena todos os dados de vento
    let windLayerGroup;
    let gridLayer;
    
    // =========================================================================
    // INICIALIZA√á√ÉO DO MAPA
    // =========================================================================
    function initMap() {
        map = L.map('map', {
            center: [CONFIG.shipLat, CONFIG.shipLon],
            zoom: 7,
            zoomControl: false
        });

        L.control.zoom({ position: 'topright' }).addTo(map);
        L.control.scale({ position: 'bottomright', imperial: false }).addTo(map);

        // Mapa Base Escuro
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19
        }).addTo(map);
        
        // Atualizar input de zoom quando mapa mudar
        map.on('zoomend', function() {
            const zoomInput = document.getElementById('zoom-input');
            if (zoomInput) zoomInput.value = map.getZoom();
        });
        
        // Grupos de camadas
        windLayerGroup = L.layerGroup().addTo(map);
        gridLayer = L.layerGroup();
        
        log('info', 'üìç Adicionando √≠cone do navio...');

        // √çcone do Navio
        const shipIcon = L.divIcon({
            className: 'ship-icon',
            html: `<svg viewBox="0 0 24 24" width="50" height="50">
                <circle cx="12" cy="12" r="10" fill="rgba(0,255,204,0.3)" stroke="#00ffcc" stroke-width="2"/>
                <circle cx="12" cy="12" r="4" fill="#00ffcc"/>
            </svg>`,
            iconSize: [50, 50],
            iconAnchor: [25, 25]
        });
        L.marker([CONFIG.shipLat, CONFIG.shipLon], { icon: shipIcon })
            .bindPopup(`<b>${CONFIG.shipName}</b><br>Lat: ${CONFIG.shipLat}<br>Lon: ${CONFIG.shipLon}`)
            .addTo(map);
        
        // √Årea de interesse (C√çRCULO VISUAL - 100 NM)
        L.circle([CONFIG.shipLat, CONFIG.shipLon], {
            radius: RAIO_VISUAL_NM * 1852,  // Converter NM para metros
            color: "#00ffcc",
            weight: 1,
            fillOpacity: 0.05,
            dashArray: '5, 5'
        }).addTo(map);
        
        log('info', 'üó∫Ô∏è Mapa base carregado');
        
        // Criar grade
        createGrid();
        
        // Carregar credenciais salvas
        loadSavedCredentials();
        
        // Configurar auto-reload de Scatterometer
        setupScatAutoReload();
        
        log('success', '‚úÖ Mapa inicializado');
        log('info', `üìè √Årea visual: ${RAIO_VISUAL_NM} NM | Grid dados: ${RAIO_NM} NM`);
        
        // Carregar sat√©lite primeiro (500ms)
        log('info', 'üõ∞Ô∏è Iniciando carregamento de sat√©lite...');
        setTimeout(() => loadSatelliteLayer(), 500);
        
        // Carregar dados SCAT em background (1 segundo) - n√£o exibe vetores, s√≥ carrega dados
        log('info', 'üõ∞Ô∏è Iniciando carregamento de SCAT em background...');
        setTimeout(() => loadScatDataSilently(), 1000);
        
        // Buscar dados Open-Meteo (1.5 segundos)
        log('info', 'üå¨Ô∏è Iniciando busca de dados de vento...');
        setTimeout(() => fetchOpenMeteoData(), 1500);
        
        // Atualiza√ß√£o autom√°tica do Open-Meteo a cada 15 minutos
        setInterval(() => {
            log('info', '‚è∞ Atualiza√ß√£o autom√°tica (15 min)...');
            fetchOpenMeteoData();
        }, 15 * 60 * 1000);  // 15 minutos
        
        // Verifica√ß√£o autom√°tica de nova imagem de sat√©lite a cada 5 minutos
        setInterval(async () => {
            if (!isLoadingSatellite && satelliteEnabled && autoExtractEnabled) {
                const needsUpdate = await shouldLoadSatellite(false);
                if (needsUpdate) {
                    log('info', 'üõ∞Ô∏è Detectada nova imagem de sat√©lite, atualizando...');
                    loadSatelliteWithReprojection(true);
                }
            }
        }, 5 * 60 * 1000);  // 5 minutos
        
        // Verifica√ß√£o autom√°tica de novos dados SCAT a cada 30 minutos
        setInterval(async () => {
            log('info', 'üõ∞Ô∏è Verificando novos dados SCAT...');
            await loadScatDataSilently();
        }, 30 * 60 * 1000);  // 30 minutos
    }
    
    // ============ TOGGLE FORECAST INFO ============
    function toggleForecastInfo() {
        const info = document.getElementById('forecast-selected-info');
        const btn = document.getElementById('forecast-toggle-btn');
        
        if (info.classList.contains('visible')) {
            info.classList.remove('visible');
            btn.classList.remove('active');
            btn.textContent = '‚ñº Detalhes';
        } else {
            info.classList.add('visible');
            btn.classList.add('active');
            btn.textContent = '‚ñ≤ Ocultar';
        }
    }
    
    // =========================================================================
    // CAMADA DE SAT√âLITE (Imagem pr√©-processada)
    // =========================================================================
    let satelliteEnabled = true;
    let satelliteLayer = null;
    let satelliteRefreshInterval = null;
    let satelliteData = null;
    let currentSatellite = 'goes19';  // Sat√©lite padr√£o
    let currentSatelliteTimestamp = null;  // Timestamp da imagem carregada
    let isLoadingSatellite = false;  // Flag para evitar carregamentos simult√¢neos
    let pendingSatelliteLayer = null;  // Camada sendo carregada em background
    let autoExtractEnabled = true;  // Auto-extra√ß√£o ligada por padr√£o
    
    // =========================================================================
    // CAMADA DMW (Derived Motion Winds)
    // =========================================================================
    let dmwEnabled = false;
    let dmwLayer = null;
    let dmwData = null;
    let dmwMarkers = [];
    let dmwAutoRefreshInterval = null;
    let lastDMWHour = -1;  // Para controlar atualiza√ß√£o por hora
    
    // =========================================================================
    // CAMADA SCATTEROMETER (ASCAT, CYGNSS)
    // =========================================================================
    let scatEnabled = false;
    let scatLayer = null;
    let scatMarkers = [];
    let scatData = null;
    let scatAutoRefreshInterval = null;
    let scatLastTimestamp = null;  // Timestamp dos dados atuais
    let scatOpacityInterval = null;  // Intervalo para atualizar opacidade
    const SCAT_MAX_AGE_HOURS = 6;  // Dados expiram ap√≥s 6 horas
    
    // ============ FUN√á√ïES DE ZOOM ============
    function setZoom(level) {
        const zoom = parseInt(level);
        if (zoom >= 3 && zoom <= 18 && map) {
            map.setZoom(zoom);
        }
    }
    
    function changeZoom(delta) {
        if (map) {
            const newZoom = map.getZoom() + delta;
            if (newZoom >= 3 && newZoom <= 18) {
                map.setZoom(newZoom);
            }
        }
    }
    
    // ============ FUN√á√ÉO TOGGLE COLLAPSIBLE ============
    function toggleCollapsible(header) {
        header.classList.toggle('collapsed');
        const content = header.nextElementSibling;
        if (content && content.classList.contains('collapsible-content')) {
            content.classList.toggle('collapsed');
        }
    }
    
    function toggleDMW(enabled) {
        dmwEnabled = enabled;
        
        // Atualizar bot√µes
        document.getElementById('btn-dmw-on').classList.toggle('active', enabled);
        document.getElementById('btn-dmw-off').classList.toggle('active', !enabled);
        
        // Atualizar status
        const statusEl = document.getElementById('dmw-status');
        
        if (enabled) {
            log('success', '‚úÖ DMW LIGADO - Carregando ventos...');
            statusEl.className = 'status-indicator loading';
            loadDMWWinds();
            
            // Iniciar verifica√ß√£o autom√°tica a cada minuto
            startDMWAutoRefresh();
        } else {
            log('info', '‚ùå DMW DESLIGADO');
            statusEl.className = 'status-indicator';
            clearDMWLayer();
            
            // Parar verifica√ß√£o autom√°tica
            stopDMWAutoRefresh();
        }
    }
    
    function startDMWAutoRefresh() {
        // Verificar a cada minuto se est√° no minuto 5
        if (dmwAutoRefreshInterval) {
            clearInterval(dmwAutoRefreshInterval);
        }
        
        // Mostrar pr√≥xima atualiza√ß√£o
        updateNextDMWTime();
        document.getElementById('dmw-next-update').style.display = 'block';
        
        dmwAutoRefreshInterval = setInterval(() => {
            if (!dmwEnabled) return;
            
            const now = new Date();
            const minute = now.getMinutes();
            const hour = now.getHours();
            
            // Atualizar info de pr√≥xima atualiza√ß√£o
            updateNextDMWTime();
            
            // Atualizar no minuto 5 de cada hora (12:05, 13:05, etc)
            // E apenas se ainda n√£o atualizou nessa hora
            if (minute === 5 && hour !== lastDMWHour) {
                lastDMWHour = hour;
                log('info', `üîÑ DMW: Atualiza√ß√£o autom√°tica (${hour}:05)`);
                loadDMWWinds();
                // Calibrar modelos APENAS quando h√° dados realmente novos
                setTimeout(() => calibrateWithObservedData(), 500);
            }
        }, 60 * 1000);  // Verificar a cada 1 minuto
        
        log('info', '‚è∞ DMW: Auto-refresh ativado (atualiza em XX:05)');
    }
    
    function updateNextDMWTime() {
        const now = new Date();
        let nextHour = now.getHours();
        
        // Se j√° passou do minuto 5, pr√≥xima √© na pr√≥xima hora
        if (now.getMinutes() >= 5) {
            nextHour = (nextHour + 1) % 24;
        }
        
        const nextUpdateEl = document.getElementById('dmw-next-update');
        if (nextUpdateEl) {
            nextUpdateEl.textContent = `‚è∞ Pr√≥xima atualiza√ß√£o: ${String(nextHour).padStart(2, '0')}:05`;
        }
    }
    
    function stopDMWAutoRefresh() {
        if (dmwAutoRefreshInterval) {
            clearInterval(dmwAutoRefreshInterval);
            dmwAutoRefreshInterval = null;
        }
        lastDMWHour = -1;
        document.getElementById('dmw-next-update').style.display = 'none';
    }
    
    function clearDMWLayer() {
        if (dmwLayer) {
            dmwLayer.clearLayers();
            map.removeLayer(dmwLayer);
            dmwLayer = null;
        }
        dmwMarkers = [];
    }
    
    async function loadDMWWinds() {
        if (!dmwEnabled) return;
        
        const level = document.getElementById('dmw-level').value;
        const statusEl = document.getElementById('dmw-status');
        const infoEl = document.getElementById('dmw-info');
        
        statusEl.className = 'status-indicator loading';
        log('info', 'üå¨Ô∏è Carregando dados DMW do GOES...');
        
        try {
            // N√≠veis de press√£o para filtrar
            const levelConfig = {
                'low': { min: 700, max: 1100, name: 'Baixo N√≠vel (<3km)' },
                'mid': { min: 400, max: 700, name: 'N√≠vel M√©dio (3-7km)' },
                'high': { min: 100, max: 400, name: 'Alto N√≠vel (>7km)' },
                'all': { min: 100, max: 1100, name: 'Todos os N√≠veis' }
            };
            
            const levelInfo = levelConfig[level] || levelConfig['low'];
            
            // Usar os mesmos bounds da imagem de sat√©lite reprojetada
            // para garantir que os vetores fiquem dentro da √°rea vis√≠vel
            const latMin = REPROJECTION_BOUNDS.south;  // -30
            const latMax = REPROJECTION_BOUNDS.north;  // 0
            const lonMin = REPROJECTION_BOUNDS.west;   // -60
            const lonMax = REPROJECTION_BOUNDS.east;   // -30
            
            // Carregar dados DMW do arquivo JSON (gerado pelo dmw_extractor.py)
            console.log('[DMW] Carregando dmw_latest.json...');
            log('info', 'üå¨Ô∏è DMW: Carregando dados...');
            
            const response = await fetch('dmw_latest.json?' + Date.now());
            if (!response.ok) {
                throw new Error(`Dados DMW n√£o encontrados (${response.status})`);
            }
            dmwData = await response.json();
            console.log(`[DMW] Dados carregados: ${dmwData.count || (dmwData.winds ? dmwData.winds.length : 0)} ventos`);
            
            log('success', `‚úÖ DMW carregado: ${dmwData.count || (dmwData.winds ? dmwData.winds.length : 0)} vetores totais`);
            
            // Limpar camada anterior
            clearDMWLayer();
            dmwLayer = L.layerGroup().addTo(map);
            
            const winds = [];
            const allWinds = dmwData.winds || [];
            
            // Limitar quantidade de vetores para n√£o poluir o mapa
            // Subsample: mostrar no m√°ximo ~200 vetores
            const maxVectors = 200;
            const step = allWinds.length > maxVectors ? Math.ceil(allWinds.length / maxVectors) : 1;
            
            for (let i = 0; i < allWinds.length; i += step) {
                const w = allWinds[i];
                
                // Sempre filtrar por √°rea (bounds da imagem de sat√©lite)
                if (w.lat < latMin || w.lat > latMax) continue;
                if (w.lon < lonMin || w.lon > lonMax) continue;
                
                // Filtrar pontos em terra (continente)
                if (!isOverOcean(w.lat, w.lon)) continue;
                
                // Filtrar por n√≠vel de press√£o
                if (w.pressure_hpa !== undefined) {
                    if (w.pressure_hpa < levelInfo.min || w.pressure_hpa > levelInfo.max) continue;
                }
                
                winds.push(w);
                
                // Cor baseada na velocidade
                const color = getDMWColor(w.speed_kt);
                
                // Criar seta de vento com press√£o e quality flag
                const pressure = w.pressure_hpa || 0;
                const qf = w.quality_flag !== undefined ? w.quality_flag : -1;
                const arrow = createDMWArrow(w.lat, w.lon, w.direction, w.speed_kt, color, pressure, qf);
                arrow.addTo(dmwLayer);
                dmwMarkers.push(arrow);
            }
            
            // Atualizar info com hor√°rio do arquivo
            const timestamp = dmwData.timestamp ? new Date(dmwData.timestamp) : new Date();
            const scanTime = dmwData.scan_time || timestamp.toISOString();
            infoEl.innerHTML = `üìÖ <strong>${winds.length}</strong> vetores | ${levelInfo.name}<br>` +
                              `üõ∞Ô∏è GOES: ${new Date(scanTime).toLocaleString('pt-BR')}`;
            
            statusEl.className = 'status-indicator active';
            log('success', `‚úÖ DMW: ${winds.length} vetores na √°rea`);
            
            // Atualizar contadores de vetores no raio (para UI)
            updateObservedVectorsUI();
            
        } catch (err) {
            console.error('‚ùå Erro DMW:', err);
            log('error', 'Erro DMW: ' + err.message);
            statusEl.className = 'status-indicator error';
            infoEl.textContent = '‚ùå Erro ao carregar dados';
        }
    }
    
    function getDMWColor(speedKt) {
        // Escala de cores unificada (igual ao Scatterometer)
        if (speedKt < 10) return '#00ff00';      // Verde - Calmo (0-10 kn)
        if (speedKt < 15) return '#88ff00';      // Verde claro - Leve (10-15 kn)
        if (speedKt < 20) return '#ffff00';      // Amarelo - Moderado (15-20 kn)
        if (speedKt < 25) return '#ff9900';      // Laranja - Fresco (20-25 kn)
        if (speedKt < 30) return '#ff0000';      // Vermelho - Forte (25-30 kn)
        return '#ff00ff';                         // Roxo/Magenta - Muito forte (>30 kn)
    }
    
    function createDMWArrow(lat, lon, direction, speed, color, pressure, qualityFlag) {
        // Tamanho da seta GRANDE para visualiza√ß√£o de 10m de dist√¢ncia
        const size = Math.min(50 + speed * 0.8, 80);
        
        // DIRE√á√ÉO: Valor indica DE ONDE o vento vem (conven√ß√£o meteorol√≥gica)
        // Seta aponta PARA ONDE o vento vai (rota√ß√£o +180¬∞)
        const arrowRotation = (direction + 180) % 360;
        
        // Criar HTML da seta usando SVG (formato de seta triangular tipo avi√£o) - GRANDE E VIS√çVEL
        const arrowHtml = `
            <div style="transform: rotate(${arrowRotation}deg); width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center;">
                <svg viewBox="0 0 24 24" width="${size - 8}" height="${size - 8}">
                    <path fill="${color}" stroke="#000" stroke-width="1.5" d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
                </svg>
            </div>
            <div style="text-align:center; font-size:18px; font-weight:bold; color:${color}; text-shadow: 2px 2px 4px black, -1px -1px 2px black; margin-top:-4px;">
                ${speed.toFixed(0)}
            </div>
        `;

        const icon = L.divIcon({
            className: 'dmw-wind-arrow',
            html: arrowHtml,
            iconSize: [size, size + 24],
            iconAnchor: [size/2, (size + 24)/2]
        });
        
        // Quality flag descri√ß√£o
        const qfDesc = qualityFlag === 0 ? '‚úÖ √ìtimo' : 
                       qualityFlag === 1 ? '‚ö†Ô∏è Degradado' : 
                       qualityFlag >= 2 ? '‚ùå Ruim' : '‚ùì N/A';
        
        // Popup com informa√ß√µes completas
        const popup = `<b>üå¨Ô∏è Vento DMW (GOES)</b><br>
                       <b>Velocidade:</b> ${speed.toFixed(1)} kt (${(speed * 0.514444).toFixed(1)} m/s)<br>
                       <b>Dire√ß√£o:</b> ${direction.toFixed(0)}¬∞ (de onde vem)<br>
                       <b>Press√£o:</b> ${pressure.toFixed(0)} hPa<br>
                       <b>Qualidade:</b> ${qfDesc} (DQF=${qualityFlag})<br>
                       <hr style="margin:4px 0;border-color:#444;">
                       <b>Lat:</b> ${lat.toFixed(3)}¬∞<br>
                       <b>Lon:</b> ${lon.toFixed(3)}¬∞`;

        return L.marker([lat, lon], { icon: icon })
            .bindPopup(popup);
    }

    // =========================================================================
    // SCATTEROMETER WINDS (ASCAT, CYGNSS via NASA Earthdata)
    // =========================================================================
    
    function toggleSCAT(enabled) {
        scatEnabled = enabled;
        
        // Atualizar bot√µes
        document.getElementById('btn-scat-on').classList.toggle('active', enabled);
        document.getElementById('btn-scat-off').classList.toggle('active', !enabled);
        
        // Atualizar status
        const statusEl = document.getElementById('scat-status');
        
        if (enabled) {
            // Apenas MOSTRAR vetores (dados j√° carregados em background)
            if (scatData && scatData.winds && scatData.winds.length > 0) {
                log('success', 'üëÅÔ∏è SCAT VIS√çVEL - Exibindo vetores...');
                statusEl.className = 'status-indicator active';
                document.getElementById('scatLegend').style.display = 'block';
                drawScatVectors();  // Desenhar vetores dos dados j√° carregados
            } else {
                // Se n√£o h√° dados, carregar
                log('success', '‚úÖ SCAT LIGADO - Carregando ventos de scatter√¥metro...');
                statusEl.className = 'status-indicator loading';
                document.getElementById('scatLegend').style.display = 'block';
                loadScatWinds();
            }
        } else {
            // ESCONDER vetores (dados permanecem em mem√≥ria)
            log('info', 'üôà SCAT OCULTO');
            statusEl.className = 'status-indicator';
            document.getElementById('scatLegend').style.display = 'none';
            clearScatLayer();
            stopScatOpacityTimer();
        }
    }
    
    // Desenhar vetores SCAT dos dados j√° carregados
    function drawScatVectors() {
        if (!scatData || !scatData.winds) return;
        
        const statusEl = document.getElementById('scat-status');
        const infoEl = document.getElementById('scat-info');
        
        const IMAGE_BOUNDS = {
            latMin: REPROJECTION_BOUNDS.south,
            latMax: REPROJECTION_BOUNDS.north,
            lonMin: REPROJECTION_BOUNDS.west,
            lonMax: REPROJECTION_BOUNDS.east
        };
        
        const GRID_SIZE = 0.25;
        const sampledGrid = new Map();
        
        const winds = scatData.winds || [];
        let totalInBounds = 0;
        
        // Amostrar por grid
        for (let i = 0; i < winds.length; i++) {
            const w = winds[i];
            if (w.lat < IMAGE_BOUNDS.latMin || w.lat > IMAGE_BOUNDS.latMax) continue;
            if (w.lon < IMAGE_BOUNDS.lonMin || w.lon > IMAGE_BOUNDS.lonMax) continue;
            
            totalInBounds++;
            
            const gridLat = Math.floor(w.lat / GRID_SIZE);
            const gridLon = Math.floor(w.lon / GRID_SIZE);
            const gridKey = `${gridLat}_${gridLon}`;
            
            if (sampledGrid.has(gridKey)) continue;
            sampledGrid.set(gridKey, w);
        }
        
        // Limpar e criar camada
        clearScatLayer();
        scatLayer = L.layerGroup().addTo(map);
        
        let displayedCount = 0;
        for (const [gridKey, w] of sampledGrid) {
            displayedCount++;
            const color = getScatWindColor(w.speed_kt);
            const marker = createScatWindMarker(w, color);
            marker.addTo(scatLayer);
            scatMarkers.push(marker);
        }
        
        // Atualizar info
        const satellites = scatData.satellites ? scatData.satellites.join(', ') : 'ASCAT';
        infoEl.textContent = `${displayedCount} vetores | ${satellites}`;
        document.getElementById('scatInfoLegend').textContent = `${displayedCount} vetores | ${satellites}`;
        
        statusEl.className = 'status-indicator active';
        log('success', `‚úÖ SCAT: ${displayedCount} vetores exibidos`);
        
        // Iniciar timer de opacidade
        startScatOpacityTimer();
    }
    
    function toggleScatAutoRefresh() {
        const checkbox = document.getElementById('scat-auto-refresh');
        const nextUpdateSpan = document.getElementById('scat-next-update');
        
        if (checkbox.checked) {
            // Verificar a cada 1 hora se h√° dados mais novos
            const ONE_HOUR = 60 * 60 * 1000;
            
            scatAutoRefreshInterval = setInterval(() => {
                console.log('üîç SCAT: Verificando se h√° dados mais novos...');
                checkAndUpdateScatWinds();
                updateScatNextUpdateTime();
            }, ONE_HOUR);
            
            updateScatNextUpdateTime();
            log('info', '‚è∞ SCAT Auto-refresh ativado (verifica a cada 1h)');
        } else {
            // Parar auto-refresh
            if (scatAutoRefreshInterval) {
                clearInterval(scatAutoRefreshInterval);
                scatAutoRefreshInterval = null;
            }
            nextUpdateSpan.textContent = '';
            log('info', '‚è∏Ô∏è SCAT Auto-refresh desativado');
        }
    }
    
    async function checkAndUpdateScatWinds() {
        // Verificar se h√° dados mais novos antes de baixar
        try {
            // Tentar buscar o JSON para comparar timestamp
            const jsonResponse = await fetch('scatterometer_latest.json');
            if (!jsonResponse.ok) return;
            
            const newData = await jsonResponse.json();
            const newTimestamp = newData.timestamp ? new Date(newData.timestamp).getTime() : 0;
            const currentTimestamp = scatLastTimestamp ? new Date(scatLastTimestamp).getTime() : 0;
            
            if (newTimestamp > currentTimestamp) {
                log('info', `‚úÖ SCAT: Dados mais novos encontrados!`);
                loadScatWinds();  // Baixar e renderizar
                // Calibrar modelos APENAS quando h√° dados realmente novos
                setTimeout(() => calibrateWithObservedData(), 500);
            } else {
                log('info', `‚ÑπÔ∏è SCAT: Dados atuais s√£o os mais recentes`);
            }
            
        } catch (err) {
            console.error('‚ùå Erro ao verificar atualiza√ß√µes SCAT:', err);
        }
    }
    
    function updateScatNextUpdateTime() {
        const nextUpdateSpan = document.getElementById('scat-next-update');
        const now = new Date();
        const nextUpdate = new Date(now.getTime() + 60 * 60 * 1000);  // 1 hora
        nextUpdateSpan.textContent = `Pr√≥x: ${nextUpdate.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`;
    }
    
    function clearScatLayer() {
        scatMarkers.forEach(m => map.removeLayer(m));
        scatMarkers = [];
        if (scatLayer) {
            map.removeLayer(scatLayer);
            scatLayer = null;
        }
    }
    
    // Carregar dados SCAT silenciosamente (sem desenhar vetores)
    // Usado na inicializa√ß√£o para ter os dados prontos e atualizar contadores
    async function loadScatDataSilently() {
        const statusEl = document.getElementById('scat-status');
        const infoEl = document.getElementById('scat-info');
        
        log('info', 'üõ∞Ô∏è Carregando dados SCAT em background...');
        
        try {
            // Usar bounds FIXOS da imagem do sat√©lite
            const IMAGE_BOUNDS = {
                latMin: REPROJECTION_BOUNDS.south,
                latMax: REPROJECTION_BOUNDS.north,
                lonMin: REPROJECTION_BOUNDS.west,
                lonMax: REPROJECTION_BOUNDS.east
            };
            
            let scatDataLocal = null;
            
            // Tentar API local primeiro
            try {
                const apiUrl = `/api/scatterometer?lat_min=${IMAGE_BOUNDS.latMin}&lat_max=${IMAGE_BOUNDS.latMax}&lon_min=${IMAGE_BOUNDS.lonMin}&lon_max=${IMAGE_BOUNDS.lonMax}`;
                const response = await fetch(apiUrl, { timeout: 30000 });
                if (response.ok) {
                    scatDataLocal = await response.json();
                }
            } catch (apiErr) {
                console.log('[SCAT] API local n√£o dispon√≠vel, tentando arquivo JSON...');
            }
            
            // Fallback: arquivo JSON
            if (!scatDataLocal || !scatDataLocal.winds || scatDataLocal.winds.length === 0) {
                try {
                    const jsonUrl = 'scatterometer_latest.json';
                    const response = await fetch(jsonUrl + '?' + Date.now());
                    if (response.ok) {
                        scatDataLocal = await response.json();
                    }
                } catch (jsonErr) {
                    console.log('[SCAT] Arquivo JSON n√£o dispon√≠vel');
                }
            }
            
            if (!scatDataLocal || !scatDataLocal.winds || scatDataLocal.winds.length === 0) {
                log('warning', '‚ö†Ô∏è SCAT: Nenhum dado dispon√≠vel');
                return;
            }
            
            // Salvar dados globalmente (sem desenhar)
            scatData = scatDataLocal;
            
            // Contar vetores na √°rea
            const winds = scatData.winds || [];
            let totalInBounds = 0;
            for (let i = 0; i < winds.length; i++) {
                const w = winds[i];
                if (w.lat >= IMAGE_BOUNDS.latMin && w.lat <= IMAGE_BOUNDS.latMax &&
                    w.lon >= IMAGE_BOUNDS.lonMin && w.lon <= IMAGE_BOUNDS.lonMax) {
                    totalInBounds++;
                }
            }
            
            // Atualizar info
            const satellites = scatData.satellites ? scatData.satellites.join(', ') : 'ASCAT';
            infoEl.textContent = `${totalInBounds} vetores | ${satellites}`;
            
            // Atualizar timestamp
            if (scatData.timestamp) {
                scatLastTimestamp = scatData.timestamp;
                const ts = new Date(scatData.timestamp);
                const tsStr = ts.toLocaleString('pt-BR', {
                    day: '2-digit', month: '2-digit', year: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
                document.getElementById('scat-timestamp').textContent = `üìÖ ${tsStr}`;
                document.getElementById('scatTimestampLegend').textContent = tsStr;
            }
            
            // Atualizar contadores de vetores no raio de 20nm
            updateObservedVectorsUI();
            
            log('success', `‚úÖ SCAT: ${totalInBounds} vetores carregados (background) | ${scatData.source || 'N/A'}`);
            
        } catch (err) {
            console.error('‚ùå Erro SCAT (background):', err);
            log('error', 'Erro SCAT: ' + err.message);
        }
    }

    async function loadScatWinds() {
        if (!scatEnabled) return;
        
        const statusEl = document.getElementById('scat-status');
        const infoEl = document.getElementById('scat-info');
        
        statusEl.className = 'status-indicator loading';
        log('info', 'üõ∞Ô∏è Carregando ventos de Scatter√¥metros...');
        
        try {
            // Usar bounds FIXOS da imagem do sat√©lite
            const IMAGE_BOUNDS = {
                latMin: REPROJECTION_BOUNDS.south,  // -30
                latMax: REPROJECTION_BOUNDS.north,  // 0
                lonMin: REPROJECTION_BOUNDS.west,   // -60
                lonMax: REPROJECTION_BOUNDS.east    // -30
            };
            
            // Grid de amostragem para reduzir densidade (~0.25¬∞ = ~25km)
            const GRID_SIZE = 0.25;
            const sampledGrid = new Map();
            
            // Tentar buscar do servidor local primeiro
            let scatDataLocal = null;
            
            try {
                // Tentar API local
                const apiUrl = `/api/scatterometer?lat_min=${IMAGE_BOUNDS.latMin}&lat_max=${IMAGE_BOUNDS.latMax}&lon_min=${IMAGE_BOUNDS.lonMin}&lon_max=${IMAGE_BOUNDS.lonMax}`;
                console.log('[SCAT] Tentando API local:', apiUrl);
                
                const response = await fetch(apiUrl, { timeout: 30000 });
                if (response.ok) {
                    scatDataLocal = await response.json();
                    console.log('[SCAT] Dados da API local:', scatDataLocal);
                }
            } catch (apiErr) {
                console.log('[SCAT] API local n√£o dispon√≠vel, tentando arquivo JSON...');
            }
            
            // Fallback: tentar arquivo JSON pr√©-gerado
            if (!scatDataLocal || !scatDataLocal.winds || scatDataLocal.winds.length === 0) {
                try {
                    const jsonUrl = 'scatterometer_latest.json';
                    const response = await fetch(jsonUrl + '?' + Date.now());
                    if (response.ok) {
                        scatDataLocal = await response.json();
                        console.log('[SCAT] Dados do arquivo JSON:', scatDataLocal);
                    }
                } catch (jsonErr) {
                    console.log('[SCAT] Arquivo JSON n√£o dispon√≠vel');
                }
            }
            
            if (!scatDataLocal || !scatDataLocal.winds || scatDataLocal.winds.length === 0) {
                throw new Error('Nenhum dado de scatter√¥metro dispon√≠vel');
            }
            
            // Salvar dados globalmente
            scatData = scatDataLocal;
            
            // Limpar camada anterior
            clearScatLayer();
            scatLayer = L.layerGroup().addTo(map);
            
            const winds = scatData.winds || [];
            let displayedCount = 0;
            let totalInBounds = 0;
            
            // Primeiro passo: filtrar e amostrar por grid
            for (let i = 0; i < winds.length; i++) {
                const w = winds[i];
                
                // Filtrar por √°rea da imagem do sat√©lite
                if (w.lat < IMAGE_BOUNDS.latMin || w.lat > IMAGE_BOUNDS.latMax) continue;
                if (w.lon < IMAGE_BOUNDS.lonMin || w.lon > IMAGE_BOUNDS.lonMax) continue;
                
                totalInBounds++;
                
                // Amostrar por grid (1 vetor por c√©lula de GRID_SIZE x GRID_SIZE graus)
                const gridLat = Math.floor(w.lat / GRID_SIZE);
                const gridLon = Math.floor(w.lon / GRID_SIZE);
                const gridKey = `${gridLat}_${gridLon}`;
                
                // Se j√° tem um vetor nessa c√©lula, pular (manter o primeiro)
                if (sampledGrid.has(gridKey)) continue;
                
                // Guardar este vetor para a c√©lula
                sampledGrid.set(gridKey, w);
            }
            
            console.log(`[SCAT] Grid: ${totalInBounds} pontos -> ${sampledGrid.size} amostrados (grid ${GRID_SIZE}¬∞)`);
            
            // Segundo passo: renderizar apenas os vetores amostrados
            for (const [gridKey, w] of sampledGrid) {
                displayedCount++;
                
                // Cor baseada na velocidade
                const color = getScatWindColor(w.speed_kt);
                
                // Criar marcador de vento
                const marker = createScatWindMarker(w, color);
                marker.addTo(scatLayer);
                scatMarkers.push(marker);
            }
            
            // Atualizar info
            const satellites = scatData.satellites ? scatData.satellites.join(', ') : 'ASCAT';
            infoEl.textContent = `${displayedCount} vetores | ${satellites}`;
            document.getElementById('scatInfoLegend').textContent = `${displayedCount} vetores | ${satellites}`;
            
            // Atualizar timestamp
            if (scatData.timestamp) {
                scatLastTimestamp = scatData.timestamp;
                const ts = new Date(scatData.timestamp);
                const tsStr = ts.toLocaleString('pt-BR', {
                    day: '2-digit', month: '2-digit', year: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
                document.getElementById('scat-timestamp').textContent = `üìÖ ${tsStr}`;
                document.getElementById('scatTimestampLegend').textContent = tsStr;
            }
            
            statusEl.className = 'status-indicator active';
            log('success', `‚úÖ SCAT: ${displayedCount} vetores carregados | ${scatData.source || 'N/A'}`);
            
            // Atualizar contadores de vetores no raio (para UI)
            updateObservedVectorsUI();
            
            // Iniciar timer de opacidade (fade out em 6 horas)
            startScatOpacityTimer();
            
        } catch (err) {
            console.error('‚ùå Erro SCAT:', err);
            log('error', 'Erro SCAT: ' + err.message);
            statusEl.className = 'status-indicator error';
            infoEl.textContent = '‚ùå Erro ao carregar';
        }
    }
    
    function getScatWindColor(speedKt) {
        // Escala de cores unificada (igual ao DMW)
        if (speedKt < 10) return '#00ff00';      // Verde - Calmo (0-10 kn)
        if (speedKt < 15) return '#88ff00';      // Verde claro - Leve (10-15 kn)
        if (speedKt < 20) return '#ffff00';      // Amarelo - Moderado (15-20 kn)
        if (speedKt < 25) return '#ff9900';      // Laranja - Fresco (20-25 kn)
        if (speedKt < 30) return '#ff0000';      // Vermelho - Forte (25-30 kn)
        return '#ff00ff';                         // Roxo/Magenta - Muito forte (>30 kn)
    }
    
    function createScatWindMarker(wind, color) {
        const lat = wind.lat;
        const lon = wind.lon;
        const speed = wind.speed_kt;
        const direction = wind.direction;
        const satellite = wind.satellite || 'SCAT';
        
        // Se n√£o tem dire√ß√£o (CYGNSS), usar c√≠rculo
        if (direction === null || direction === undefined) {
            // C√≠rculo simples para CYGNSS (s√≥ velocidade)
            const circle = L.circleMarker([lat, lon], {
                radius: 4 + speed * 0.1,
                color: color,
                fillColor: color,
                fillOpacity: 0.7,
                weight: 1
            });
            
            circle.bindPopup(`
                <div style="text-align:center;">
                    <b>üõ∞Ô∏è ${satellite}</b><br>
                    <b>${speed.toFixed(1)} kt</b> (${(speed * 0.514444).toFixed(1)} m/s)<br>
                    Dire√ß√£o: N/A (somente velocidade)<br>
                    Lat: ${lat.toFixed(2)}¬∞ | Lon: ${lon.toFixed(2)}¬∞
                </div>
            `, { className: 'wind-popup' });
            
            return circle;
        }
        
        // Seta de vento (linha + cabe√ßa)
        const arrowLength = Math.min(0.15 + speed * 0.005, 0.4);
        
        // Converter dire√ß√£o meteorol√≥gica (de onde vem) para onde vai
        const adjustedDir = (direction - 180 + 360) % 360;
        const mathAngle = (90 - adjustedDir + 360) % 360;
        const dirRad = mathAngle * Math.PI / 180;
        
        // Calcular ponto final
        const endLat = lat - arrowLength * Math.sin(dirRad);
        const endLon = lon - arrowLength * Math.cos(dirRad) / Math.cos(lat * Math.PI / 180);
        
        const line = L.polyline([[lat, lon], [endLat, endLon]], {
            color: color,
            weight: 2,
            opacity: 0.9
        });
        
        line.bindPopup(`
            <div style="text-align:center;">
                <b>üõ∞Ô∏è ${satellite}</b><br>
                <b>${speed.toFixed(1)} kt</b> (${(speed * 0.514444).toFixed(1)} m/s)<br>
                Vem de: ${adjustedDir.toFixed(0)}¬∞<br>
                Lat: ${lat.toFixed(2)}¬∞ | Lon: ${lon.toFixed(2)}¬∞
            </div>
        `, { className: 'wind-popup' });
        
        // Cabe√ßa da seta
        const arrowHead = L.divIcon({
            html: `<div style="
                width: 0;
                height: 0;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-bottom: 10px solid ${color};
                transform: rotate(${(adjustedDir + 180) % 360}deg);
                transform-origin: center center;
                filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
            "></div>`,
            iconSize: [10, 10],
            iconAnchor: [5, 5],
            className: 'scat-arrow-head'
        });
        
        const head = L.marker([endLat, endLon], { icon: arrowHead, interactive: false });
        
        return L.layerGroup([line, head]);
    }
    
    // Recarregar SCAT quando mover o mapa
    let scatReloadTimeout = null;
    
    function setupScatAutoReload() {
        map.on('moveend', () => {
            if (scatEnabled) {
                clearTimeout(scatReloadTimeout);
                scatReloadTimeout = setTimeout(() => {
                    loadScatWinds();
                }, 1500);
            }
        });
    }
    
    // =========================================================================
    // OPACIDADE SCAT BASEADA NA IDADE DOS DADOS
    // =========================================================================
    
    // Calcular opacidade baseada na idade (0-1)
    // 0 horas = 1.0 (100%), 6 horas = 0.0 (0%)
    function getScatOpacity() {
        if (!scatLastTimestamp) return 1.0;
        
        const dataTime = new Date(scatLastTimestamp).getTime();
        const now = Date.now();
        const ageMs = now - dataTime;
        const ageHours = ageMs / (1000 * 60 * 60);
        
        // Se mais de 6 horas, opacidade 0
        if (ageHours >= SCAT_MAX_AGE_HOURS) return 0;
        
        // Opacidade linear: 1.0 em 0h, 0.0 em 6h
        return Math.max(0, 1.0 - (ageHours / SCAT_MAX_AGE_HOURS));
    }
    
    // Atualizar opacidade de todos os vetores SCAT
    function updateScatOpacity() {
        const opacity = getScatOpacity();
        
        // Se opacidade zero, esconder camada e legenda
        if (opacity <= 0) {
            if (scatLayer) {
                scatLayer.eachLayer(layer => {
                    if (layer.setStyle) layer.setStyle({ opacity: 0, fillOpacity: 0 });
                    if (layer.setOpacity) layer.setOpacity(0);
                    if (layer.eachLayer) {
                        layer.eachLayer(sublayer => {
                            if (sublayer.setStyle) sublayer.setStyle({ opacity: 0, fillOpacity: 0 });
                            if (sublayer.setOpacity) sublayer.setOpacity(0);
                        });
                    }
                });
            }
            document.getElementById('scatLegend').style.display = 'none';
            log('warning', '‚ö†Ô∏è SCAT: Dados expiraram (mais de 6h)');
            
            // Parar o intervalo
            if (scatOpacityInterval) {
                clearInterval(scatOpacityInterval);
                scatOpacityInterval = null;
            }
            return;
        }
        
        // Aplicar opacidade a todos os vetores
        if (scatLayer) {
            scatLayer.eachLayer(layer => {
                // Para polylines (setas)
                if (layer.setStyle) {
                    layer.setStyle({ opacity: opacity * 0.9 });
                }
                // Para LayerGroups (seta + cabe√ßa)
                if (layer.eachLayer) {
                    layer.eachLayer(sublayer => {
                        if (sublayer.setStyle) sublayer.setStyle({ opacity: opacity * 0.9 });
                        if (sublayer.setOpacity) sublayer.setOpacity(opacity);
                        // Para markers (cabe√ßa da seta)
                        if (sublayer._icon) {
                            sublayer._icon.style.opacity = opacity;
                        }
                    });
                }
                // Para circle markers
                if (layer.setStyle && layer.options && layer.options.fillOpacity !== undefined) {
                    layer.setStyle({ opacity: opacity * 0.9, fillOpacity: opacity * 0.7 });
                }
            });
        }
        
        // Atualizar legenda com indica√ß√£o de idade
        const ageHours = (Date.now() - new Date(scatLastTimestamp).getTime()) / (1000 * 60 * 60);
        const ageStr = ageHours < 1 ? `${Math.round(ageHours * 60)}min` : `${ageHours.toFixed(1)}h`;
        const opacityPct = Math.round(opacity * 100);
        document.getElementById('scatInfoLegend').textContent = `${scatMarkers.length} vetores | ${opacityPct}% (${ageStr})`;
    }
    
    // Iniciar timer de atualiza√ß√£o de opacidade (a cada 1 minuto)
    function startScatOpacityTimer() {
        // Limpar intervalo anterior se existir
        if (scatOpacityInterval) {
            clearInterval(scatOpacityInterval);
        }
        
        // Atualizar imediatamente
        updateScatOpacity();
        
        // Atualizar a cada 1 minuto
        scatOpacityInterval = setInterval(() => {
            updateScatOpacity();
        }, 60 * 1000);
    }
    
    // Parar timer de opacidade
    function stopScatOpacityTimer() {
        if (scatOpacityInterval) {
            clearInterval(scatOpacityInterval);
            scatOpacityInterval = null;
        }
    }

    // =========================================================================
    // CAMADA L2 GOES (CAPE, LI, Cloud Height, TPW)
    // =========================================================================
    let l2Enabled = false;
    let l2Layer = null;
    let l2Data = null;
    let l2Markers = [];
    let l2CanvasLayer = null;
    let l2DisplayMode = 'area'; // 'area' ou 'markers'
    let l2Opacity = 70; // Opacidade do canvas L2 (0-100)
    
    // Fun√ß√£o para atualizar opacidade do canvas L2
    function updateL2Opacity(value) {
        l2Opacity = parseInt(value);
        document.getElementById('l2-opacity-value').textContent = l2Opacity + '%';
        
        // Redesenhar o canvas com a nova opacidade
        if (l2CanvasLayer && l2DisplayMode === 'area') {
            l2CanvasLayer.draw();
        }
    }
    
    function toggleL2(enabled) {
        l2Enabled = enabled;
        
        // Atualizar bot√µes
        document.getElementById('btn-l2-on').classList.toggle('active', enabled);
        document.getElementById('btn-l2-off').classList.toggle('active', !enabled);
        
        // Atualizar status
        const statusEl = document.getElementById('l2-status');
        
        if (enabled) {
            log('success', '‚úÖ L2 LIGADO - Carregando dados...');
            statusEl.className = 'status-indicator loading';
            loadL2Data();
        } else {
            log('info', '‚ùå L2 DESLIGADO');
            statusEl.className = 'status-indicator';
            clearL2Layer();
            document.getElementById('l2-ship-data').style.display = 'none';
        }
    }
    
    function clearL2Layer() {
        if (l2Layer) {
            l2Layer.clearLayers();
            map.removeLayer(l2Layer);
            l2Layer = null;
        }
        if (l2CanvasLayer) {
            map.removeLayer(l2CanvasLayer);
            l2CanvasLayer = null;
        }
        l2Markers = [];
    }
    
    async function loadL2Data() {
        if (!l2Enabled) return;
        
        const statusEl = document.getElementById('l2-status');
        const infoEl = document.getElementById('l2-info');
        
        try {
            statusEl.className = 'status-indicator loading';
            infoEl.textContent = 'üì° Carregando dados L2...';
            
            // Carregar dados L2 do arquivo JSON (gerado pelo goes_l2_extractor.py)
            console.log('[L2] Carregando goes_l2_latest.json...');
            log('info', 'üì° L2: Carregando dados...');
            
            const response = await fetch('goes_l2_latest.json?' + Date.now());
            if (!response.ok) {
                throw new Error(`Dados L2 n√£o encontrados (${response.status})`);
            }
            
            l2Data = await response.json();
            console.log('[L2] Dados carregados:', l2Data.products ? Object.keys(l2Data.products) : 'sem produtos');
            
            // Limpar camada anterior
            clearL2Layer();
            l2Layer = L.layerGroup().addTo(map);
            
            // Exibir dados com a vari√°vel selecionada
            updateL2Display();
            
            // Atualizar info
            const timestamp = new Date(l2Data.timestamp);
            infoEl.innerHTML = `üìÖ ${timestamp.toLocaleString('pt-BR')}<br>üõ∞Ô∏è ${l2Data.satellite_name || 'GOES-19'}`;
            
            statusEl.className = 'status-indicator active';
            log('success', `‚úÖ L2: Dados carregados`);
            
        } catch (err) {
            console.error('‚ùå Erro L2:', err);
            log('error', 'Erro L2: ' + err.message);
            statusEl.className = 'status-indicator error';
            infoEl.textContent = '‚ùå Erro ao carregar dados';
        }
    }
    
    function updateL2Display() {
        if (!l2Data) return;
        
        // Criar legenda
        const selectedVar = document.getElementById('l2-variable').value;
        createL2Legend(selectedVar);
        
        // Se modo √°rea, usar canvas layer
        if (l2DisplayMode === 'area') {
            if (l2Layer) {
                l2Layer.clearLayers();
            }
            l2Markers = [];
            updateL2CanvasLayer();
            updateL2ShipData();
            return;
        }
        
        // Modo marcadores
        if (!l2Layer) return;
        
        l2Layer.clearLayers();
        l2Markers = [];
        
        const shipData = document.getElementById('l2-ship-data');
        
        // Encontrar qual produto tem a vari√°vel
        let productKey = null;
        let productData = null;
        
        if (selectedVar === 'CAPE' || selectedVar === 'LI' || selectedVar === 'KI' || selectedVar === 'TT' || selectedVar === 'SI') {
            productKey = 'DSIF';
        } else if (selectedVar === 'TPW') {
            productKey = 'TPWF';
        } else if (selectedVar === 'HT') {
            productKey = 'ACHAF';
        } else if (selectedVar === 'Phase') {
            productKey = 'ACTPF';
        }
        
        if (productKey && l2Data.products[productKey] && l2Data.products[productKey].data) {
            productData = l2Data.products[productKey].data;
        }
        
        if (!productData || productData.length === 0) {
            log('warning', `‚ö†Ô∏è Sem dados para ${selectedVar}`);
            return;
        }
        
        // Encontrar dados no ponto do navio (mais pr√≥ximo)
        let closestToShip = null;
        let minDist = Infinity;
        
        for (const point of productData) {
            const dist = Math.sqrt(Math.pow(point.lat - CONFIG.shipLat, 2) + Math.pow(point.lon - CONFIG.shipLon, 2));
            if (dist < minDist) {
                minDist = dist;
                closestToShip = point;
            }
        }
        
        // Exibir dados do ponto mais pr√≥ximo ao navio
        if (closestToShip && minDist < 0.5) {
            shipData.style.display = 'block';
            
            // DSIF
            if (l2Data.products.DSIF && l2Data.products.DSIF.data) {
                const dsif = l2Data.products.DSIF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (dsif) {
                    document.getElementById('l2-ship-cape').textContent = dsif.CAPE ? dsif.CAPE.toFixed(0) + ' J/kg' : '--';
                    document.getElementById('l2-ship-li').textContent = dsif.LI ? dsif.LI.toFixed(1) + ' K' : '--';
                }
            }
            
            // TPW
            if (l2Data.products.TPWF && l2Data.products.TPWF.data) {
                const tpw = l2Data.products.TPWF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (tpw) {
                    document.getElementById('l2-ship-tpw').textContent = tpw.TPW ? tpw.TPW.toFixed(1) + ' mm' : '--';
                }
            }
            
            // Cloud Height
            if (l2Data.products.ACHAF && l2Data.products.ACHAF.data) {
                const ht = l2Data.products.ACHAF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (ht && ht.HT) {
                    document.getElementById('l2-ship-ht').textContent = (ht.HT / 1000).toFixed(1) + ' km';
                } else {
                    document.getElementById('l2-ship-ht').textContent = '‚òÄÔ∏è C√©u limpo';
                }
            }
        }
        
        // Exibir marcadores no mapa
        for (const point of productData) {
            const value = point[selectedVar];
            if (value === undefined || value === null) continue;
            
            const color = getL2Color(selectedVar, value);
            const label = formatL2Value(selectedVar, value);
            
            const marker = createL2Marker(point.lat, point.lon, label, color, selectedVar, point);
            marker.addTo(l2Layer);
            l2Markers.push(marker);
        }
        
        log('info', `üìä L2: ${l2Markers.length} pontos de ${selectedVar}`);
    }
    
    // Atualizar dados do navio (usado por ambos os modos)
    function updateL2ShipData() {
        if (!l2Data) return;
        
        const shipData = document.getElementById('l2-ship-data');
        const selectedVar = document.getElementById('l2-variable').value;
        
        // Encontrar qual produto tem a vari√°vel
        let productKey = null;
        if (selectedVar === 'CAPE' || selectedVar === 'LI' || selectedVar === 'KI' || selectedVar === 'TT' || selectedVar === 'SI') {
            productKey = 'DSIF';
        } else if (selectedVar === 'TPW') {
            productKey = 'TPWF';
        } else if (selectedVar === 'HT') {
            productKey = 'ACHAF';
        } else if (selectedVar === 'Phase') {
            productKey = 'ACTPF';
        }
        
        if (!productKey || !l2Data.products[productKey] || !l2Data.products[productKey].data) {
            return;
        }
        
        const productData = l2Data.products[productKey].data;
        
        // Encontrar dados no ponto do navio (mais pr√≥ximo)
        let closestToShip = null;
        let minDist = Infinity;
        
        for (const point of productData) {
            const dist = Math.sqrt(Math.pow(point.lat - CONFIG.shipLat, 2) + Math.pow(point.lon - CONFIG.shipLon, 2));
            if (dist < minDist) {
                minDist = dist;
                closestToShip = point;
            }
        }
        
        if (closestToShip && minDist < 0.5) {
            shipData.style.display = 'block';
            
            // DSIF
            if (l2Data.products.DSIF && l2Data.products.DSIF.data) {
                const dsif = l2Data.products.DSIF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (dsif) {
                    document.getElementById('l2-ship-cape').textContent = dsif.CAPE ? dsif.CAPE.toFixed(0) + ' J/kg' : '--';
                    document.getElementById('l2-ship-li').textContent = dsif.LI ? dsif.LI.toFixed(1) + ' K' : '--';
                }
            }
            
            // TPW
            if (l2Data.products.TPWF && l2Data.products.TPWF.data) {
                const tpw = l2Data.products.TPWF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (tpw) {
                    document.getElementById('l2-ship-tpw').textContent = tpw.TPW ? tpw.TPW.toFixed(1) + ' mm' : '--';
                }
            }
            
            // Cloud Height
            if (l2Data.products.ACHAF && l2Data.products.ACHAF.data) {
                const ht = l2Data.products.ACHAF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (ht && ht.HT) {
                    document.getElementById('l2-ship-ht').textContent = (ht.HT / 1000).toFixed(1) + ' km';
                } else {
                    document.getElementById('l2-ship-ht').textContent = '‚òÄÔ∏è C√©u limpo';
                }
            }
        }
    }
    
    // =========================================================================
    // SISTEMA DE CORES COM GRADIENTE GRANULAR
    // =========================================================================
    
    // Interpola entre duas cores hex
    function interpolateColor(color1, color2, factor) {
        const hex = (c) => parseInt(c, 16);
        const r1 = hex(color1.slice(1, 3)), g1 = hex(color1.slice(3, 5)), b1 = hex(color1.slice(5, 7));
        const r2 = hex(color2.slice(1, 3)), g2 = hex(color2.slice(3, 5)), b2 = hex(color2.slice(5, 7));
        const r = Math.round(r1 + (r2 - r1) * factor);
        const g = Math.round(g1 + (g2 - g1) * factor);
        const b = Math.round(b1 + (b2 - b1) * factor);
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    // Paleta de cores expandida para CAPE
    const CAPE_COLORS = [
        { value: 0, color: '#004400' },      // Verde muito escuro
        { value: 50, color: '#006600' },     // Verde escuro
        { value: 100, color: '#008800' },    // Verde m√©dio-escuro
        { value: 150, color: '#00aa00' },    // Verde m√©dio
        { value: 200, color: '#00cc00' },    // Verde
        { value: 300, color: '#00ff00' },    // Verde claro
        { value: 400, color: '#66ff00' },    // Verde-amarelo claro
        { value: 500, color: '#99ff00' },    // Amarelo-verde
        { value: 600, color: '#ccff00' },    // Amarelo esverdeado
        { value: 700, color: '#e6e600' },    // Amarelo escuro
        { value: 800, color: '#ffff00' },    // Amarelo
        { value: 900, color: '#ffdd00' },    // Amarelo-laranja claro
        { value: 1000, color: '#ffcc00' },   // Laranja claro
        { value: 1200, color: '#ffaa00' },   // Laranja m√©dio-claro
        { value: 1400, color: '#ff9900' },   // Laranja
        { value: 1600, color: '#ff7700' },   // Laranja escuro
        { value: 1800, color: '#ff5500' },   // Laranja-vermelho
        { value: 2000, color: '#ff3300' },   // Vermelho-laranja
        { value: 2500, color: '#ff0000' },   // Vermelho
        { value: 3000, color: '#cc0000' },   // Vermelho escuro
        { value: 4000, color: '#990000' },   // Vermelho muito escuro
        { value: 5000, color: '#660033' }    // Roxo escuro
    ];
    
    // Paleta de cores para LI (Lifted Index) - valores negativos = inst√°vel
    const LI_COLORS = [
        { value: 6, color: '#004400' },      // Muito est√°vel - verde muito escuro
        { value: 4, color: '#006600' },      // Muito est√°vel - verde escuro
        { value: 2, color: '#00aa00' },      // Est√°vel - verde m√©dio
        { value: 1, color: '#00ff00' },      // Est√°vel - verde claro
        { value: 0, color: '#88ff00' },      // Marginalmente est√°vel - verde-amarelo
        { value: -1, color: '#ccff00' },     // Marginalmente inst√°vel - amarelo-verde
        { value: -2, color: '#ffff00' },     // Levemente inst√°vel - amarelo
        { value: -3, color: '#ffcc00' },     // Inst√°vel - laranja claro
        { value: -4, color: '#ff9900' },     // Moderadamente inst√°vel - laranja
        { value: -5, color: '#ff6600' },     // Muito inst√°vel - laranja escuro
        { value: -6, color: '#ff3300' },     // Muito inst√°vel - vermelho-laranja
        { value: -8, color: '#ff0000' },     // Extremamente inst√°vel - vermelho
        { value: -10, color: '#cc0000' }     // Extremamente inst√°vel - vermelho escuro
    ];
    
    // Paleta de cores para TPW (√°gua precipit√°vel)
    const TPW_COLORS = [
        { value: 0, color: '#001144' },      // Muito seco - azul muito escuro
        { value: 10, color: '#002288' },     // Seco - azul escuro
        { value: 20, color: '#0044cc' },     // Seco - azul m√©dio
        { value: 30, color: '#0088ff' },     // Normal - azul claro
        { value: 40, color: '#00ccff' },     // Normal - ciano
        { value: 50, color: '#00ffaa' },     // √ömido - verde-ciano
        { value: 60, color: '#88ff00' },     // √ömido - verde-amarelo
        { value: 70, color: '#ffff00' },     // Muito √∫mido - amarelo
        { value: 80, color: '#ff9900' },     // Muito √∫mido - laranja
        { value: 90, color: '#ff0000' },     // Extremamente √∫mido - vermelho
        { value: 100, color: '#990066' }     // Saturado - roxo
    ];
    
    // Paleta de cores para altura de nuvem
    const HT_COLORS = [
        { value: 0, color: '#004400' },      // Sem nuvem - verde muito escuro
        { value: 1000, color: '#00aa00' },   // Baixa - verde m√©dio
        { value: 2000, color: '#00ff00' },   // Baixa - verde claro
        { value: 3000, color: '#88ff00' },   // M√©dia-baixa - verde-amarelo
        { value: 4000, color: '#ccff00' },   // M√©dia - amarelo-verde
        { value: 5000, color: '#ffff00' },   // M√©dia - amarelo
        { value: 6000, color: '#ffcc00' },   // M√©dia-alta - laranja claro
        { value: 8000, color: '#ff9900' },   // Alta - laranja
        { value: 10000, color: '#ff5500' },  // Alta - laranja escuro
        { value: 12000, color: '#ff0000' },  // Muito alta - vermelho
        { value: 14000, color: '#cc0066' },  // Muito alta - magenta escuro
        { value: 16000, color: '#9900cc' }   // Extrema - roxo
    ];
    
    // Fun√ß√£o para obter cor do gradiente
    function getColorFromGradient(value, colorStops) {
        // Encontrar os dois pontos entre os quais o valor est√°
        let lower = colorStops[0];
        let upper = colorStops[colorStops.length - 1];
        
        for (let i = 0; i < colorStops.length - 1; i++) {
            if (value >= colorStops[i].value && value <= colorStops[i + 1].value) {
                lower = colorStops[i];
                upper = colorStops[i + 1];
                break;
            } else if (value < colorStops[i].value) {
                return colorStops[i].color;
            }
        }
        
        if (value >= upper.value) return upper.color;
        if (value <= lower.value) return lower.color;
        
        // Interpolar
        const factor = (value - lower.value) / (upper.value - lower.value);
        return interpolateColor(lower.color, upper.color, factor);
    }
    
    function getL2Color(variable, value) {
        switch(variable) {
            case 'CAPE':
                return getColorFromGradient(value, CAPE_COLORS);
            
            case 'LI':
                // LI usa escala invertida (valores altos primeiro)
                return getColorFromGradient(value, LI_COLORS.slice().sort((a, b) => b.value - a.value));
            
            case 'TPW':
                return getColorFromGradient(value, TPW_COLORS);
            
            case 'HT':
                return getColorFromGradient(value, HT_COLORS);
            
            case 'Phase':
                const phases = ['#00aaff', '#00ff00', '#00ffcc', '#ffff00', '#ff00ff', '#888888'];
                return phases[Math.floor(value)] || '#888888';
            
            default:
                return '#ffffff';
        }
    }
    
    // Calcular opacidade baseada na intensidade do valor (valores maiores = mais opaco)
    function getL2IntensityOpacity(variable, value) {
        // Retorna um fator de 0.1 a 1.0 baseado na intensidade
        let normalized = 0;
        
        switch(variable) {
            case 'CAPE':
                // CAPE: 0-5000 J/kg, valores acima de 1000 s√£o significativos
                if (value < 100) normalized = 0.1;
                else if (value < 300) normalized = 0.2;
                else if (value < 500) normalized = 0.3;
                else if (value < 800) normalized = 0.4;
                else if (value < 1000) normalized = 0.5;
                else if (value < 1500) normalized = 0.6;
                else if (value < 2000) normalized = 0.75;
                else if (value < 3000) normalized = 0.9;
                else normalized = 1.0;
                break;
            
            case 'LI':
                // LI: valores negativos s√£o inst√°veis (mais importante)
                // -10 a +10, valores < -2 s√£o significativos
                if (value > 2) normalized = 0.1;       // Est√°vel
                else if (value > 0) normalized = 0.2;  // Marginalmente est√°vel
                else if (value > -2) normalized = 0.4; // Marginalmente inst√°vel
                else if (value > -4) normalized = 0.6; // Inst√°vel
                else if (value > -6) normalized = 0.8; // Muito inst√°vel
                else normalized = 1.0;                  // Extremamente inst√°vel
                break;
            
            case 'TPW':
                // TPW: 0-100 mm, valores acima de 40 s√£o significativos
                if (value < 10) normalized = 0.1;
                else if (value < 20) normalized = 0.2;
                else if (value < 30) normalized = 0.35;
                else if (value < 40) normalized = 0.5;
                else if (value < 50) normalized = 0.65;
                else if (value < 60) normalized = 0.8;
                else normalized = 1.0;
                break;
            
            case 'HT':
                // Altura de nuvem: 0-16000 m
                if (value < 1000) normalized = 0.15;
                else if (value < 2000) normalized = 0.25;
                else if (value < 4000) normalized = 0.4;
                else if (value < 6000) normalized = 0.55;
                else if (value < 8000) normalized = 0.7;
                else if (value < 10000) normalized = 0.85;
                else normalized = 1.0;
                break;
            
            case 'Phase':
                normalized = 0.7; // Fase de nuvem - opacidade fixa
                break;
            
            default:
                normalized = 0.5;
        }
        
        return normalized;
    }
    
    function formatL2Value(variable, value) {
        switch(variable) {
            case 'CAPE':
                return value.toFixed(0);
            case 'LI':
                return value.toFixed(1);
            case 'TPW':
                return value.toFixed(0);
            case 'HT':
                return (value / 1000).toFixed(1);
            case 'Phase':
                const labels = ['‚òÄÔ∏è', 'üíß', '‚ùÑÔ∏è', 'üåÄ', 'üßä', '‚ùì'];
                return labels[Math.floor(value)] || '?';
            default:
                return value.toFixed(1);
        }
    }
    
    function createL2Marker(lat, lon, label, color, variable, point) {
        // Tamanho GRANDE para visualiza√ß√£o de 10m de dist√¢ncia
        const size = 50;
        
        const markerHtml = `
            <div style="
                width: ${size}px;
                height: ${size}px;
                background: ${color};
                border: 3px solid #000;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                font-weight: bold;
                color: #000;
                text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
            ">${label}</div>
        `;

        const icon = L.divIcon({
            className: 'l2-marker',
            html: markerHtml,
            iconSize: [size, size],
            iconAnchor: [size/2, size/2]
        });
        
        // Popup com todos os dados dispon√≠veis
        let popupContent = `<b>üìä Dados L2 (GOES)</b><br>`;
        popupContent += `<b>Lat:</b> ${lat.toFixed(3)}¬∞<br>`;
        popupContent += `<b>Lon:</b> ${lon.toFixed(3)}¬∞<br>`;
        popupContent += `<hr style="margin:4px 0;border-color:#444;">`;
        
        // Adicionar dados espec√≠ficos do ponto
        if (point.CAPE !== undefined) popupContent += `<b>‚ö° CAPE:</b> ${point.CAPE.toFixed(0)} J/kg<br>`;
        if (point.LI !== undefined) popupContent += `<b>üå°Ô∏è LI:</b> ${point.LI.toFixed(1)} K<br>`;
        if (point.KI !== undefined) popupContent += `<b>üìà K-Index:</b> ${point.KI.toFixed(1)}<br>`;
        if (point.TT !== undefined) popupContent += `<b>üìä TT-Index:</b> ${point.TT.toFixed(1)}<br>`;
        if (point.TPW !== undefined) popupContent += `<b>üíß TPW:</b> ${point.TPW.toFixed(1)} mm<br>`;
        if (point.HT !== undefined) popupContent += `<b>‚òÅÔ∏è Altura:</b> ${(point.HT/1000).toFixed(1)} km<br>`;
        if (point.Phase !== undefined) {
            const phaseLabels = ['C√©u Limpo', '√Ågua', 'Super-resfriada', 'Mista', 'Gelo', 'Incerto'];
            popupContent += `<b>üßä Fase:</b> ${phaseLabels[Math.floor(point.Phase)] || 'N/A'}<br>`;
        }
        if (point.DQF !== undefined) {
            const dqfLabels = ['‚úÖ √ìtimo', '‚ö†Ô∏è Degradado', '‚ùå Ruim'];
            popupContent += `<b>üìã DQF:</b> ${dqfLabels[point.DQF] || point.DQF}<br>`;
        }

        return L.marker([lat, lon], { icon: icon })
            .bindPopup(popupContent);
    }

    // =========================================================================
    // RENDERIZA√á√ÉO DE √ÅREA UNIFICADA COM GRADIENTE (Canvas Overlay)
    // =========================================================================
    
    // Extens√£o do Leaflet para Canvas Layer
    L.CanvasLayer = L.Layer.extend({
        initialize: function(options) {
            L.setOptions(this, options);
            this._canvas = null;
            this._ctx = null;
        },
        
        onAdd: function(map) {
            this._map = map;
            
            // Criar canvas
            this._canvas = L.DomUtil.create('canvas', 'leaflet-canvas-layer');
            const size = map.getSize();
            this._canvas.width = size.x;
            this._canvas.height = size.y;
            this._canvas.style.position = 'absolute';
            this._canvas.style.top = '0';
            this._canvas.style.left = '0';
            this._canvas.style.pointerEvents = 'none';
            this._canvas.style.zIndex = '250';
            
            this._ctx = this._canvas.getContext('2d');
            
            map.getPanes().overlayPane.appendChild(this._canvas);
            
            map.on('moveend', this._reset, this);
            map.on('zoomend', this._reset, this);
            map.on('resize', this._resize, this);
            
            this._reset();
        },
        
        onRemove: function(map) {
            L.DomUtil.remove(this._canvas);
            map.off('moveend', this._reset, this);
            map.off('zoomend', this._reset, this);
            map.off('resize', this._resize, this);
        },
        
        _resize: function() {
            const size = this._map.getSize();
            this._canvas.width = size.x;
            this._canvas.height = size.y;
            this._reset();
        },
        
        _reset: function() {
            const topLeft = this._map.containerPointToLayerPoint([0, 0]);
            L.DomUtil.setPosition(this._canvas, topLeft);
            this.draw();
        },
        
        draw: function() {
            if (this.options.drawCallback) {
                this.options.drawCallback(this._canvas, this._ctx, this._map);
            }
        },
        
        getCanvas: function() {
            return this._canvas;
        },
        
        getContext: function() {
            return this._ctx;
        }
    });
    
    // Interpola√ß√£o IDW (Inverse Distance Weighting)
    function idwInterpolation(x, y, points, variable, power = 2) {
        let numerator = 0;
        let denominator = 0;
        
        for (const point of points) {
            const value = point[variable];
            if (value === undefined || value === null) continue;
            
            const dx = x - point.lon;
            const dy = y - point.lat;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 0.0001) {
                return value; // Ponto exato
            }
            
            const weight = 1 / Math.pow(dist, power);
            numerator += weight * value;
            denominator += weight;
        }
        
        return denominator > 0 ? numerator / denominator : null;
    }
    
    // Desenhar √°rea com gradiente usando IDW
    function drawL2GradientArea(canvas, ctx, map) {
        if (!l2Data || !l2Enabled) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
        }
        
        const selectedVar = document.getElementById('l2-variable').value;
        
        // Encontrar produto correto
        let productKey = null;
        if (selectedVar === 'CAPE' || selectedVar === 'LI' || selectedVar === 'KI' || selectedVar === 'TT' || selectedVar === 'SI') {
            productKey = 'DSIF';
        } else if (selectedVar === 'TPW') {
            productKey = 'TPWF';
        } else if (selectedVar === 'HT') {
            productKey = 'ACHAF';
        } else if (selectedVar === 'Phase') {
            productKey = 'ACTPF';
        }
        
        if (!productKey || !l2Data.products[productKey] || !l2Data.products[productKey].data) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
        }
        
        const points = l2Data.products[productKey].data;
        if (points.length === 0) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
        }
        
        // Limpar canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Definir bounds baseado no c√≠rculo de interesse
        const centerLat = CONFIG.shipLat;
        const centerLon = CONFIG.shipLon;
        const radiusDeg = RAIO_VISUAL_GRAUS;
        
        // Resolu√ß√£o do grid para interpola√ß√£o (quanto menor, mais suave)
        const resolution = 4; // pixels por c√©lula
        
        // Criar imagem de dados
        const imageData = ctx.createImageData(canvas.width, canvas.height);
        const data = imageData.data;
        
        // Para cada pixel do canvas
        for (let py = 0; py < canvas.height; py += resolution) {
            for (let px = 0; px < canvas.width; px += resolution) {
                // Converter pixel para lat/lon
                const point = map.containerPointToLatLng([px, py]);
                const lat = point.lat;
                const lon = point.lng;
                
                // Verificar se est√° dentro do c√≠rculo de interesse
                const distFromCenter = Math.sqrt(
                    Math.pow(lat - centerLat, 2) + 
                    Math.pow(lon - centerLon, 2)
                );
                
                if (distFromCenter > radiusDeg * 1.1) continue; // Fora do c√≠rculo
                
                // Interpolar valor neste ponto
                const value = idwInterpolation(lon, lat, points, selectedVar, 2);
                
                if (value === null) continue;
                
                // Debug: log alguns valores para verificar interpola√ß√£o
                if (Math.random() < 0.001) {
                    console.log(`[L2 Canvas] ${selectedVar} em (${lat.toFixed(2)}, ${lon.toFixed(2)}): valor=${value.toFixed(1)}`);
                }
                
                // Obter cor do gradiente
                const color = getL2Color(selectedVar, value);
                
                // Extrair RGB da cor
                let r, g, b;
                if (color.startsWith('rgb')) {
                    const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (match) {
                        r = parseInt(match[1]);
                        g = parseInt(match[2]);
                        b = parseInt(match[3]);
                    }
                } else if (color.startsWith('#')) {
                    r = parseInt(color.slice(1, 3), 16);
                    g = parseInt(color.slice(3, 5), 16);
                    b = parseInt(color.slice(5, 7), 16);
                }
                
                if (r === undefined) continue;
                
                // Calcular opacidade baseada na INTENSIDADE do valor
                const intensityFactor = getL2IntensityOpacity(selectedVar, value);
                
                // Opacidade final = slider * intensidade (valores baixos ficam mais transparentes)
                const baseAlpha = Math.round(l2Opacity * 2.55 * intensityFactor);
                let alpha = baseAlpha;
                
                // Fade nas bordas do c√≠rculo
                if (distFromCenter > radiusDeg * 0.8) {
                    const fadeFactor = (radiusDeg * 1.1 - distFromCenter) / (radiusDeg * 0.3);
                    alpha = Math.max(0, Math.min(baseAlpha, baseAlpha * fadeFactor));
                }
                
                // Preencher bloco de pixels
                for (let dy = 0; dy < resolution && py + dy < canvas.height; dy++) {
                    for (let dx = 0; dx < resolution && px + dx < canvas.width; dx++) {
                        const idx = ((py + dy) * canvas.width + (px + dx)) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = alpha;
                    }
                }
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Desenhar borda do c√≠rculo
        const centerPoint = map.latLngToContainerPoint([centerLat, centerLon]);
        const edgePoint = map.latLngToContainerPoint([centerLat + radiusDeg, centerLon]);
        const radiusPixels = Math.abs(edgePoint.y - centerPoint.y);
        
        ctx.beginPath();
        ctx.arc(centerPoint.x, centerPoint.y, radiusPixels, 0, 2 * Math.PI);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Criar ou atualizar canvas layer
    function updateL2CanvasLayer() {
        if (!l2Enabled || l2DisplayMode !== 'area') {
            if (l2CanvasLayer) {
                map.removeLayer(l2CanvasLayer);
                l2CanvasLayer = null;
            }
            return;
        }
        
        if (!l2CanvasLayer) {
            l2CanvasLayer = new L.CanvasLayer({
                drawCallback: drawL2GradientArea
            });
            l2CanvasLayer.addTo(map);
        } else {
            l2CanvasLayer.draw();
        }
    }
    
    // Alternar modo de exibi√ß√£o
    function toggleL2DisplayMode(mode) {
        l2DisplayMode = mode;
        
        // Atualizar bot√µes
        document.getElementById('btn-l2-area').classList.toggle('active', mode === 'area');
        document.getElementById('btn-l2-markers').classList.toggle('active', mode === 'markers');
        
        if (mode === 'area') {
            // Limpar marcadores
            if (l2Layer) {
                l2Layer.clearLayers();
            }
            l2Markers = [];
            updateL2CanvasLayer();
            log('info', 'üé® L2: Modo √°rea com gradiente');
        } else {
            // Remover canvas
            if (l2CanvasLayer) {
                map.removeLayer(l2CanvasLayer);
                l2CanvasLayer = null;
            }
            updateL2Display();
            log('info', '‚≠ï L2: Modo marcadores');
        }
    }
    
    // Criar legenda din√¢mica para a vari√°vel selecionada
    function createL2Legend(variable) {
        const legendDiv = document.getElementById('l2-legend-cape');
        if (!legendDiv) return;
        
        let colorStops, title, unit;
        
        switch(variable) {
            case 'CAPE':
                colorStops = CAPE_COLORS;
                title = '‚ö° CAPE';
                unit = 'J/kg';
                break;
            case 'LI':
                colorStops = LI_COLORS;
                title = 'üå°Ô∏è Lifted Index';
                unit = 'K';
                break;
            case 'TPW':
                colorStops = TPW_COLORS;
                title = 'üíß TPW';
                unit = 'mm';
                break;
            case 'HT':
                colorStops = HT_COLORS;
                title = '‚òÅÔ∏è Altura';
                unit = 'm';
                break;
            default:
                legendDiv.style.display = 'none';
                return;
        }
        
        // Criar gradiente CSS
        const gradientColors = colorStops.map((stop, i) => {
            const percent = (i / (colorStops.length - 1)) * 100;
            return `${stop.color} ${percent}%`;
        }).join(', ');
        
        legendDiv.innerHTML = `
            <div style="background:#111; padding:8px; border-radius:4px; margin-top:8px; border:1px solid #333;">
                <div style="font-size:10px; color:#888; margin-bottom:4px;">${title} (${unit})</div>
                <div style="display:flex; align-items:center; gap:6px;">
                    <span style="font-size:9px; color:#666;">${colorStops[0].value}</span>
                    <div style="flex:1; height:12px; background: linear-gradient(to right, ${gradientColors}); border-radius:2px;"></div>
                    <span style="font-size:9px; color:#666;">${colorStops[colorStops.length-1].value}</span>
                </div>
            </div>
        `;
        legendDiv.style.display = 'block';
    }

    // Fun√ß√£o para ligar/desligar auto-extra√ß√£o
    function toggleAutoExtract(enabled) {
        autoExtractEnabled = enabled;
        
        // Atualizar bot√µes
        document.getElementById('btn-autoextract-on').classList.toggle('active', enabled);
        document.getElementById('btn-autoextract-off').classList.toggle('active', !enabled);
        
        if (enabled) {
            log('success', '‚úÖ Auto-extra√ß√£o de sat√©lite LIGADA (verifica a cada 5 min)');
        } else {
            log('warning', '‚ùå Auto-extra√ß√£o de sat√©lite DESLIGADA');
        }
    }
    
    function selectSatellite(satId) {
        currentSatellite = satId;
        
        // Atualizar bot√µes
        document.querySelectorAll('.toggle-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById('btn-' + satId).classList.add('active');
        
        // Atualizar nome no t√≠tulo
        const nameEl = document.getElementById('satellite-name');
        if (nameEl) {
            nameEl.textContent = satId === 'goes19' ? 'GOES-19' : 'GOES-16';
        }
        
        // Carregar novo sat√©lite
        loadSatelliteLayer();
        log('info', `üõ∞Ô∏è Sat√©lite alterado para ${satId.toUpperCase()}`);
    }
    
    // =========================================================================
    // REPROJE√á√ÉO REAL - GOES Full Disk para Web Mercator
    // =========================================================================
    
    // REPROJECTION_BOUNDS j√° definido acima, pr√≥ximo ao CONFIG
    
    // Fun√ß√£o para gerar URL da imagem Full Disk
    function getFullDiskUrl(satellite, product) {
        const sat = satellite.toUpperCase();
        return `https://cdn.star.nesdis.noaa.gov/${sat}/ABI/FD/${product}/5424x5424.jpg`;
    }
    
    // FUN√á√ïES DE PROJE√á√ÉO WEB MERCATOR (EPSG:3857)
    const EARTH_RADIUS = 6378137;
    
    function lonToMercatorX(lon) {
        return lon * Math.PI / 180 * EARTH_RADIUS;
    }
    
    function latToMercatorY(lat) {
        const latClamped = Math.max(-85, Math.min(85, lat));
        const latRad = latClamped * Math.PI / 180;
        return Math.log(Math.tan(Math.PI / 4 + latRad / 2)) * EARTH_RADIUS;
    }
    
    function mercatorXToLon(x) {
        return x / EARTH_RADIUS * 180 / Math.PI;
    }
    
    function mercatorYToLat(y) {
        return (2 * Math.atan(Math.exp(y / EARTH_RADIUS)) - Math.PI / 2) * 180 / Math.PI;
    }
    
    // GOES-R ABI Fixed Grid - converte lat/lon para coordenadas de scan
    function latLonToScan(lat, lon, sat_lon) {
        const DEG2RAD = Math.PI / 180;
        const req = 6378137.0;
        const rpol = 6356752.31414;
        const H = 42164160.0;
        const e2 = 1 - (rpol * rpol) / (req * req);
        
        const lat_rad = lat * DEG2RAD;
        const lon_rad = lon * DEG2RAD;
        const sat_lon_rad = sat_lon * DEG2RAD;
        
        const lat_geo = Math.atan((rpol * rpol / (req * req)) * Math.tan(lat_rad));
        const rc = rpol / Math.sqrt(1 - e2 * Math.cos(lat_geo) * Math.cos(lat_geo));
        const dlon = lon_rad - sat_lon_rad;
        
        const sx = H - rc * Math.cos(lat_geo) * Math.cos(dlon);
        const sy = -rc * Math.cos(lat_geo) * Math.sin(dlon);
        const sz = rc * Math.sin(lat_geo);
        
        const dlon_deg = Math.abs(lon - sat_lon);
        if (dlon_deg > 81 || Math.abs(lat) > 81) return null;
        
        const sn = Math.sqrt(sx * sx + sy * sy + sz * sz);
        const x = Math.asin(-sy / sn);
        const y = Math.atan(sz / sx);
        
        return { x, y };
    }
    
    // Interpola√ß√£o bilinear para qualidade
    function bilinearInterpolate(srcData, x, y) {
        const x0 = Math.floor(x);
        const y0 = Math.floor(y);
        const x1 = Math.min(x0 + 1, srcData.width - 1);
        const y1 = Math.min(y0 + 1, srcData.height - 1);
        
        const fx = x - x0;
        const fy = y - y0;
        
        const w00 = (1 - fx) * (1 - fy);
        const w10 = fx * (1 - fy);
        const w01 = (1 - fx) * fy;
        const w11 = fx * fy;
        
        const i00 = (y0 * srcData.width + x0) * 4;
        const i10 = (y0 * srcData.width + x1) * 4;
        const i01 = (y1 * srcData.width + x0) * 4;
        const i11 = (y1 * srcData.width + x1) * 4;
        
        return {
            r: Math.round(srcData.data[i00] * w00 + srcData.data[i10] * w10 + srcData.data[i01] * w01 + srcData.data[i11] * w11),
            g: Math.round(srcData.data[i00+1] * w00 + srcData.data[i10+1] * w10 + srcData.data[i01+1] * w01 + srcData.data[i11+1] * w11),
            b: Math.round(srcData.data[i00+2] * w00 + srcData.data[i10+2] * w10 + srcData.data[i01+2] * w01 + srcData.data[i11+2] * w11)
        };
    }
    
    // Carregar imagem com Promise
    function loadImageAsync(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error('Falha ao carregar imagem'));
            img.src = url;
        });
    }
    
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    
    function setReprojectionProgress(pct, text) {
        const bar = document.getElementById('satellite-progress-bar');
        const txt = document.getElementById('satellite-progress-text');
        const container = document.getElementById('satellite-progress');
        if (bar) bar.style.width = pct + '%';
        if (txt) txt.textContent = text || (Math.round(pct) + '%');
        if (container) container.style.display = 'block';
    }
    
    function hideReprojectionProgress() {
        const container = document.getElementById('satellite-progress');
        if (container) container.style.display = 'none';
    }
    
    // Fun√ß√£o para verificar timestamp da imagem no servidor
    async function checkSatelliteTimestamp(satellite, product) {
        try {
            const url = getFullDiskUrl(satellite, product);
            // Fazer HEAD request para pegar Last-Modified
            const response = await fetch(url, { method: 'HEAD', mode: 'cors' });
            const lastModified = response.headers.get('Last-Modified');
            if (lastModified) {
                return new Date(lastModified);
            }
            // Fallback: usar timestamp atual
            return new Date();
        } catch (e) {
            console.warn('N√£o foi poss√≠vel verificar timestamp:', e);
            return null;
        }
    }
    
    // Fun√ß√£o para verificar se precisa atualizar a imagem
    async function shouldLoadSatellite(forceLoad = false) {
        if (forceLoad) return true;
        if (!satelliteLayer) return true;  // N√£o tem imagem carregada
        if (!currentSatelliteTimestamp) return true;  // N√£o sabe o hor√°rio
        
        const satId = currentSatellite;
        const product = document.getElementById('satellite-product')?.value || 'GEOCOLOR';
        
        try {
            const serverTimestamp = await checkSatelliteTimestamp(satId, product);
            if (serverTimestamp && serverTimestamp > currentSatelliteTimestamp) {
                log('info', `üîÑ Nova imagem dispon√≠vel: ${serverTimestamp.toLocaleTimeString()}`);
                return true;
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    // FUN√á√ÉO PRINCIPAL: Carregar sat√©lite com reproje√ß√£o real
    async function loadSatelliteWithReprojection(forceLoad = true) {
        // Verificar se j√° est√° carregando
        if (isLoadingSatellite) {
            log('warning', '‚è≥ J√° existe um carregamento em andamento...');
            return;
        }
        
        // Verificar se precisa carregar (a menos que seja for√ßado)
        if (!forceLoad) {
            const needsLoad = await shouldLoadSatellite(false);
            if (!needsLoad) {
                log('info', '‚úì Imagem de sat√©lite est√° atualizada');
                return;
            }
        }
        
        const satId = currentSatellite;
        const product = document.getElementById('satellite-product')?.value || 'GEOCOLOR';
        const quality = document.getElementById('satellite-quality')?.value || 'medium';
        const opacity = (document.getElementById('satellite-opacity')?.value || 75) / 100;
        
        isLoadingSatellite = true;
        setStatus('satellite-status', 'loading');
        log('info', `üõ∞Ô∏è Iniciando reproje√ß√£o REAL: ${satId.toUpperCase()} - ${product}`);
        setReprojectionProgress(5, 'Iniciando...');
        
        try {
            // N√ÉO remover camada anterior - manter vis√≠vel enquanto carrega nova
            
            // URL da imagem Full Disk
            const url = getFullDiskUrl(satId, product);
            log('info', `üì° Carregando imagem Full Disk...`);
            setReprojectionProgress(10, 'Baixando imagem...');
            
            // Carregar imagem
            const img = await loadImageAsync(url + '?t=' + Date.now());
            log('info', `‚úÖ Imagem carregada: ${img.width}x${img.height}`);
            setReprojectionProgress(30, 'Imagem carregada');
            
            // Configura√ß√µes de qualidade
            const qualitySettings = {
                low: { width: 600, interpolate: false },
                medium: { width: 1200, interpolate: true },
                high: { width: 2400, interpolate: true },
                max: { width: 4800, interpolate: true }
            };
            const settings = qualitySettings[quality] || qualitySettings.medium;
            
            log('info', `üîÑ Reprojetando (${quality}: ${settings.width}px)...`);
            setReprojectionProgress(35, `Reprojetando (${quality})...`);
            
            // Bounds para reproje√ß√£o
            const bounds = REPROJECTION_BOUNDS;
            
            // Converter bounds para Web Mercator
            const mercBounds = {
                minX: lonToMercatorX(bounds.west),
                maxX: lonToMercatorX(bounds.east),
                minY: latToMercatorY(bounds.south),
                maxY: latToMercatorY(bounds.north)
            };
            
            // Canvas de sa√≠da
            const outWidth = settings.width;
            const outHeight = Math.round(outWidth * (mercBounds.maxY - mercBounds.minY) / (mercBounds.maxX - mercBounds.minX));
            
            const canvas = document.createElement('canvas');
            canvas.width = outWidth;
            canvas.height = outHeight;
            const ctx = canvas.getContext('2d');
            
            // Canvas fonte
            const srcCanvas = document.createElement('canvas');
            srcCanvas.width = img.width;
            srcCanvas.height = img.height;
            const srcCtx = srcCanvas.getContext('2d');
            srcCtx.drawImage(img, 0, 0);
            const srcData = srcCtx.getImageData(0, 0, img.width, img.height);
            
            // Canvas destino
            const outData = ctx.createImageData(outWidth, outHeight);
            
            // GOES-East longitude
            const sat_lon = -75.0;
            
            // Par√¢metros da imagem Full Disk
            const scanMax = 0.1518;
            const imgRadius = Math.min(img.width, img.height) / 2;
            const scale = imgRadius / scanMax;
            const centerX = img.width / 2;
            const centerY = img.height / 2;
            
            let pixelsVisible = 0;
            
            // Loop de reproje√ß√£o
            for (let y = 0; y < outHeight; y++) {
                for (let x = 0; x < outWidth; x++) {
                    const mercX = mercBounds.minX + (x / outWidth) * (mercBounds.maxX - mercBounds.minX);
                    const mercY = mercBounds.maxY - (y / outHeight) * (mercBounds.maxY - mercBounds.minY);
                    
                    const lon = mercatorXToLon(mercX);
                    const lat = mercatorYToLat(mercY);
                    
                    const scan = latLonToScan(lat, lon, sat_lon);
                    if (!scan) continue;
                    
                    const srcX = centerX + scan.x * scale;
                    const srcY = centerY - scan.y * scale;
                    
                    if (srcX < 0 || srcX >= img.width - 1 || srcY < 0 || srcY >= img.height - 1) continue;
                    
                    let r, g, b;
                    if (settings.interpolate) {
                        const pixel = bilinearInterpolate(srcData, srcX, srcY);
                        r = pixel.r; g = pixel.g; b = pixel.b;
                    } else {
                        const sx = Math.floor(srcX);
                        const sy = Math.floor(srcY);
                        const srcIdx = (sy * srcData.width + sx) * 4;
                        r = srcData.data[srcIdx];
                        g = srcData.data[srcIdx + 1];
                        b = srcData.data[srcIdx + 2];
                    }
                    
                    const idx = (y * outWidth + x) * 4;
                    outData.data[idx] = r;
                    outData.data[idx + 1] = g;
                    outData.data[idx + 2] = b;
                    outData.data[idx + 3] = 255;
                    pixelsVisible++;
                }
                
                // Atualizar progresso
                if (y % 50 === 0) {
                    setReprojectionProgress(35 + (y / outHeight) * 60, `Reprojetando... ${Math.round(y / outHeight * 100)}%`);
                    await sleep(1);
                }
            }
            
            log('info', `üìä Reproje√ß√£o completa: ${pixelsVisible} pixels`);
            setReprojectionProgress(95, 'Finalizando...');
            
            ctx.putImageData(outData, 0, 0);
            
            // Criar overlay (em mem√≥ria primeiro)
            const dataUrl = canvas.toDataURL('image/png');
            const leafletBounds = [[bounds.south, bounds.west], [bounds.north, bounds.east]];
            
            // Criar nova camada em background
            const newLayer = L.imageOverlay(dataUrl, leafletBounds, {
                opacity: opacity,
                zIndex: 1
            });
            
            // Pr√©-carregar imagem antes de exibir
            const preloadImg = new Image();
            preloadImg.src = dataUrl;
            await new Promise((resolve) => {
                preloadImg.onload = resolve;
                preloadImg.onerror = resolve;
            });
            
            // Capturar timestamp da imagem
            const imageTimestamp = new Date();
            try {
                const serverTs = await checkSatelliteTimestamp(satId, product);
                if (serverTs) currentSatelliteTimestamp = serverTs;
                else currentSatelliteTimestamp = imageTimestamp;
            } catch (e) {
                currentSatelliteTimestamp = imageTimestamp;
            }
            
            // AGORA sim: remover camada antiga e adicionar nova (troca suave)
            if (satelliteLayer) {
                map.removeLayer(satelliteLayer);
            }
            satelliteLayer = newLayer;
            satelliteLayer.addTo(map);
            
            setReprojectionProgress(100, 'Conclu√≠do!');
            setTimeout(hideReprojectionProgress, 1000);
            
            // Atualizar info com timestamp do arquivo
            const infoEl = document.getElementById('satellite-info');
            const timestampStr = currentSatelliteTimestamp ? 
                currentSatelliteTimestamp.toLocaleString('pt-BR', { 
                    day: '2-digit', month: '2-digit', year: 'numeric',
                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                }) : 'N/A';
            if (infoEl) {
                infoEl.innerHTML = `üì° ${satId.toUpperCase()} ${product}<br>üîÑ Reproje√ß√£o REAL (${quality})<br>üìä ${pixelsVisible.toLocaleString()} pixels<br>üïê Arquivo: ${timestampStr}<br>‚è∞ Carregado: ${new Date().toLocaleTimeString()}`;
            }
            
            log('success', `‚úÖ Reproje√ß√£o conclu√≠da: ${satId.toUpperCase()} ${product}`);
            log('info', `üïê Hor√°rio do arquivo: ${timestampStr}`);
            setStatus('satellite-status', 'active');
            isLoadingSatellite = false;  // Liberar flag
            
        } catch (error) {
            log('error', `‚ùå Erro: ${error.message}`);
            console.error('‚ùå [REPROJECTION] Erro:', error);
            setStatus('satellite-status', 'error');
            hideReprojectionProgress();
            isLoadingSatellite = false;  // Liberar flag em caso de erro
        }
    }
    
    // Fun√ß√£o legada para compatibilidade - carrega s√≥ se necess√°rio ou se n√£o tiver imagem
    async function loadSatelliteLayer() {
        // Na inicializa√ß√£o, carregar se n√£o tiver imagem
        if (!satelliteLayer) {
            await loadSatelliteWithReprojection(true);
        } else {
            // Verificar se h√° imagem mais recente
            await loadSatelliteWithReprojection(false);
        }
    }
    
    function updateSatelliteOpacity(value) {
        document.getElementById('opacity-value').textContent = value + '%';
        if (satelliteLayer) {
            satelliteLayer.setOpacity(value / 100);
        }
    }
    
    function toggleSatelliteLayer() {
        satelliteEnabled = !satelliteEnabled;
        if (satelliteEnabled) {
            loadSatelliteLayer();
            log('info', 'üõ∞Ô∏è Camada de sat√©lite ativada');
        } else {
            if (satelliteLayer) map.removeLayer(satelliteLayer);
            setStatus('satellite-status', '');
            log('info', 'üõ∞Ô∏è Camada de sat√©lite desativada');
        }
    }
    
    // =========================================================================
    // GRADE DE COORDENADAS
    // =========================================================================
    function createGrid() {
        for (let lat = -30; lat <= -15; lat += 1) {
            L.polyline([[lat, CONFIG.lonMin - 2], [lat, CONFIG.lonMax + 2]], {
                color: '#333',
                weight: 1,
                opacity: 0.5
            }).addTo(gridLayer);
            
            L.marker([lat, CONFIG.lonMin - 1], {
                icon: L.divIcon({
                    className: 'grid-label',
                    html: `<span style="color:#666;font-size:10px">${lat}¬∞</span>`
                })
            }).addTo(gridLayer);
        }
        
        for (let lon = -50; lon <= -35; lon += 1) {
            L.polyline([[CONFIG.latMin - 2, lon], [CONFIG.latMax + 2, lon]], {
                color: '#333',
                weight: 1,
                opacity: 0.5
            }).addTo(gridLayer);
        }
    }
    
    // =========================================================================
    // TOGGLE DE CAMADAS
    // =========================================================================
    function toggleLayer(layer) {
        const checkbox = document.getElementById(`layer-${layer}`);
        switch(layer) {
            case 'arrows':
                if (checkbox.checked) windLayerGroup.addTo(map);
                else map.removeLayer(windLayerGroup);
                break;
            case 'grid':
                if (checkbox.checked) gridLayer.addTo(map);
                else map.removeLayer(gridLayer);
                break;
        }
    }
    
    // =========================================================================
    // BUSCAR DADOS - NOAA ERDDAP (GRATUITO!)
    // =========================================================================
    
    // Lista de datasets NOAA ERDDAP dispon√≠veis (em ordem de prefer√™ncia)
    const NOAA_DATASETS = [
        {
            id: 'erdQCwindproducts1day',
            name: 'MetOp-C ASCAT 1-Day (2020-presente)',
            vars: ['wind_speed', 'wind_direction']
        },
        {
            id: 'erdQCwindproducts3day',
            name: 'MetOp-C ASCAT 3-Day Composite',
            vars: ['wind_speed', 'wind_direction']
        },
        {
            id: 'erdNavgem05D10mWind',
            name: 'NAVGEM 0.5¬∞ 10m Wind (modelo)',
            vars: ['u_wind', 'v_wind']
        }
    ];
    
    async function fetchNOAAData() {
        setStatus('noaa-status', 'loading');
        log('info', 'üì° Buscando dados NOAA ERDDAP (ASCAT Metop-C)...');
        
        const baseUrl = 'https://coastwatch.pfeg.noaa.gov/erddap/griddap';
        
        // Tentar datasets em ordem de prefer√™ncia
        for (const dataset of NOAA_DATASETS) {
            log('info', `üîç Tentando: ${dataset.name}...`);
            
            // Dados de sat√©lite t√™m atraso de ~24h no processamento
            // Buscar de 4 dias atr√°s at√© 1 dia atr√°s
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000);
            const fourDaysAgo = new Date(now.getTime() - 4 * 24 * 60 * 60 * 1000);
            
            const startTime = fourDaysAgo.toISOString().split('.')[0] + 'Z';
            const endTime = oneDayAgo.toISOString().split('.')[0] + 'Z';
            
            // Construir URL baseado nas vari√°veis do dataset
            // Nota: erdQCwindproducts tem dimens√£o altitude (10m)
            let erddapUrl;
            if (dataset.vars.includes('wind_speed')) {
                // Dataset com wind_speed e wind_direction diretos (com altitude)
                erddapUrl = `${baseUrl}/${dataset.id}.json?` +
                    `wind_speed[(${startTime}):1:(${endTime})]` +
                    `[(10.0)]` +  // altitude 10m
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]` +
                    `,wind_direction[(${startTime}):1:(${endTime})]` +
                    `[(10.0)]` +  // altitude 10m
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]`;
            } else {
                // Dataset com componentes u/v (pode ter altitude ou n√£o)
                erddapUrl = `${baseUrl}/${dataset.id}.json?` +
                    `${dataset.vars[0]}[(${startTime}):1:(${endTime})]` +
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]` +
                    `,${dataset.vars[1]}[(${startTime}):1:(${endTime})]` +
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]`;
            }
            
            try {
                // Usar proxy local para evitar CORS
                const url = `/api/noaa?url=${encodeURIComponent(erddapUrl)}`;
                log('info', 'Buscando via proxy local...');
                
                const response = await fetch(url, { timeout: 30000 });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    log('warning', `Dataset ${dataset.id} indispon√≠vel: ${response.status} - ${errorData.reason || ''}`);
                    continue; // Tentar pr√≥ximo dataset
                }
                
                const data = await response.json();
                
                // Verificar se h√° dados v√°lidos
                if (data && data.table && data.table.rows && data.table.rows.length > 0) {
                    log('success', `‚úÖ Dados obtidos de ${dataset.name}: ${data.table.rows.length} pontos`);
                    processNOAAData(data, dataset.vars.includes('wind_speed'));
                    setStatus('noaa-status', 'active');
                    return; // Sucesso!
                } else {
                    log('warning', `Dataset ${dataset.id} sem dados para a √°rea/per√≠odo`);
                }
                
            } catch (error) {
                log('warning', `Erro no dataset ${dataset.id}: ${error.message}`);
                continue; // Tentar pr√≥ximo
            }
        }
        
        // Se todos falharam, usar Open-Meteo como fallback
        log('warning', '‚ö†Ô∏è Nenhum dataset NOAA dispon√≠vel, usando Open-Meteo como fallback');
        setStatus('noaa-status', 'error');
        await fetchOpenMeteoWindGrid();
    }
    
    // Fallback: buscar grid de vento do Open-Meteo
    async function fetchOpenMeteoWindGrid() {
        log('info', 'üîÑ Buscando grid de vento Open-Meteo...');
        
        // Criar grid de pontos na √°rea
        const lats = [];
        const lons = [];
        const step = 0.5;
        
        for (let lat = CONFIG.latMin; lat <= CONFIG.latMax; lat += step) {
            lats.push(lat.toFixed(2));
        }
        for (let lon = CONFIG.lonMin; lon <= CONFIG.lonMax; lon += step) {
            lons.push(lon.toFixed(2));
        }
        
        // Criar todas as combina√ß√µes
        const queryLats = [];
        const queryLons = [];
        for (const lat of lats) {
            for (const lon of lons) {
                queryLats.push(lat);
                queryLons.push(lon);
            }
        }
        
        // Limitar a 50 pontos (limite da API)
        const maxPoints = 50;
        const selectedLats = queryLats.slice(0, maxPoints);
        const selectedLons = queryLons.slice(0, maxPoints);
        
        const url = `https://api.open-meteo.com/v1/forecast?` +
            `latitude=${selectedLats.join(',')}&` +
            `longitude=${selectedLons.join(',')}&` +
            `current=wind_speed_10m,wind_direction_10m&` +
            `wind_speed_unit=kn`;
        
        try {
            const response = await fetch(url);
            const data = await response.json();
            
            let count = 0;
            if (Array.isArray(data)) {
                data.forEach(point => {
                    if (point.current) {
                        addWindPoint({
                            lat: point.latitude,
                            lon: point.longitude,
                            speed: point.current.wind_speed_10m,
                            direction: point.current.wind_direction_10m,
                            time: new Date(),
                            source: 'Open-Meteo Grid'
                        });
                        count++;
                    }
                });
            } else if (data.current) {
                addWindPoint({
                    lat: data.latitude,
                    lon: data.longitude,
                    speed: data.current.wind_speed_10m,
                    direction: data.current.wind_direction_10m,
                    time: new Date(),
                    source: 'Open-Meteo Grid'
                });
                count = 1;
            }
            
            log('success', `‚úÖ Grid Open-Meteo: ${count} pontos`);
            updateWindDisplay();
            setStatus('noaa-status', 'active');
            
        } catch (error) {
            log('error', `Erro Open-Meteo Grid: ${error.message}`);
        }
    }
    
    // =========================================================================
    // OPEN-METEO (MULTI-MODELO) COM PESOS DIN√ÇMICOS
    // =========================================================================
    
    // Lista de modelos dispon√≠veis
    const MODELS = ['gfs_seamless', 'ecmwf_ifs025', 'icon_seamless', 'meteofrance_seamless', 'jma_seamless'];
    const MODEL_NAMES = {
        'gfs_seamless': 'GFS',
        'ecmwf_ifs025': 'ECMWF', 
        'icon_seamless': 'ICON',
        'meteofrance_seamless': 'MeteoFR',
        'jma_seamless': 'JMA'
    };
    
    // Armazena dados de todos os modelos
    let modelData = {};
    MODELS.forEach(m => modelData[m] = { speed: null, direction: null });
    
    // Pesos din√¢micos SEPARADOS para velocidade e dire√ß√£o
    let modelSpeedWeights = {};
    let modelDirWeights = {};
    MODELS.forEach(m => {
        modelSpeedWeights[m] = 1 / MODELS.length;
        modelDirWeights[m] = 1 / MODELS.length;
    });
    
    // Peso combinado (para compatibilidade)
    let modelWeights = {};
    MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
    
    // =========================================================================
    // SISTEMA DE CALIBRA√á√ÉO CUMULATIVA
    // =========================================================================
    // Estat√≠sticas cumulativas por modelo - SEPARADO POR VELOCIDADE E DIRE√á√ÉO
    let modelStats = {};
    MODELS.forEach(m => modelStats[m] = { 
        totalComparisons: 0,   // N√∫mero de compara√ß√µes
        // Velocidade
        speedCorrectCount: 0,  // Acertos de velocidade
        speedWrongCount: 0,    // Erros de velocidade
        speedScore: 0,         // Score acumulado de velocidade (soma dos pesos)
        // Dire√ß√£o
        dirCorrectCount: 0,    // Acertos de dire√ß√£o
        dirWrongCount: 0,      // Erros de dire√ß√£o
        dirScore: 0            // Score acumulado de dire√ß√£o (soma dos pesos)
    });
    
    // Threshold para considerar "acerto" vs "erro"
    const ACCURACY_THRESHOLD_SPEED = 3;   // kt - diferen√ßa m√°xima para considerar acerto
    const ACCURACY_THRESHOLD_DIR = 20;    // graus - diferen√ßa m√°xima para considerar acerto
    
    // Fator de penalidade para erros consecutivos
    const ERROR_PENALTY_FACTOR = 1.5;     // Multiplicador de penalidade para erros
    const CORRECT_REWARD_FACTOR = 0.8;    // Fator de recupera√ß√£o para acertos
    
    // Hist√≥rico de previs√µes para compara√ß√£o
    let forecastHistory = [];
    
    // =========================================================================
    // SISTEMA DE PREVIS√ïES PENDENTES (para calibra√ß√£o real)
    // =========================================================================
    // Armazena previs√µes feitas pelos modelos para hor√°rios futuros
    // Quando esse hor√°rio chegar e tivermos dados observados, comparamos
    let pendingForecasts = [];
    const FORECAST_VALIDATION_HOURS = [1, 2, 3];  // Validar previs√µes h+1, h+2, h+3
    const FORECAST_TOLERANCE_MINUTES = 30;  // Toler√¢ncia de ¬±30 minutos
    
    // Salvar previs√µes para valida√ß√£o futura
    function savePendingForecasts() {
        const now = Date.now();
        
        FORECAST_VALIDATION_HOURS.forEach(hoursAhead => {
            const targetTime = now + hoursAhead * 60 * 60 * 1000;  // Hor√°rio alvo
            
            const forecast = {
                savedAt: now,
                targetTime: targetTime,
                hoursAhead: hoursAhead,
                validated: false,
                models: {}
            };
            
            // Salvar previs√£o de cada modelo para esse hor√°rio
            MODELS.forEach(model => {
                const data = allForecastData[model];
                if (data && data.speeds && data.speeds[hoursAhead] !== null) {
                    forecast.models[model] = {
                        speed: data.speeds[hoursAhead],
                        direction: data.directions[hoursAhead]
                    };
                }
            });
            
            // S√≥ salvar se temos dados de pelo menos 1 modelo
            if (Object.keys(forecast.models).length > 0) {
                pendingForecasts.push(forecast);
            }
        });
        
        // Limitar array (manter √∫ltimas 24 horas de previs√µes)
        const maxAge = 24 * 60 * 60 * 1000;
        pendingForecasts = pendingForecasts.filter(f => now - f.savedAt < maxAge);
        
        // Salvar no localStorage
        try {
            localStorage.setItem('pendingForecasts', JSON.stringify(pendingForecasts));
        } catch (e) {
            console.warn('Erro ao salvar pendingForecasts:', e);
        }
        
        log('info', `üìù Salvas ${FORECAST_VALIDATION_HOURS.length * MODELS.length} previs√µes pendentes (h+${FORECAST_VALIDATION_HOURS.join(', h+')})`);
    }
    
    // Carregar previs√µes pendentes do localStorage
    function loadPendingForecasts() {
        try {
            const saved = localStorage.getItem('pendingForecasts');
            if (saved) {
                pendingForecasts = JSON.parse(saved);
                // Filtrar apenas n√£o validadas e dentro da janela v√°lida
                const now = Date.now();
                pendingForecasts = pendingForecasts.filter(f => 
                    !f.validated && (now - f.savedAt < 24 * 60 * 60 * 1000)
                );
            }
        } catch (e) {
            console.warn('Erro ao carregar pendingForecasts:', e);
            pendingForecasts = [];
        }
    }
    
    // Encontrar previs√µes que correspondem ao hor√°rio da observa√ß√£o
    function findMatchingForecasts(observationTime) {
        const tolerance = FORECAST_TOLERANCE_MINUTES * 60 * 1000;  // ¬±30 min
        
        return pendingForecasts.filter(f => 
            !f.validated && 
            Math.abs(f.targetTime - observationTime) <= tolerance
        );
    }
    
    // =========================================================================
    // CALIBRA√á√ÉO COM DADOS OBSERVADOS (DMW/SCAT)
    // =========================================================================
    // Timestamps da √∫ltima calibra√ß√£o com DMW/SCAT
    let lastDMWCalibrationTimestamp = 0;   // Timestamp do DMW usado para √∫ltima calibra√ß√£o
    let lastSCATCalibrationTimestamp = 0;  // Timestamp do SCAT usado para √∫ltima calibra√ß√£o
    
    // Pesos de acur√°cia de previs√£o (comparando previs√£o vs realidade)
    // Esses pesos s√£o MULTIPLICADOS pelos pesos de calibra√ß√£o DMW/SCAT
    let modelForecastAccuracy = {};
    MODELS.forEach(m => modelForecastAccuracy[m] = { speedAccuracy: 1.0, dirAccuracy: 1.0 });
    
    // Estat√≠sticas de vetores observados
    let observedStats = {
        dmw: { count: 0, avgSpeed: null, avgDir: null, weight: 0 },
        scat: { count: 0, avgSpeed: null, avgDir: null, weight: 0 }
    };
    
    // Calcular vetores DMW dentro do raio de 20nm do navio
    function getDMWVectorsInRadius() {
        if (!dmwData || !dmwData.winds) return { count: 0, avgSpeed: null, avgDir: null };
        
        const winds = dmwData.winds;
        const radiusDeg = RAIO_OBSERVACAO_GRAUS;  // ~0.33 graus para 20nm
        let speeds = [];
        let dirs = [];
        
        for (const w of winds) {
            const latDiff = Math.abs(w.lat - CONFIG.shipLat);
            const lonDiff = Math.abs(w.lon - CONFIG.shipLon);
            
            // Aproxima√ß√£o simples de dist√¢ncia em graus
            if (latDiff <= radiusDeg && lonDiff <= radiusDeg) {
                // Filtrar pontos em terra
                if (!isOverOcean(w.lat, w.lon)) continue;
                
                speeds.push(w.speed_kt);
                if (w.direction !== null && w.direction !== undefined) {
                    dirs.push(w.direction);
                }
            }
        }
        
        if (speeds.length === 0) return { count: 0, avgSpeed: null, avgDir: null };
        
        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
        
        // M√©dia circular para dire√ß√£o
        let avgDir = null;
        if (dirs.length > 0) {
            let sinSum = 0, cosSum = 0;
            dirs.forEach(d => {
                sinSum += Math.sin(d * Math.PI / 180);
                cosSum += Math.cos(d * Math.PI / 180);
            });
            avgDir = Math.atan2(sinSum / dirs.length, cosSum / dirs.length) * 180 / Math.PI;
            if (avgDir < 0) avgDir += 360;
        }
        
        return { count: speeds.length, avgSpeed, avgDir };
    }
    
    // Calcular vetores SCAT dentro do raio de 20nm do navio
    function getSCATVectorsInRadius() {
        if (!scatData || !scatData.winds) return { count: 0, avgSpeed: null, avgDir: null };
        
        const winds = scatData.winds;
        const radiusDeg = RAIO_OBSERVACAO_GRAUS;  // ~0.33 graus para 20nm
        let speeds = [];
        let dirs = [];
        
        for (const w of winds) {
            const latDiff = Math.abs(w.lat - CONFIG.shipLat);
            const lonDiff = Math.abs(w.lon - CONFIG.shipLon);
            
            // Aproxima√ß√£o simples de dist√¢ncia em graus
            if (latDiff <= radiusDeg && lonDiff <= radiusDeg) {
                // Filtrar pontos em terra
                if (!isOverOcean(w.lat, w.lon)) continue;
                
                speeds.push(w.speed_kt);
                if (w.direction !== null && w.direction !== undefined) {
                    // IMPORTANTE: Ajustar dire√ß√£o igual ao popup (direction - 180)
                    const adjustedDir = (w.direction - 180 + 360) % 360;
                    dirs.push(adjustedDir);
                }
            }
        }
        
        if (speeds.length === 0) return { count: 0, avgSpeed: null, avgDir: null };
        
        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
        
        // M√©dia circular para dire√ß√£o
        let avgDir = null;
        if (dirs.length > 0) {
            let sinSum = 0, cosSum = 0;
            dirs.forEach(d => {
                sinSum += Math.sin(d * Math.PI / 180);
                cosSum += Math.cos(d * Math.PI / 180);
            });
            avgDir = Math.atan2(sinSum / dirs.length, cosSum / dirs.length) * 180 / Math.PI;
            if (avgDir < 0) avgDir += 360;
        }
        
        return { count: speeds.length, avgSpeed, avgDir };
    }
    
    // Calcular peso do DMW/SCAT baseado na quantidade de vetores
    // Mais vetores = mais confi√°vel = maior peso
    function calculateObservationWeight(count) {
        // 0 vetores = peso 0
        // 1 vetor = peso 0.1 (10%)
        // 5 vetores = peso 0.5 (50%)
        // 10+ vetores = peso 1.0 (100%)
        if (count === 0) return 0;
        if (count >= 10) return 1.0;
        return Math.min(1.0, count * 0.1);
    }
    
    // Calibrar modelos com dados OBSERVADOS (DMW ou SCAT)
    function calibrateWithObservedData() {
        // Verificar se h√° dados DMW ou SCAT novos
        // IMPORTANTE: Calibrar separadamente - SCAT ou DMW, nunca misturar
        // Podem ter at√© 12h de diferen√ßa, misturar prejudica os c√°lculos
        const dmwTimestamp = dmwData && dmwData.timestamp ? new Date(dmwData.timestamp).getTime() : 0;
        const scatTimestamp = scatData && scatData.timestamp ? new Date(scatData.timestamp).getTime() : 0;
        
        const hasNewDMW = dmwTimestamp > lastDMWCalibrationTimestamp;
        const hasNewSCAT = scatTimestamp > lastSCATCalibrationTimestamp;
        
        if (!hasNewDMW && !hasNewSCAT) {
            log('info', 'üìä Calibra√ß√£o: Sem dados novos de DMW/SCAT');
            return;
        }
        
        // Decidir qual fonte usar (apenas UMA por vez)
        // Prioridade para o que acabou de atualizar
        let useSource = null;
        let observedSpeed = null;
        let observedDir = null;
        let sourceWeight = 0;
        let vectorCount = 0;
        
        if (hasNewSCAT) {
            // SCAT atualizou - usar APENAS SCAT
            const scatVectors = getSCATVectorsInRadius();
            observedStats.scat = {
                count: scatVectors.count,
                avgSpeed: scatVectors.avgSpeed,
                avgDir: scatVectors.avgDir,
                weight: calculateObservationWeight(scatVectors.count)
            };
            
            if (scatVectors.count > 0 && scatVectors.avgSpeed !== null) {
                useSource = 'SCAT';
                observedSpeed = scatVectors.avgSpeed;
                observedDir = scatVectors.avgDir;
                sourceWeight = observedStats.scat.weight;
                vectorCount = scatVectors.count;
                lastSCATCalibrationTimestamp = scatTimestamp;
                log('info', `üõ∞Ô∏è SCAT atualizado: ${scatVectors.count} vetores (peso ${(sourceWeight * 100).toFixed(0)}%)`);
            }
        } else if (hasNewDMW) {
            // DMW atualizou - usar APENAS DMW
            const dmwVectors = getDMWVectorsInRadius();
            observedStats.dmw = {
                count: dmwVectors.count,
                avgSpeed: dmwVectors.avgSpeed,
                avgDir: dmwVectors.avgDir,
                weight: calculateObservationWeight(dmwVectors.count)
            };
            
            if (dmwVectors.count > 0 && dmwVectors.avgSpeed !== null) {
                useSource = 'DMW';
                observedSpeed = dmwVectors.avgSpeed;
                observedDir = dmwVectors.avgDir;
                sourceWeight = observedStats.dmw.weight;
                vectorCount = dmwVectors.count;
                lastDMWCalibrationTimestamp = dmwTimestamp;
                log('info', `üåÄ DMW atualizado: ${dmwVectors.count} vetores (peso ${(sourceWeight * 100).toFixed(0)}%)`);
            }
        }
        
        // Se n√£o tem fonte v√°lida, sair
        if (!useSource || observedSpeed === null) {
            log('warning', `‚ö†Ô∏è Calibra√ß√£o: Fonte sem vetores v√°lidos no raio de ${RAIO_OBSERVACAO_NM}nm`);
            updateObservedVectorsUI();  // Atualizar contagens na UI
            return;
        }
        
        // Se peso muito baixo, n√£o calibrar
        if (sourceWeight < 0.1) {
            log('warning', `‚ö†Ô∏è Calibra√ß√£o: ${useSource} com poucos vetores (peso < 10%)`);
            updateObservedVectorsUI();  // Atualizar contagens na UI
            return;
        }
        
        log('success', `üìç Calibrando com ${useSource}: ${observedSpeed.toFixed(1)} kt, ${observedDir ? observedDir.toFixed(0) + '¬∞' : 'N/A'}`);
        
        // =====================================================================
        // PARTE 1: VALIDAR PREVIS√ïES PENDENTES (previs√£o vs realidade)
        // =====================================================================
        const observationTime = useSource === 'SCAT' ? scatTimestamp : dmwTimestamp;
        const matchingForecasts = findMatchingForecasts(observationTime);
        
        if (matchingForecasts.length > 0) {
            log('info', `üîÆ Validando ${matchingForecasts.length} previs√µes pendentes...`);
            
            matchingForecasts.forEach(forecast => {
                const hoursAgo = forecast.hoursAhead;  // Quantas horas antes foi feita
                
                MODELS.forEach(model => {
                    const predicted = forecast.models[model];
                    if (!predicted || predicted.speed === null) return;
                    
                    // Comparar previs√£o com o observado
                    const speedError = Math.abs(predicted.speed - observedSpeed);
                    const dirError = observedDir !== null && predicted.direction !== null ? 
                                     directionError(predicted.direction, observedDir) : null;
                    
                    // Atualizar acur√°cia do modelo (m√©dia m√≥vel exponencial)
                    const alpha = 0.3;  // Fator de suaviza√ß√£o (30% peso para nova observa√ß√£o)
                    
                    // Acur√°cia de velocidade: 1.0 = perfeito, 0.0 = p√©ssimo
                    // speedError de 0 = acc 1.0, speedError de 10+ = acc ~0.3
                    const speedAcc = Math.max(0.3, 1.0 - speedError / 15);
                    modelForecastAccuracy[model].speedAccuracy = 
                        (1 - alpha) * modelForecastAccuracy[model].speedAccuracy + alpha * speedAcc;
                    
                    // Acur√°cia de dire√ß√£o
                    if (dirError !== null) {
                        // dirError de 0 = acc 1.0, dirError de 60+ = acc ~0.3
                        const dirAcc = Math.max(0.3, 1.0 - dirError / 90);
                        modelForecastAccuracy[model].dirAccuracy = 
                            (1 - alpha) * modelForecastAccuracy[model].dirAccuracy + alpha * dirAcc;
                    }
                    
                    log('info', `   üîÆ ${MODEL_NAMES[model]} h-${hoursAgo}: prev ${predicted.speed.toFixed(1)}kt vs obs ${observedSpeed.toFixed(1)}kt | Œî${speedError.toFixed(1)}kt ‚Üí acc ${(modelForecastAccuracy[model].speedAccuracy*100).toFixed(0)}%`);
                });
                
                // Marcar como validada
                forecast.validated = true;
            });
            
            // Salvar previs√µes atualizadas
            try {
                localStorage.setItem('pendingForecasts', JSON.stringify(pendingForecasts));
            } catch (e) {}
        }
        
        // =====================================================================
        // PARTE 2: COMPARAR MODELOS COM OBSERVADO ATUAL
        // SISTEMA PROPORCIONAL - quanto menor o erro, maior o score
        // =====================================================================
        let calibrationResults = [];
        
        // =====================================================================
        // SISTEMA SIMPLES E DIRETO:
        // - Velocidade: 0 kt erro = peso 100%, 30 kt erro = peso 0%
        // - Dire√ß√£o: 0¬∞ erro = peso 100%, 180¬∞ erro = peso 0%
        // =====================================================================
        
        MODELS.forEach(model => {
            const modelValue = modelData[model];
            if (!modelValue || modelValue.speed === null) return;
            
            const speedError = Math.abs(modelValue.speed - observedSpeed);
            const dirError = observedDir !== null && modelValue.direction !== null ? 
                             directionError(modelValue.direction, observedDir) : null;
            
            // Atualizar contadores
            modelStats[model].totalComparisons++;
            
            // === VELOCIDADE ===
            // Peso linear: 0 kt = 100%, 30 kt = 0%
            const speedWeight = Math.max(0, 1 - speedError / 30);
            
            // Acumulador: score vai de 0 a infinito, proporcional √† precis√£o
            // Cada calibra√ß√£o adiciona o peso (0-1) multiplicado pelo peso da fonte
            modelStats[model].speedScore += speedWeight * sourceWeight * 10;
            
            // Contadores de acerto/erro para exibi√ß√£o
            if (speedError < ACCURACY_THRESHOLD_SPEED) {
                modelStats[model].speedCorrectCount++;
            } else {
                modelStats[model].speedWrongCount++;
            }
            
            // === DIRE√á√ÉO ===
            if (dirError !== null) {
                // Peso linear: 0¬∞ = 100%, 180¬∞ = 0%
                const dirWeight = Math.max(0, 1 - dirError / 180);
                
                // Acumulador
                modelStats[model].dirScore += dirWeight * sourceWeight * 10;
                
                // Contadores
                if (dirError < ACCURACY_THRESHOLD_DIR) {
                    modelStats[model].dirCorrectCount++;
                } else {
                    modelStats[model].dirWrongCount++;
                }
            }
            
            calibrationResults.push({
                model: MODEL_NAMES[model],
                speedError: speedError.toFixed(1),
                dirError: dirError !== null ? dirError.toFixed(0) : 'N/A',
                speedWeight: (speedWeight * 100).toFixed(0),
                dirWeight: dirError !== null ? ((1 - dirError / 180) * 100).toFixed(0) : 'N/A',
                speedScore: modelStats[model].speedScore.toFixed(0),
                dirScore: modelStats[model].dirScore.toFixed(0)
            });
        });
        
        // Log detalhado
        calibrationResults.forEach(r => {
            log('info', `${r.model}: Vel Œî${r.speedError}kt=${r.speedWeight}%‚Üí${r.speedScore} | Dir Œî${r.dirError}¬∞=${r.dirWeight}%‚Üí${r.dirScore}`);
        });
        
        // Recalcular pesos
        calculateDynamicWeights();
        
        // ATUALIZAR TABELA DE PREVIS√ÉO COM NOVOS PESOS
        buildForecastTimeline();
        updateForecastDisplay();
        
        // Salvar estat√≠sticas
        saveForecastHistory();
        
        // Atualizar UI
        updateWeightReasonUI(useSource, vectorCount);
    }
    
    // Atualizar UI de vetores observados (√°rea separada)
    // SEMPRE busca vetores atuais no raio, independente de calibra√ß√£o
    function updateObservedVectorsUI() {
        // Buscar vetores DMW e SCAT atuais no raio
        const dmwVectors = getDMWVectorsInRadius();
        const scatVectors = getSCATVectorsInRadius();
        
        const dmwCount = dmwVectors.count;
        const scatCount = scatVectors.count;
        
        // Calcular peso de cada fonte baseado na quantidade de vetores
        const dmwRawWeight = calculateObservationWeight(dmwCount);
        const scatRawWeight = calculateObservationWeight(scatCount);
        
        // PROPOR√á√ÉO RELATIVA: se s√≥ tem uma fonte, ela √© 100%
        const totalWeight = dmwRawWeight + scatRawWeight;
        let dmwPct = 0, scatPct = 0;
        
        if (totalWeight > 0) {
            dmwPct = (dmwRawWeight / totalWeight) * 100;
            scatPct = (scatRawWeight / totalWeight) * 100;
        }
        
        const dmwCountEl = document.getElementById('dmw-vectors-count');
        const scatCountEl = document.getElementById('scat-vectors-count');
        const dmwWeightEl = document.getElementById('dmw-weight-pct');
        const scatWeightEl = document.getElementById('scat-weight-pct');
        
        if (dmwCountEl) dmwCountEl.textContent = dmwCount;
        if (scatCountEl) scatCountEl.textContent = scatCount;
        if (dmwWeightEl) dmwWeightEl.textContent = dmwPct.toFixed(0) + '%';
        if (scatWeightEl) scatWeightEl.textContent = scatPct.toFixed(0) + '%';
    }
    
    // Atualizar UI de raz√£o dos pesos (√∫ltima calibra√ß√£o)
    function updateWeightReasonUI(source, vectorCount) {
        const el = document.getElementById('weight-reason');
        if (!el) return;
        
        const weight = calculateObservationWeight(vectorCount);
        const now = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        
        el.innerHTML = `‚úÖ ${source}: ${vectorCount} vetores (${(weight * 100).toFixed(0)}% peso) √†s ${now}`;
        
        // Atualizar tamb√©m a √°rea de vetores observados
        updateObservedVectorsUI();
    }
    
    // Vers√£o da calibra√ß√£o - incrementar para for√ßar reset quando houver mudan√ßas importantes
    const CALIBRATION_VERSION = 7;  // v7: sistema linear simples - vel 0-30kt, dir 0-180¬∞
    
    // Carregar hist√≥rico e estat√≠sticas do localStorage
    function loadForecastHistory() {
        try {
            // Verificar vers√£o - se mudou, limpar dados antigos
            const savedVersion = localStorage.getItem('calibrationVersion');
            if (savedVersion !== String(CALIBRATION_VERSION)) {
                log('warning', `üîÑ Nova vers√£o de calibra√ß√£o (v${CALIBRATION_VERSION}) - resetando dados antigos...`);
                localStorage.removeItem('forecastHistoryMulti');
                localStorage.removeItem('modelStatsCumulative');
                localStorage.removeItem('pendingForecasts');
                localStorage.removeItem('modelForecastAccuracy');
                localStorage.setItem('calibrationVersion', String(CALIBRATION_VERSION));
                calculateDynamicWeights();
                return;
            }
            
            const saved = localStorage.getItem('forecastHistoryMulti');
            if (saved) {
                forecastHistory = JSON.parse(saved);
                const cutoff = Date.now() - 24 * 60 * 60 * 1000;
                forecastHistory = forecastHistory.filter(h => h.timestamp > cutoff);
                log('info', `üìä Hist√≥rico carregado: ${forecastHistory.length} registros`);
            }
            
            // Carregar estat√≠sticas cumulativas
            const savedStats = localStorage.getItem('modelStatsCumulative');
            if (savedStats) {
                const parsed = JSON.parse(savedStats);
                // Manter estrutura com campos de velocidade e dire√ß√£o separados
                MODELS.forEach(m => {
                    if (parsed[m]) {
                        modelStats[m] = {
                            totalComparisons: parsed[m].totalComparisons || 0,
                            speedCorrectCount: parsed[m].speedCorrectCount || 0,
                            speedWrongCount: parsed[m].speedWrongCount || 0,
                            speedScore: parsed[m].speedScore || 0,
                            dirCorrectCount: parsed[m].dirCorrectCount || 0,
                            dirWrongCount: parsed[m].dirWrongCount || 0,
                            dirScore: parsed[m].dirScore || 0
                        };
                    }
                });
                log('info', `üìä Estat√≠sticas carregadas: ${MODELS.map(m => MODEL_NAMES[m] + ' V:' + modelStats[m].speedScore.toFixed(0) + ' D:' + modelStats[m].dirScore.toFixed(0)).join(' | ')}`);
            }
            
            // Carregar previs√µes pendentes
            loadPendingForecasts();
            
            // Carregar acur√°cia de previs√£o
            const savedAccuracy = localStorage.getItem('modelForecastAccuracy');
            if (savedAccuracy) {
                const parsed = JSON.parse(savedAccuracy);
                MODELS.forEach(m => {
                    if (parsed[m]) {
                        modelForecastAccuracy[m] = {
                            speedAccuracy: parsed[m].speedAccuracy || 1.0,
                            dirAccuracy: parsed[m].dirAccuracy || 1.0
                        };
                    }
                });
                log('info', `üîÆ Acur√°cia carregada: ${MODELS.map(m => MODEL_NAMES[m] + ':' + (modelForecastAccuracy[m].speedAccuracy*100).toFixed(0) + '%').join(' ')}`);
            }
            
            calculateDynamicWeights();
        } catch (e) {
            forecastHistory = [];
            console.error('Erro ao carregar hist√≥rico:', e);
        }
    }
    
    function saveForecastHistory() {
        try {
            localStorage.setItem('forecastHistoryMulti', JSON.stringify(forecastHistory));
            localStorage.setItem('modelStatsCumulative', JSON.stringify(modelStats));
            localStorage.setItem('modelForecastAccuracy', JSON.stringify(modelForecastAccuracy));
        } catch (e) {
            console.error('Erro ao salvar hist√≥rico:', e);
        }
    }
    
    function directionError(predicted, actual) {
        if (predicted === null || actual === null) return 180;
        let diff = Math.abs(predicted - actual);
        if (diff > 180) diff = 360 - diff;
        return diff;
    }
    
    // Calcular o "valor observado" (proxy) - m√©dia simples de todos os modelos dispon√≠veis
    function calculateObservedValue(historyRecord) {
        let speeds = [];
        let dirs = [];
        
        MODELS.forEach(m => {
            if (historyRecord[m] && historyRecord[m].speed !== null) {
                speeds.push(historyRecord[m].speed);
                if (historyRecord[m].direction !== null) {
                    dirs.push(historyRecord[m].direction);
                }
            }
        });
        
        if (speeds.length === 0) return null;
        
        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
        
        // M√©dia circular para dire√ß√£o
        let avgDir = null;
        if (dirs.length > 0) {
            let sinSum = 0, cosSum = 0;
            dirs.forEach(d => {
                sinSum += Math.sin(d * Math.PI / 180);
                cosSum += Math.cos(d * Math.PI / 180);
            });
            avgDir = Math.atan2(sinSum / dirs.length, cosSum / dirs.length) * 180 / Math.PI;
            if (avgDir < 0) avgDir += 360;
        }
        
        return { speed: avgSpeed, direction: avgDir };
    }
    
    // Atualizar estat√≠sticas cumulativas comparando previs√£o com valor observado
    function updateCumulativeStats(prevRecord, currRecord) {
        // O "valor observado" √© a m√©dia simples do registro ATUAL
        const observed = calculateObservedValue(currRecord);
        if (!observed) return;
        
        MODELS.forEach(model => {
            // A previs√£o √© o valor do registro ANTERIOR (o que o modelo previa)
            const prediction = prevRecord[model];
            if (!prediction || prediction.speed === null) return;
            
            // Calcular erros
            const speedError = Math.abs(prediction.speed - observed.speed);
            const dirError = directionError(prediction.direction, observed.direction);
            
            // Erro combinado normalizado (0-1 scale)
            const normalizedError = (speedError / 30) * 0.6 + (dirError / 180) * 0.4;
            
            // Atualizar contadores
            modelStats[model].totalErrors += normalizedError;
            modelStats[model].totalComparisons++;
            
            // Verificar se √© acerto ou erro
            const isCorrect = speedError < ACCURACY_THRESHOLD_SPEED && dirError < ACCURACY_THRESHOLD_DIR;
            
            if (isCorrect) {
                modelStats[model].correctCount++;
                // Recuperar score levemente
                modelStats[model].cumulativeScore = Math.min(150, 
                    modelStats[model].cumulativeScore + 2 * CORRECT_REWARD_FACTOR);
            } else {
                modelStats[model].wrongCount++;
                // Penalizar score - quanto maior o erro, maior a penalidade
                const penalty = normalizedError * 10 * ERROR_PENALTY_FACTOR;
                modelStats[model].cumulativeScore = Math.max(10, 
                    modelStats[model].cumulativeScore - penalty);
            }
        });
    }
    
    // Calcular pesos SEPARADOS para velocidade e dire√ß√£o
    function calculateDynamicWeights() {
        const hasStats = MODELS.some(m => modelStats[m].totalComparisons > 0);
        
        if (!hasStats) {
            MODELS.forEach(m => {
                modelSpeedWeights[m] = 1 / MODELS.length;
                modelDirWeights[m] = 1 / MODELS.length;
                modelWeights[m] = 1 / MODELS.length;
            });
            const weightReasonEl = document.getElementById('weight-reason');
            if (weightReasonEl) weightReasonEl.textContent = '‚è≥ Pesos iguais (aguardando calibra√ß√£o)';
            updateCalibrationUI();
            return;
        }
        
        // === PESOS DE VELOCIDADE ===
        let totalSpeedScore = 0;
        MODELS.forEach(m => totalSpeedScore += modelStats[m].speedScore);
        
        if (totalSpeedScore > 0) {
            MODELS.forEach(m => {
                // Peso base da calibra√ß√£o DMW/SCAT
                let baseWeight = modelStats[m].speedScore / totalSpeedScore;
                // MULTIPLICAR pela acur√°cia de previs√£o
                baseWeight *= modelForecastAccuracy[m].speedAccuracy;
                modelSpeedWeights[m] = baseWeight;
            });
            // Limitar entre 5% e 50%
            MODELS.forEach(m => {
                modelSpeedWeights[m] = Math.max(0.05, Math.min(0.50, modelSpeedWeights[m]));
            });
            // Renormalizar
            let sumSpd = 0;
            MODELS.forEach(m => sumSpd += modelSpeedWeights[m]);
            MODELS.forEach(m => modelSpeedWeights[m] /= sumSpd);
        }
        
        // === PESOS DE DIRE√á√ÉO ===
        let totalDirScore = 0;
        MODELS.forEach(m => totalDirScore += modelStats[m].dirScore);
        
        if (totalDirScore > 0) {
            MODELS.forEach(m => {
                // Peso base da calibra√ß√£o DMW/SCAT
                let baseWeight = modelStats[m].dirScore / totalDirScore;
                // MULTIPLICAR pela acur√°cia de previs√£o
                baseWeight *= modelForecastAccuracy[m].dirAccuracy;
                modelDirWeights[m] = baseWeight;
            });
            // Limitar entre 5% e 50%
            MODELS.forEach(m => {
                modelDirWeights[m] = Math.max(0.05, Math.min(0.50, modelDirWeights[m]));
            });
            // Renormalizar
            let sumDir = 0;
            MODELS.forEach(m => sumDir += modelDirWeights[m]);
            MODELS.forEach(m => modelDirWeights[m] /= sumDir);
        }
        
        // Peso combinado (para compatibilidade - m√©dia dos dois)
        MODELS.forEach(m => {
            modelWeights[m] = (modelSpeedWeights[m] + modelDirWeights[m]) / 2;
        });
        
        // Encontrar melhor modelo em cada categoria
        let bestSpeedModel = MODELS[0];
        let bestDirModel = MODELS[0];
        let highestSpeedScore = modelStats[MODELS[0]].speedScore;
        let highestDirScore = modelStats[MODELS[0]].dirScore;
        
        MODELS.forEach(m => {
            if (modelStats[m].speedScore > highestSpeedScore) {
                highestSpeedScore = modelStats[m].speedScore;
                bestSpeedModel = m;
            }
            if (modelStats[m].dirScore > highestDirScore) {
                highestDirScore = modelStats[m].dirScore;
                bestDirModel = m;
            }
        });
        
        const totalComparisons = modelStats[MODELS[0]].totalComparisons;
        console.log(`‚öñÔ∏è ${totalComparisons} verifica√ß√µes | Melhor Vel: ${MODEL_NAMES[bestSpeedModel]} | Melhor Dir: ${MODEL_NAMES[bestDirModel]}`);
        
        log('info', `‚öñÔ∏è Vel: ${MODELS.map(m => MODEL_NAMES[m] + ':' + (modelSpeedWeights[m]*100).toFixed(0) + '%').join(' ')}`);
        log('info', `‚öñÔ∏è Dir: ${MODELS.map(m => MODEL_NAMES[m] + ':' + (modelDirWeights[m]*100).toFixed(0) + '%').join(' ')}`);
        
        updateCalibrationUI();
    }
    
    // Atualizar UI de calibra√ß√£o com estat√≠sticas detalhadas (velocidade e dire√ß√£o separados)
    function updateCalibrationUI() {
        MODELS.forEach(m => {
            const stats = modelStats[m];
            const spdWeight = (modelSpeedWeights[m] * 100).toFixed(0);
            const dirWeight = (modelDirWeights[m] * 100).toFixed(0);
            
            // Atualizar elementos de velocidade
            const spdCountEl = document.getElementById(`calib-spd-count-${m}`);
            const spdScoreEl = document.getElementById(`calib-spd-score-${m}`);
            const spdWeightEl = document.getElementById(`calib-spd-weight-${m}`);
            const dirCountEl = document.getElementById(`calib-dir-count-${m}`);
            const dirScoreEl = document.getElementById(`calib-dir-score-${m}`);
            const dirWeightEl = document.getElementById(`calib-dir-weight-${m}`);
            
            if (spdCountEl) spdCountEl.textContent = `${stats.speedCorrectCount}/${stats.speedWrongCount}`;
            if (spdScoreEl) spdScoreEl.textContent = stats.speedScore.toFixed(0);
            if (spdWeightEl) spdWeightEl.textContent = spdWeight;
            if (dirCountEl) dirCountEl.textContent = `${stats.dirCorrectCount}/${stats.dirWrongCount}`;
            if (dirScoreEl) dirScoreEl.textContent = stats.dirScore.toFixed(0);
            if (dirWeightEl) dirWeightEl.textContent = dirWeight;
            
            // Colorir score de velocidade
            if (spdScoreEl) {
                if (stats.speedScore >= 100) {
                    spdScoreEl.style.color = '#00ff00';
                } else if (stats.speedScore >= 50) {
                    spdScoreEl.style.color = '#88ccff';
                } else {
                    spdScoreEl.style.color = '#ff6666';
                }
            }
            
            // Colorir score de dire√ß√£o
            if (dirScoreEl) {
                if (stats.dirScore >= 100) {
                    dirScoreEl.style.color = '#00ff00';
                } else if (stats.dirScore >= 50) {
                    dirScoreEl.style.color = '#ffcc88';
                } else {
                    dirScoreEl.style.color = '#ff6666';
                }
            }
        });
    }
    
    // TESTE DE CALIBRA√á√ÉO - Bot√£o tempor√°rio para debug
    function testCalibration() {
        log('warning', 'üß™ ========== TEST CALIBRATION ==========');
        
        // 1. Mostrar dados SCAT dispon√≠veis
        if (scatData && scatData.winds) {
            log('info', `üìä SCAT: ${scatData.winds.length} vetores totais`);
            log('info', `üìÖ SCAT timestamp: ${scatData.timestamp}`);
        } else {
            log('error', '‚ùå SCAT: Sem dados carregados');
        }
        
        // 2. Buscar vetores no raio de observa√ß√£o (20nm)
        const scatVectors = getSCATVectorsInRadius();
        log('info', `üéØ SCAT no raio de ${RAIO_OBSERVACAO_NM}nm: ${scatVectors.count} vetores`);
        
        if (scatVectors.count > 0) {
            log('success', `üìç SCAT m√©dia: ${scatVectors.avgSpeed?.toFixed(1)} kt, ${scatVectors.avgDir?.toFixed(0)}¬∞`);
            
            // 3. Mostrar vetores individuais encontrados
            const radiusDeg = RAIO_OBSERVACAO_GRAUS;
            let foundVectors = [];
            
            if (scatData && scatData.winds) {
                for (const w of scatData.winds) {
                    const latDiff = Math.abs(w.lat - CONFIG.shipLat);
                    const lonDiff = Math.abs(w.lon - CONFIG.shipLon);
                    
                    if (latDiff <= radiusDeg && lonDiff <= radiusDeg) {
                        if (!isOverOcean(w.lat, w.lon)) continue;
                        
                        // Calcular adjustedDir (igual ao popup)
                        const adjustedDir = (w.direction - 180 + 360) % 360;
                        foundVectors.push({
                            lat: w.lat,
                            lon: w.lon,
                            speed: w.speed_kt,
                            dirOriginal: w.direction,
                            dirAdjusted: adjustedDir
                        });
                    }
                }
            }
            
            log('info', `üîç Vetores encontrados no raio:`);
            foundVectors.forEach((v, i) => {
                log('info', `   [${i+1}] Lat:${v.lat.toFixed(2)} Lon:${v.lon.toFixed(2)} | ${v.speed.toFixed(1)}kt | Original:${v.dirOriginal?.toFixed(0)}¬∞ -> Adjusted:${v.dirAdjusted?.toFixed(0)}¬∞`);
            });
        }
        
        // 4. Mostrar dados DMW
        if (dmwData && dmwData.winds) {
            const dmwVectors = getDMWVectorsInRadius();
            log('info', `üåÄ DMW no raio de ${RAIO_OBSERVACAO_NM}nm: ${dmwVectors.count} vetores`);
            if (dmwVectors.count > 0) {
                log('success', `üìç DMW m√©dia: ${dmwVectors.avgSpeed?.toFixed(1)} kt, ${dmwVectors.avgDir?.toFixed(0)}¬∞`);
            }
        }
        
        // 5. Mostrar valores dos modelos
        log('info', 'üìà Valores dos modelos:');
        MODELS.forEach(m => {
            const val = modelData[m];
            if (val && val.speed !== null) {
                log('info', `   ${m}: ${val.speed.toFixed(1)} kt, ${val.direction?.toFixed(0)}¬∞`);
            } else {
                log('info', `   ${m}: sem dados`);
            }
        });
        
        // 6. For√ßar calibra√ß√£o (ignorando timestamp)
        log('warning', 'üîß For√ßando calibra√ß√£o...');
        
        // Salvar timestamps atuais
        const savedDMW = lastDMWCalibrationTimestamp;
        const savedSCAT = lastSCATCalibrationTimestamp;
        
        // Zerar timestamps para for√ßar calibra√ß√£o
        lastDMWCalibrationTimestamp = 0;
        lastSCATCalibrationTimestamp = 0;
        
        // Executar calibra√ß√£o
        calibrateWithObservedData();
        
        // Restaurar timestamps (para n√£o calibrar novamente sem dados novos)
        lastDMWCalibrationTimestamp = savedDMW;
        lastSCATCalibrationTimestamp = savedSCAT;
        
        log('warning', 'üß™ ========== FIM TEST CALIBRATION ==========');
    }
    
    // TESTE DE PESOS ALEAT√ìRIOS - para verificar se tabela atualiza
    function testRandomWeights() {
        log('warning', 'üé≤ ========== TESTE PESOS ALEAT√ìRIOS ==========');
        
        // Gerar pesos aleat√≥rios BEM DIFERENTES para cada modelo
        // Usar valores de 1 a 100 para ter bastante varia√ß√£o
        const randomValues = {};
        MODELS.forEach(m => {
            randomValues[m] = Math.random() * 99 + 1;  // 1 a 100
        });
        
        // Normalizar para somar 100%
        const total = Object.values(randomValues).reduce((a, b) => a + b, 0);
        
        MODELS.forEach(m => {
            modelSpeedWeights[m] = randomValues[m] / total;
            modelDirWeights[m] = (Math.random() * 99 + 1) / total;  // Dire√ß√£o diferente!
        });
        
        // Renormalizar dire√ß√£o
        let sumDir = 0;
        MODELS.forEach(m => sumDir += modelDirWeights[m]);
        MODELS.forEach(m => modelDirWeights[m] /= sumDir);
        
        // Log dos novos pesos
        log('info', `üé≤ Pesos Vel: ${MODELS.map(m => MODEL_NAMES[m] + ':' + (modelSpeedWeights[m]*100).toFixed(0) + '%').join(' | ')}`);
        log('info', `üé≤ Pesos Dir: ${MODELS.map(m => MODEL_NAMES[m] + ':' + (modelDirWeights[m]*100).toFixed(0) + '%').join(' | ')}`);
        
        // ATUALIZAR TUDO
        updateCalibrationUI();
        buildForecastTimeline();
        updateForecastDisplay();
        
        log('success', '‚úÖ Tabela de previs√£o reconstru√≠da com pesos aleat√≥rios!');
        log('warning', 'üé≤ ========== FIM TESTE PESOS ALEAT√ìRIOS ==========');
    }
    
    // Resetar calibra√ß√£o (para recome√ßar do zero)
    function resetCalibration() {
        if (!confirm('Resetar todas as estat√≠sticas de calibra√ß√£o? Isso ir√° zerar os pesos acumulados.')) {
            return;
        }
        
        MODELS.forEach(m => {
            modelStats[m] = {
                totalComparisons: 0,
                speedCorrectCount: 0,
                speedWrongCount: 0,
                speedScore: 0,
                dirCorrectCount: 0,
                dirWrongCount: 0,
                dirScore: 0
            };
            modelWeights[m] = 1 / MODELS.length;
            modelSpeedWeights[m] = 1 / MODELS.length;
            modelDirWeights[m] = 1 / MODELS.length;
            modelForecastAccuracy[m] = { speedAccuracy: 1.0, dirAccuracy: 1.0 };
        });
        
        forecastHistory = [];
        pendingForecasts = [];
        localStorage.removeItem('forecastHistoryMulti');
        localStorage.removeItem('modelStatsCumulative');
        localStorage.removeItem('pendingForecasts');
        localStorage.removeItem('modelForecastAccuracy');
        
        calculateDynamicWeights();
        updateForecastDisplay();  // Atualizar header com novos pesos
        log('warning', 'üîÑ Calibra√ß√£o resetada - todos os modelos com peso igual');
    }
    
    function addToForecastHistory(data) {
        const record = { timestamp: Date.now() };
        MODELS.forEach(m => {
            record[m] = data[m] ? { speed: data[m].speed, direction: data[m].direction } : { speed: null, direction: null };
        });
        
        // N√ÉO comparar mais entre modelos - a calibra√ß√£o agora √© feita
        // pela fun√ß√£o calibrateWithObservedData() que usa dados DMW/SCAT reais
        
        forecastHistory.push(record);
        if (forecastHistory.length > 96) forecastHistory = forecastHistory.slice(-96);
        
        saveForecastHistory();
    }
    
    async function fetchOpenMeteoData() {
        setStatus('openmeteo-status', 'loading');
        log('info', 'üåê Buscando 5 modelos (Open-Meteo)...');
        console.log('[OpenMeteo] Iniciando busca de dados de vento...');
        
        try {
            if (forecastHistory.length === 0) loadForecastHistory();
            
            // Limpar dados anteriores
            windDataPoints = windDataPoints.filter(p => 
                !p.source.includes('GFS') && !p.source.includes('ECMWF') && 
                !p.source.includes('ICON') && !p.source.includes('MeteoFR') && 
                !p.source.includes('JMA') && p.source !== 'Open-Meteo'
            );
            
            // Usar endpoint /forecast com par√¢metro models para todos
            // Isso garante dados 'current' dispon√≠veis para todos os modelos
            let successCount = 0;
            const promises = MODELS.map(async model => {
                try {
                    // Endpoint unificado com par√¢metro models
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.shipLat}&longitude=${CONFIG.shipLon}&current=wind_speed_10m,wind_direction_10m&models=${model}&wind_speed_unit=kn`;
                    console.log(`[OpenMeteo] Buscando ${model}: ${url}`);
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    console.log(`[OpenMeteo] ${model} resposta:`, data);
                    
                    if (data.current && data.current.wind_speed_10m !== undefined) {
                        modelData[model] = {
                            speed: data.current.wind_speed_10m,
                            direction: data.current.wind_direction_10m
                        };
                        successCount++;
                        log('info', `  ‚úì ${MODEL_NAMES[model]}: ${data.current.wind_speed_10m.toFixed(1)} kn`);
                    } else if (data.error) {
                        log('warning', `  ‚úó ${MODEL_NAMES[model]}: ${data.reason || data.error}`);
                        console.error(`[OpenMeteo] ${model} erro:`, data);
                    } else {
                        log('warning', `  ‚úó ${MODEL_NAMES[model]}: sem dados current`);
                    }
                } catch (e) {
                    console.error(`[OpenMeteo] ${model} exce√ß√£o:`, e);
                    log('warning', `  ‚úó ${MODEL_NAMES[model]}: ${e.message}`);
                }
            });
            
            await Promise.all(promises);
            
            // Adicionar ao hist√≥rico
            addToForecastHistory(modelData);
            
            // Atualizar display
            updateModelAverage();
            
            // Carregar previs√£o hor√°ria
            await fetchForecastData();
            
            updateWindDisplay();
            setStatus('openmeteo-status', 'active');
            
            const activeModels = MODELS.filter(m => modelData[m].speed !== null).length;
            log('success', `‚úÖ ${activeModels} modelos carregados - Pr√≥xima atualiza√ß√£o em 15 min`);
            
        } catch (error) {
            log('error', '‚ùå Erro: ' + error.message);
            setStatus('openmeteo-status', 'error');
        }
    }
    
    // =========================================================================
    // SISTEMA DE PREVIS√ÉO MULTI-MODELO (24h/48h/72h)
    // =========================================================================
    let forecastPeriod = 24;  // Per√≠odo selecionado (24, 48, 72)
    let forecastHour = 0;     // Hora selecionada dentro do per√≠odo
    let allForecastData = {}; // Dados de previs√£o de todos os modelos
    let forecastRefreshInterval = null;
    
    function selectForecastPeriod(period) {
        forecastPeriod = period;
        forecastHour = 0;  // Reset para primeira hora
        
        // Atualizar bot√µes
        document.querySelectorAll('.forecast-period-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Reconstruir timeline
        buildForecastTimeline();
        
        // Recarregar dados
        fetchForecastData();
        
        log('info', `üìÖ Per√≠odo de previs√£o: ${period}h`);
    }
    
    // Fun√ß√£o para obter classe de cor baseada na velocidade do vento (em kn)
    // Escala ajustada: amarelo > 25kn, vermelho > 35kn
    function getWindColorClass(speed) {
        if (speed < 10) return 'wind-calm';       // Verde escuro: 0-10 kn
        if (speed < 15) return 'wind-light';      // Verde claro: 10-15 kn
        if (speed < 20) return 'wind-moderate';   // Verde-amarelo: 15-20 kn
        if (speed < 25) return 'wind-fresh';      // Amarelo esverdeado: 20-25 kn
        if (speed < 30) return 'wind-strong';     // Amarelo: 25-30 kn
        if (speed < 35) return 'wind-gale';       // Laranja: 30-35 kn
        if (speed < 45) return 'wind-storm';      // Vermelho: 35-45 kn
        return 'wind-violent';                    // Roxo: > 45 kn
    }
    
    // Fun√ß√£o para obter seta de dire√ß√£o
    function getDirectionArrow(deg) {
        const arrows = ['‚Üì', '‚Üô', '‚Üê', '‚Üñ', '‚Üë', '‚Üó', '‚Üí', '‚Üò'];
        const index = Math.round(deg / 45) % 8;
        return arrows[index];
    }
    
    function buildForecastTimeline() {
        const hoursContainer = document.getElementById('forecast-hours');
        const windsContainer = document.getElementById('forecast-winds');
        const gustsContainer = document.getElementById('forecast-gusts');
        const dirsContainer = document.getElementById('forecast-dirs');
        
        if (!hoursContainer || !windsContainer || !gustsContainer || !dirsContainer) {
            console.warn('[buildForecastTimeline] Containers n√£o encontrados');
            return;
        }
        
        hoursContainer.innerHTML = '';
        windsContainer.innerHTML = '';
        gustsContainer.innerHTML = '';
        dirsContainer.innerHTML = '';
        
        // Intervalo baseado no per√≠odo
        let interval;
        if (forecastPeriod === 24) interval = 1;
        else if (forecastPeriod === 48) interval = 3;
        else interval = 6;
        
        const now = new Date();
        
        for (let h = 0; h <= forecastPeriod; h += interval) {
            const forecastTime = new Date(now.getTime() + h * 60 * 60 * 1000);
            const hourNum = forecastTime.getHours();
            
            // C√©lula de Hora
            const hourCell = document.createElement('div');
            hourCell.className = 'forecast-cell hour';
            hourCell.textContent = hourNum;
            hourCell.dataset.hour = h;
            hourCell.onclick = function() { selectForecastHour(parseInt(this.dataset.hour), this); };
            hoursContainer.appendChild(hourCell);
            
            // Calcular dados para esta hora (m√©dia ponderada)
            const hourData = calculateHourData(h);
            
            // C√©lula de Vento
            const windCell = document.createElement('div');
            windCell.className = 'forecast-cell ' + getWindColorClass(hourData.speed);
            windCell.textContent = hourData.speed !== null ? Math.round(hourData.speed) : '--';
            windCell.dataset.hour = h;
            windCell.onclick = function() { selectForecastHour(parseInt(this.dataset.hour), this); };
            windsContainer.appendChild(windCell);
            
            // C√©lula de Rajada
            const gustCell = document.createElement('div');
            gustCell.className = 'forecast-cell ' + getWindColorClass(hourData.gust);
            gustCell.textContent = hourData.gust !== null ? Math.round(hourData.gust) : '--';
            gustCell.dataset.hour = h;
            gustCell.onclick = function() { selectForecastHour(parseInt(this.dataset.hour), this); };
            gustsContainer.appendChild(gustCell);
            
            // C√©lula de Dire√ß√£o (valor num√©rico em graus)
            const dirCell = document.createElement('div');
            dirCell.className = 'forecast-cell direction';
            dirCell.textContent = hourData.dir !== null ? Math.round(hourData.dir) + '¬∞' : '--';
            dirCell.dataset.hour = h;
            dirCell.onclick = function() { selectForecastHour(parseInt(this.dataset.hour), this); };
            dirsContainer.appendChild(dirCell);
        }
        
        // Selecionar primeira hora por padr√£o
        selectForecastHour(0, document.querySelector('.forecast-cell.hour'));
    }
    
    // Calcular dados de uma hora espec√≠fica (m√©dia ponderada)
    function calculateHourData(hourOffset) {
        // hourOffset √© o offset em horas (0, 1, 2, 3... ou 0, 3, 6... dependendo do per√≠odo)
        // Os dados da API v√™m em intervalos de 1 hora, ent√£o usamos hourOffset diretamente
        const hourIndex = hourOffset;
        
        let availableModels = [];
        let totalWeight = 0;
        
        MODELS.forEach(model => {
            const data = allForecastData[model];
            if (data && data.speeds && data.speeds[hourIndex] !== null && data.speeds[hourIndex] !== undefined) {
                availableModels.push(model);
                totalWeight += modelWeights[model];
            }
        });
        
        if (availableModels.length === 0) {
            return { speed: null, gust: null, dir: null };
        }
        
        let normalizedWeights = {};
        availableModels.forEach(model => {
            normalizedWeights[model] = modelWeights[model] / totalWeight;
        });
        
        let weightedSpeed = 0;
        let weightedGust = 0;
        let weightedDirX = 0;
        let weightedDirY = 0;
        
        availableModels.forEach(model => {
            const data = allForecastData[model];
            const weight = normalizedWeights[model];
            
            const speed = data.speeds[hourIndex];
            const dir = data.directions[hourIndex];
            // Verificar se gust existe E tem valor v√°lido para esta hora
            let gust = null;
            if (data.gusts && data.gusts[hourIndex] !== null && data.gusts[hourIndex] !== undefined) {
                gust = data.gusts[hourIndex];
            } else {
                // Fallback: estimar rajada como 30% maior que velocidade
                gust = speed * 1.3;
            }
            
            weightedSpeed += speed * weight;
            weightedGust += gust * weight;
            
            const rad = dir * Math.PI / 180;
            weightedDirX += Math.cos(rad) * weight;
            weightedDirY += Math.sin(rad) * weight;
        });
        
        let avgDir = Math.atan2(weightedDirY, weightedDirX) * 180 / Math.PI;
        if (avgDir < 0) avgDir += 360;
        
        return { speed: weightedSpeed, gust: weightedGust, dir: avgDir };
    }
    
    function selectForecastHour(hour, btnElement) {
        forecastHour = hour;
        
        // Remover sele√ß√£o de todas as c√©lulas
        document.querySelectorAll('.forecast-cell').forEach(cell => {
            cell.classList.remove('selected');
        });
        
        // Marcar todas as c√©lulas da coluna selecionada
        document.querySelectorAll(`.forecast-cell[data-hour="${hour}"]`).forEach(cell => {
            cell.classList.add('selected');
        });
        
        // Atualizar display com dados do hor√°rio selecionado
        updateForecastDisplay();
    }
    
    async function fetchForecastData() {
        log('info', `üåä Buscando previs√£o ${forecastPeriod}h (5 modelos)...`);
        
        try {
            // Limpar dados anteriores
            allForecastData = {};
            
            // Buscar dados de todos os modelos
            const promises = MODELS.map(async model => {
                try {
                    // Calcular horas necess√°rias
                    const hours = [];
                    let interval = forecastPeriod === 24 ? 1 : (forecastPeriod === 48 ? 3 : 6);
                    for (let h = 0; h <= forecastPeriod; h += interval) {
                        hours.push(h);
                    }
                    
                    const url = `https://api.open-meteo.com/v1/forecast?` +
                        `latitude=${CONFIG.shipLat}&longitude=${CONFIG.shipLon}&` +
                        `hourly=wind_speed_10m,wind_direction_10m,wind_gusts_10m&` +
                        `models=${model}&wind_speed_unit=kn&` +
                        `forecast_hours=${forecastPeriod + 1}`;
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.hourly) {
                        allForecastData[model] = {
                            times: data.hourly.time,
                            speeds: data.hourly.wind_speed_10m,
                            directions: data.hourly.wind_direction_10m,
                            gusts: data.hourly.wind_gusts_10m
                        };
                        log('info', `  ‚úì ${MODEL_NAMES[model]}: ${data.hourly.time.length} horas`);
                    }
                } catch (e) {
                    log('warning', `  ‚úó ${MODEL_NAMES[model]}: ${e.message}`);
                }
            });
            
            await Promise.all(promises);
            
            // Reconstruir tabela com dados atualizados
            buildForecastTimeline();
            
            // Atualizar display da hora selecionada
            updateForecastDisplay();
            
            // SALVAR PREVIS√ïES PENDENTES para valida√ß√£o futura
            savePendingForecasts();
            
            // Atualizar status
            const now = new Date();
            const nextUpdate = new Date(now.getTime() + 15 * 60 * 1000);
            const forecastStatusEl = document.getElementById('forecast-status');
            if (forecastStatusEl) {
                forecastStatusEl.textContent = 
                    `‚è∞ ${nextUpdate.toLocaleTimeString('pt-BR', {hour:'2-digit', minute:'2-digit'})}`;
            }
            
            log('success', `‚úÖ Previs√£o ${forecastPeriod}h carregada`);
            
        } catch (error) {
            log('error', `‚ùå Erro previs√£o: ${error.message}`);
        }
    }
    
    function updateForecastDisplay() {
        // Calcular √≠ndice da hora no array
        const interval = forecastPeriod === 24 ? 1 : (forecastPeriod === 48 ? 3 : 6);
        const hourIndex = forecastHour;  // Index direto para dados hourly (0, 1, 2, ...)
        
        // =====================================================================
        // M√âDIA PONDERADA DIN√ÇMICA - PESOS SEPARADOS PARA VELOCIDADE E DIRE√á√ÉO
        // =====================================================================
        // Passo 1: Identificar quais modelos t√™m dados para este hor√°rio
        let availableModels = [];
        let totalSpeedWeight = 0;
        let totalDirWeight = 0;
        
        MODELS.forEach(model => {
            const data = allForecastData[model];
            if (data && data.speeds && data.speeds[hourIndex] !== null && data.speeds[hourIndex] !== undefined) {
                availableModels.push(model);
                totalSpeedWeight += modelSpeedWeights[model];
                totalDirWeight += modelDirWeights[model];
            }
        });
        
        if (availableModels.length === 0) {
            const fSpeed = document.getElementById('forecast-speed');
            const fDir = document.getElementById('forecast-dir');
            const fGust = document.getElementById('forecast-gust');
            if (fSpeed) fSpeed.textContent = '--';
            if (fDir) fDir.textContent = '--';
            if (fGust) fGust.textContent = '--';
            return;
        }
        
        // Passo 2: Renormalizar pesos para os modelos dispon√≠veis (soma = 1)
        let normSpeedWeights = {};
        let normDirWeights = {};
        availableModels.forEach(model => {
            normSpeedWeights[model] = modelSpeedWeights[model] / totalSpeedWeight;
            normDirWeights[model] = modelDirWeights[model] / totalDirWeight;
        });
        
        // Passo 3: Calcular m√©dia ponderada COM PESOS SEPARADOS
        let weightedSpeed = 0;
        let weightedGust = 0;
        let weightedDirX = 0;
        let weightedDirY = 0;
        
        availableModels.forEach(model => {
            const data = allForecastData[model];
            const spdWeight = normSpeedWeights[model];
            const dirWeight = normDirWeights[model];
            
            const speed = data.speeds[hourIndex];
            const dir = data.directions[hourIndex];
            // Verificar se gust existe E tem valor v√°lido para esta hora
            let gust = null;
            if (data.gusts && data.gusts[hourIndex] !== null && data.gusts[hourIndex] !== undefined) {
                gust = data.gusts[hourIndex];
            } else {
                // Fallback: estimar rajada como 30% maior que velocidade
                gust = speed * 1.3;
            }
            
            // Velocidade e rajada usam peso de velocidade
            weightedSpeed += speed * spdWeight;
            weightedGust += gust * spdWeight;
            
            // Dire√ß√£o usa peso de dire√ß√£o
            const rad = dir * Math.PI / 180;
            weightedDirX += Math.cos(rad) * dirWeight;
            weightedDirY += Math.sin(rad) * dirWeight;
        });
        
        // Calcular dire√ß√£o resultante
        let avgDir = Math.atan2(weightedDirY, weightedDirX) * 180 / Math.PI;
        if (avgDir < 0) avgDir += 360;
        
        // Calcular hor√°rio da previs√£o
        const now = new Date();
        const forecastTime = new Date(now.getTime() + forecastHour * 60 * 60 * 1000);
        const dateTimeStr = forecastTime.toLocaleString('pt-BR', { 
            day: '2-digit', month: '2-digit', 
            hour: '2-digit', minute: '2-digit' 
        });
        
        // Atualizar display
        const fDatetime = document.getElementById('forecast-datetime');
        const fSpeed = document.getElementById('forecast-speed');
        const fDir = document.getElementById('forecast-dir');
        const fGust = document.getElementById('forecast-gust');
        
        if (fDatetime) fDatetime.textContent = dateTimeStr;
        if (fSpeed) fSpeed.textContent = weightedSpeed.toFixed(1);
        if (fDir) fDir.textContent = avgDir.toFixed(0) + '¬∞';
        if (fGust) fGust.textContent = weightedGust.toFixed(1);
        
        // Atualizar pesos na interface (mostrar peso de velocidade)
        const uiMap = {
            'gfs_seamless': 'gfs',
            'ecmwf_ifs025': 'ecmwf',
            'icon_seamless': 'icon',
            'meteofrance_seamless': 'meteofr',
            'jma_seamless': 'jma'
        };
        
        MODELS.forEach(model => {
            const uiKey = uiMap[model];
            const el = document.getElementById(`fw-${uiKey}`);
            if (el) {
                if (normSpeedWeights[model] !== undefined) {
                    // Mostrar peso de velocidade (o principal para previs√£o)
                    el.textContent = (normSpeedWeights[model] * 100).toFixed(0) + '%';
                    el.style.fontWeight = 'bold';
                } else {
                    el.textContent = '--';
                    el.style.fontWeight = 'normal';
                }
            }
        });
        
        // Log para debug (apenas quando muda de hora)
        if (hourIndex === 0) {
            const weightsStr = availableModels.map(m => 
                `${MODEL_NAMES[m]}: V${(normSpeedWeights[m]*100).toFixed(0)}% D${(normDirWeights[m]*100).toFixed(0)}%`
            ).join(' | ');
            log('info', `üìä Previs√£o h+${forecastHour}: ${weightedSpeed.toFixed(1)}kn ${avgDir.toFixed(0)}¬∞ [${weightsStr}]`);
        }
    }
    
    // Iniciar atualiza√ß√£o autom√°tica de previs√£o a cada 15 minutos
    function startForecastAutoRefresh() {
        if (forecastRefreshInterval) clearInterval(forecastRefreshInterval);
        
        forecastRefreshInterval = setInterval(() => {
            log('info', '‚è∞ Atualizando previs√£o (15 min)...');
            fetchForecastData();
        }, 15 * 60 * 1000);  // 15 minutos
    }
    
    // Construir timeline inicial
    buildForecastTimeline();
    startForecastAutoRefresh();
    
    function updateModelAverage() {
        // Atualizar valores individuais na UI
        const uiMap = {
            'gfs_seamless': 'gfs',
            'ecmwf_ifs025': 'ecmwf',
            'icon_seamless': 'icon',
            'meteofrance_seamless': 'meteofr',
            'jma_seamless': 'jma'
        };
        
        console.log('[updateModelAverage] modelData:', JSON.stringify(modelData));
        
        let validModels = 0;
        let weightedSpeed = 0;
        let weightedDirX = 0;
        let weightedDirY = 0;
        
        MODELS.forEach(model => {
            const uiKey = uiMap[model];
            const data = modelData[model];
            const weight = modelWeights[model];
            
            console.log(`[updateModelAverage] ${model}: speed=${data?.speed}, dir=${data?.direction}`);
            
            // Atualizar UI (se elementos existirem)
            const valEl = document.getElementById(`${uiKey}-value`);
            const weightEl = document.getElementById(`${uiKey}-weight`);
            
            if (data && data.speed !== null) {
                if (valEl) valEl.textContent = `${data.speed.toFixed(1)} kn / ${data.direction.toFixed(0)}¬∞`;
                if (weightEl) weightEl.textContent = `(${(weight * 100).toFixed(0)}%)`;
                
                // Acumular para m√©dia ponderada
                weightedSpeed += data.speed * weight;
                const rad = data.direction * Math.PI / 180;
                weightedDirX += Math.cos(rad) * weight;
                weightedDirY += Math.sin(rad) * weight;
                validModels++;
            } else {
                if (valEl) valEl.textContent = '--';
                if (weightEl) weightEl.textContent = '';
            }
        });
        
        // Calcular m√©dia ponderada
        if (validModels > 0) {
            let avgDir = Math.atan2(weightedDirY, weightedDirX) * 180 / Math.PI;
            if (avgDir < 0) avgDir += 360;
            
            const avgSpeedEl = document.getElementById('avg-model-speed');
            const avgDirEl = document.getElementById('avg-model-dir');
            if (avgSpeedEl) avgSpeedEl.textContent = weightedSpeed.toFixed(1);
            if (avgDirEl) avgDirEl.textContent = avgDir.toFixed(0) + '¬∞';
            
            log('info', `üåç M√©dia Ponderada (${validModels} modelos): ${weightedSpeed.toFixed(1)} kn de ${avgDir.toFixed(0)}¬∞`);
        }
    }
    
    function clearOpenMeteoData() {
        windDataPoints = windDataPoints.filter(p => 
            !p.source.includes('GFS') && !p.source.includes('ECMWF') && 
            !p.source.includes('ICON') && p.source !== 'Open-Meteo'
        );
        MODELS.forEach(m => modelData[m] = { speed: null, direction: null });
        allForecastData = {};
        
        const avgSpeedEl = document.getElementById('avg-model-speed');
        const avgDirEl = document.getElementById('avg-model-dir');
        const forecastSpeedEl = document.getElementById('forecast-speed');
        const forecastDirEl = document.getElementById('forecast-dir');
        const forecastGustEl = document.getElementById('forecast-gust');
        
        if (avgSpeedEl) avgSpeedEl.textContent = '--';
        if (avgDirEl) avgDirEl.textContent = '--';
        if (forecastSpeedEl) forecastSpeedEl.textContent = '--';
        if (forecastDirEl) forecastDirEl.textContent = '--';
        if (forecastGustEl) forecastGustEl.textContent = '--';
        
        updateWindDisplay();
        setStatus('openmeteo-status', '');
        log('info', 'üóëÔ∏è Dados de modelos removidos');
    }
    
    function processNOAAData(data, hasDirectSpeed = false) {
        if (!data.table || !data.table.rows) {
            log('warning', 'Dados NOAA vazios');
            return;
        }
        
        const rows = data.table.rows;
        const columnNames = data.table.columnNames || [];
        let count = 0;
        
        // Detectar formato das colunas
        const hasWindSpeed = columnNames.includes('wind_speed');
        const hasWindDirection = columnNames.includes('wind_direction');
        
        rows.forEach(row => {
            // Detectar estrutura baseado no n√∫mero de colunas
            // Com altitude: [time, altitude, lat, lon, wind_speed, wind_direction]
            // Sem altitude: [time, lat, lon, wind_speed, wind_direction]
            const hasAltitude = columnNames.includes('altitude');
            const offset = hasAltitude ? 1 : 0;
            
            const time = new Date(row[0]);
            const lat = row[1 + offset];
            const lon = row[2 + offset];
            
            let speed, direction;
            
            if (hasDirectSpeed || hasWindSpeed) {
                // Formato com wind_speed e wind_direction diretos
                speed = row[3 + offset];  // j√° em m/s
                direction = row[4 + offset];  // j√° em graus
                
                if (speed !== null && direction !== null) {
                    speed = speed * 1.94384;  // m/s para knots
                }
            } else {
                // Formato com componentes u/v
                const u = row[3 + offset];  // componente x
                const v = row[4 + offset];  // componente y
                
                if (u !== null && v !== null) {
                    // Calcular velocidade e dire√ß√£o
                    speed = Math.sqrt(u*u + v*v) * 1.94384;  // m/s para knots
                    direction = (Math.atan2(-u, -v) * 180 / Math.PI + 360) % 360;
                }
            }
            
            if (speed !== null && direction !== null && !isNaN(speed) && !isNaN(direction)) {
                addWindPoint({
                    lat: lat,
                    lon: lon,
                    speed: speed,
                    direction: direction,
                    time: time,
                    source: 'NOAA ASCAT'
                });
                count++;
            }
        });
        
        updateWindDisplay();
        log('success', `‚úÖ NOAA: ${count} pontos carregados`);
    }
    
    // =========================================================================
    // BUSCAR DADOS - COPERNICUS MARINE
    // =========================================================================
    async function fetchCopernicusData() {
        const user = document.getElementById('cmems-user').value;
        const pass = document.getElementById('cmems-pass').value;
        
        if (!user || !pass) {
            log('warning', 'CMEMS: Insira usu√°rio e senha');
            return;
        }
        
        setStatus('cmems-status', 'loading');
        log('info', 'Buscando dados Copernicus Marine...');
        
        // CMEMS usa WMS/WCS - precisamos de uma abordagem diferente
        // Para uso real, seria necess√°rio usar o copernicusmarine Python client
        // Aqui vamos mostrar como seria a URL
        
        const datasetId = 'WIND_GLO_PHY_L4_NRT_012_004';  // Global wind L4
        
        log('info', `Dataset: ${datasetId}`);
        log('warning', 'CMEMS requer autentica√ß√£o OAuth - use o Python client');
        log('info', 'Comando: pip install copernicusmarine');
        log('info', 'copernicusmarine subset -i ' + datasetId);
        
        // Mostrar instru√ß√µes
        alert(`Para acessar dados Copernicus Marine:

1. Instale o cliente Python:
   pip install copernicusmarine

2. Configure credenciais:
   copernicusmarine login

3. Baixe dados de vento:
   copernicusmarine subset \
     --dataset-id WIND_GLO_PHY_L4_NRT_012_004 \
     --variable eastward_wind \
     --variable northward_wind \
     --minimum-longitude ${CONFIG.lonMin} \
     --maximum-longitude ${CONFIG.lonMax} \
     --minimum-latitude ${CONFIG.latMin} \
     --maximum-latitude ${CONFIG.latMax}`);
        
        setStatus('cmems-status', 'error');
    }
    
    // =========================================================================
    // BUSCAR DADOS - NASA EARTHDATA
    // =========================================================================
    async function fetchNASAData() {
        const user = document.getElementById('nasa-user').value;
        const pass = document.getElementById('nasa-pass').value;
        
        if (!user || !pass) {
            log('warning', 'NASA: Insira usu√°rio e senha');
            return;
        }
        
        setStatus('nasa-status', 'loading');
        log('info', 'Buscando dados NASA Earthdata (CYGNSS)...');
        
        // NASA Earthdata tamb√©m requer autentica√ß√£o especial
        // CYGNSS √© um constela√ß√£o de 8 sat√©lites que mede vento oce√¢nico
        
        log('info', 'Datasets dispon√≠veis:');
        log('info', '- CYGNSS L2 Ocean Surface Wind Speed');
        log('info', '- QuikSCAT Level 2B (hist√≥rico)');
        log('info', '- RapidSCAT Level 2B (hist√≥rico)');
        
        log('warning', 'NASA Earthdata requer token de autentica√ß√£o');
        log('info', 'Use: https://search.earthdata.nasa.gov');
        
        setStatus('nasa-status', 'error');
    }
    
    // =========================================================================
    // FUN√á√ïES DE VISUALIZA√á√ÉO
    // =========================================================================
    function addWindPoint(point) {
        windDataPoints.push(point);
    }
    
    function updateWindDisplay() {
        windLayerGroup.clearLayers();
        
        if (windDataPoints.length === 0) return;
        
        const now = new Date();
        const maxAgeMs = MAX_DATA_AGE_MINUTES * 60 * 1000;  // Converter para milissegundos
        
        // FILTRAR dados que est√£o dentro do limite de idade (60 min)
        const recentPoints = windDataPoints.filter(point => {
            const ageMs = now - point.time;
            return ageMs <= maxAgeMs;
        });
        
        // Contar quantos foram descartados
        const discardedCount = windDataPoints.length - recentPoints.length;
        if (discardedCount > 0) {
            log('warning', `‚ö†Ô∏è ${discardedCount} pontos descartados (mais de ${MAX_DATA_AGE_MINUTES} min de atraso)`);
        }
        
        // Atualizar array global apenas com dados recentes
        windDataPoints = recentPoints;
        
        if (windDataPoints.length === 0) {
            log('warning', `‚ùå Nenhum dado com menos de ${MAX_DATA_AGE_MINUTES} min de idade`);
            document.getElementById('avg-wind').textContent = '--';
            document.getElementById('max-wind').textContent = '--';
            document.getElementById('data-points').textContent = '0';
            document.getElementById('data-age').textContent = '--';
            setStatus('wind-status', 'error');
            return;
        }
        
        let totalSpeed = 0;
        let maxSpeed = 0;
        let latestTime = new Date(0);
        
        windDataPoints.forEach(point => {
            // Desenhar seta
            drawWindArrow(point.lat, point.lon, point.direction, point.speed, point.source);
            
            // Estat√≠sticas
            totalSpeed += point.speed;
            if (point.speed > maxSpeed) maxSpeed = point.speed;
            if (point.time > latestTime) latestTime = point.time;
        });
        
        // Atualizar painel
        const avgSpeed = totalSpeed / windDataPoints.length;
        const ageMinutes = (now - latestTime) / (1000 * 60);  // Idade em minutos
        
        document.getElementById('avg-wind').textContent = avgSpeed.toFixed(1);
        document.getElementById('max-wind').textContent = maxSpeed.toFixed(1);
        document.getElementById('data-points').textContent = windDataPoints.length;
        document.getElementById('data-age').textContent = ageMinutes.toFixed(0) + ' min';
        
        // Status baseado na idade
        if (ageMinutes <= 30) {
            setStatus('wind-status', 'active');
        } else if (ageMinutes <= MAX_DATA_AGE_MINUTES) {
            setStatus('wind-status', 'loading');  // Amarelo para dados entre 30-60 min
        } else {
            setStatus('wind-status', 'error');
        }
    }
    
    function drawWindArrow(lat, lon, direction, speed, source) {
        // Cor baseada na velocidade - ESCALA UNIFICADA (igual ao DMW)
        let color;
        if (speed < 10) color = '#00ff00';       // Verde - Calmo (0-10 kn)
        else if (speed < 15) color = '#88ff00'; // Verde claro - Leve (10-15 kn)
        else if (speed < 20) color = '#ffff00'; // Amarelo - Moderado (15-20 kn)
        else if (speed < 25) color = '#ff9900'; // Laranja - Fresco (20-25 kn)
        else if (speed < 30) color = '#ff0000'; // Vermelho - Forte (25-30 kn)
        else color = '#ff00ff';                  // Roxo/Magenta - Muito forte (>30 kn)
        
        // ESCATER√îMETROS: √≠cone maior, borda destacada, zIndex alto
        const isScatterometer = source.includes('ASCAT') || source.includes('NOAA') || 
                                source.includes('CYGNSS') || source.includes('Copernicus') ||
                                source.includes('Scatterometer');
        
        const size = isScatterometer ? 36 : 22;
        const fontSize = isScatterometer ? '11px' : '9px';
        const borderStyle = isScatterometer ? `border: 2px solid ${color}; border-radius: 50%; background: rgba(0,0,0,0.7); padding: 3px;` : '';
        const zIndex = isScatterometer ? 1000 : 100;
        
        // DIRE√á√ÉO: Valor indica DE ONDE o vento vem (conven√ß√£o meteorol√≥gica)
        // Seta aponta PARA ONDE o vento vai (rota√ß√£o +180¬∞)
        // Ex: Vento de 0¬∞ (Norte) -> seta aponta para Sul (180¬∞)
        const arrowRotation = (direction + 180) % 360;  // Rotaciona 180¬∞
        
        const arrowHtml = `
            <div style="${borderStyle} transform: rotate(${arrowRotation}deg); width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center;">
                <svg viewBox="0 0 24 24" width="${size - 8}" height="${size - 8}">
                    <path fill="${color}" stroke="${isScatterometer ? '#fff' : 'none'}" stroke-width="${isScatterometer ? 1 : 0}" d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
                </svg>
            </div>
            <div style="text-align:center; font-size:${fontSize}; font-weight:bold; color:${color}; text-shadow: 1px 1px 2px black;">
                ${speed.toFixed(0)}${isScatterometer ? '‚óÜ' : ''}
            </div>
        `;

        const icon = L.divIcon({
            className: 'wind-arrow' + (isScatterometer ? ' scatterometer' : ' openmeteo'),
            html: arrowHtml,
            iconSize: [size, size + 12],
            iconAnchor: [size/2, (size + 12)/2]
        });

        L.marker([lat, lon], { icon: icon, zIndexOffset: zIndex })
            .bindPopup(`
                <b>Dados de Vento</b><br>
                Velocidade: ${speed.toFixed(1)} kn<br>
                Dire√ß√£o: ${direction.toFixed(0)}¬∞<br>
                Fonte: ${source}<br>
                Lat: ${lat.toFixed(3)}<br>
                Lon: ${lon.toFixed(3)}
            `)
            .addTo(windLayerGroup);
    }
    
    // =========================================================================
    // FUN√á√ïES AUXILIARES
    // =========================================================================
    function log(type, message) {
        const logArea = document.getElementById('log-area');
        const time = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${time}] ${message}`;
        logArea.appendChild(entry);
        logArea.scrollTop = logArea.scrollHeight;
    }
    
    function setStatus(elementId, status) {
        const el = document.getElementById(elementId);
        if (el) {
            el.className = 'status-indicator ' + status;
        }
    }
    
    function saveCmemsCredentials() {
        const user = document.getElementById('cmems-user').value;
        const pass = document.getElementById('cmems-pass').value;
        localStorage.setItem('cmems-user', user);
        localStorage.setItem('cmems-pass', pass);
        log('success', 'Credenciais CMEMS salvas');
    }
    
    function saveNasaCredentials() {
        const user = document.getElementById('nasa-user').value;
        const pass = document.getElementById('nasa-pass').value;
        localStorage.setItem('nasa-user', user);
        localStorage.setItem('nasa-pass', pass);
        log('success', 'Credenciais NASA salvas');
    }
    
    function loadSavedCredentials() {
        // Credenciais desabilitadas - escater√¥metros t√™m atraso > 60 min
        // Apenas Open-Meteo (tempo real) est√° habilitado
    }
    
    function fetchAllSources() {
        log('info', `‚è±Ô∏è Limite de idade: ${MAX_DATA_AGE_MINUTES} minutos`);
        log('info', 'üåê Buscando dados em TEMPO REAL...');
        
        // Atualizar dados de vento Open-Meteo
        fetchOpenMeteoData();
        
        // Atualizar imagem de sat√©lite se habilitado
        if (satelliteEnabled) {
            loadSatelliteLayer();
        }
        
        // Atualizar dados DMW (ventos derivados de movimento) se habilitado
        if (dmwEnabled) {
            loadDMWWinds();
        }
        
        // Atualizar dados SCAT (scatter√¥metro) se habilitado
        if (scatEnabled) {
            loadScatWinds();
        }
        
        // Atualizar dados L2 (CAPE, LI, TPW) se habilitado
        if (l2Enabled) {
            loadL2Data();
        }
        
        log('info', '‚úÖ Fontes atualizadas: Open-Meteo, Sat√©lite, DMW, SCAT, L2');
    }
    
    function clearData() {
        windDataPoints = [];
        windLayerGroup.clearLayers();
        document.getElementById('avg-wind').textContent = '--';
        document.getElementById('max-wind').textContent = '--';
        document.getElementById('data-points').textContent = '--';
        document.getElementById('data-age').textContent = '--';
        setStatus('wind-status', '');
        log('info', 'Dados limpos');
    }
    
    function exportData() {
        if (windDataPoints.length === 0) {
            log('warning', 'Nenhum dado para exportar');
            return;
        }
        
        let csv = 'latitude,longitude,wind_speed_kn,wind_direction,source,timestamp\n';
        windDataPoints.forEach(p => {
            csv += `${p.lat},${p.lon},${p.speed.toFixed(2)},${p.direction.toFixed(1)},${p.source},${p.time.toISOString()}\n`;
        });
        
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `scatterometer_data_${new Date().toISOString().slice(0,10)}.csv`;
        a.click();
        
        log('success', 'Dados exportados para CSV');
    }
    
    // =========================================================================
    // INICIAR
    // =========================================================================
    initMap();
</script>

</body>
</html>
