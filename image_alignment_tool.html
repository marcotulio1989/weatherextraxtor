<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ∞Ô∏è Ferramenta de Alinhamento de Imagem Sat√©lite</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Painel de Controle */
        .control-panel {
            width: 320px;
            background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            z-index: 1000;
        }

        .control-panel h1 {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #e94560;
            text-align: center;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }

        .control-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(15, 52, 96, 0.5);
            border-radius: 10px;
        }

        .control-section h3 {
            color: #00d9ff;
            margin-bottom: 12px;
            font-size: 0.95em;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .control-row label {
            flex: 0 0 80px;
            font-size: 0.85em;
            color: #aaa;
        }

        .control-row input[type="range"] {
            flex: 1;
            accent-color: #e94560;
        }

        .control-row input[type="number"] {
            width: 70px;
            padding: 5px;
            border: 1px solid #0f3460;
            background: #1a1a2e;
            color: #fff;
            border-radius: 5px;
            text-align: center;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e94560, #c23a51);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #0f3460, #16213e);
            color: #00d9ff;
            border: 1px solid #00d9ff;
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894, #00a381);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
            color: #1a1a2e;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* √Årea do Mapa */
        .map-area {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Overlay da Imagem */
        .image-overlay-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 500;
        }

        .satellite-image {
            position: absolute;
            transform-origin: center center;
            pointer-events: auto;
            cursor: move;
        }

        /* Pontos de Controle */
        .control-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #e94560;
            border: 3px solid white;
            border-radius: 50%;
            cursor: grab;
            z-index: 1000;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.8);
            transition: transform 0.1s;
        }

        .control-point:hover {
            transform: scale(1.3);
            background: #00d9ff;
        }

        .control-point:active {
            cursor: grabbing;
        }

        .control-point.corner-tl { background: #ff6b6b; }
        .control-point.corner-tr { background: #4ecdc4; }
        .control-point.corner-bl { background: #ffe66d; }
        .control-point.corner-br { background: #95e1d3; }

        /* Info Panel */
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 340px;
            background: rgba(26, 26, 46, 0.95);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid #0f3460;
            z-index: 1000;
            max-width: 400px;
        }

        .info-panel h4 {
            color: #00d9ff;
            margin-bottom: 10px;
        }

        .info-panel pre {
            font-size: 0.75em;
            color: #aaa;
            white-space: pre-wrap;
            max-height: 150px;
            overflow-y: auto;
        }

        /* Instru√ß√µes */
        .instructions {
            font-size: 0.8em;
            color: #888;
            line-height: 1.5;
            margin-top: 10px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        /* Coordenadas dos pontos */
        .coords-display {
            font-family: monospace;
            font-size: 0.75em;
            background: #0a0a15;
            padding: 10px;
            border-radius: 5px;
            max-height: 120px;
            overflow-y: auto;
        }

        /* Toggle para visibilidade */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #0f3460;
            transition: 0.4s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #00d9ff;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        /* Modal de Salvamento */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #16213e;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #00d9ff;
            margin-bottom: 20px;
        }

        .modal-content pre {
            background: #0a0a15;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.8em;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 2em;
            color: #e94560;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Painel de Controle -->
        <div class="control-panel">
            <h1>üõ∞Ô∏è Alinhamento de Sat√©lite</h1>

            <!-- Baixar Imagem Sat√©lite -->
            <div class="control-section">
                <h3>üõ∞Ô∏è Carregar Imagem Sat√©lite</h3>
                <select id="satelliteProduct" style="width: 100%; padding: 8px; background: #1a1a2e; border: 1px solid #0f3460; color: #fff; border-radius: 5px; margin-bottom: 10px;">
                    <optgroup label="GOES-16 Am√©rica do Sul">
                        <option value="goes16-ssa-ch13">GOES-16 SSA - Infravermelho (Ch13)</option>
                        <option value="goes16-ssa-ch02">GOES-16 SSA - Vis√≠vel (Ch02)</option>
                        <option value="goes16-ssa-ch08">GOES-16 SSA - Vapor d'√Ågua (Ch08)</option>
                    </optgroup>
                    <optgroup label="GOES-16 Brasil">
                        <option value="goes16-br-ch13">GOES-16 Brasil - Infravermelho</option>
                    </optgroup>
                    <optgroup label="Windy.com (Funciona direto!)">
                        <option value="windy-satellite">Windy Sat√©lite IR</option>
                        <option value="windy-radar">Windy Radar</option>
                    </optgroup>
                </select>
                <button class="btn btn-primary" onclick="fetchSatelliteImage()" id="btnFetchSat">
                    üîÑ Buscar Imagem do Sat√©lite
                </button>
                <button class="btn btn-secondary" onclick="openCPTECPage()" style="margin-top:5px;">
                    üåê Abrir CPTEC (salvar manualmente)
                </button>
                <div id="satStatus" style="font-size: 0.8em; color: #888; margin-top: 8px;"></div>
            </div>

            <!-- Carregar Imagem -->
            <div class="control-section">
                <h3>üìÅ Ou Carregar Imagem Manual</h3>
                <div class="file-input-wrapper">
                    <button class="btn btn-secondary">Selecionar Arquivo</button>
                    <input type="file" id="imageInput" accept="image/*">
                </div>
                <input type="text" id="imageUrl" placeholder="Ou cole URL da imagem..." 
                       style="width: 100%; padding: 8px; margin-top: 10px; background: #1a1a2e; border: 1px solid #0f3460; color: #fff; border-radius: 5px;">
                <button class="btn btn-secondary" onclick="loadImageFromUrl()" style="margin-top: 10px;">Carregar URL</button>
            </div>

            <!-- Transforma√ß√µes Globais -->
            <div class="control-section">
                <h3>üîÑ Transforma√ß√µes Globais</h3>
                
                <div class="control-row">
                    <label>Rota√ß√£o:</label>
                    <input type="range" id="rotation" min="-180" max="180" value="0" step="0.1">
                    <input type="number" id="rotationValue" value="0" step="0.1">
                </div>

                <div class="control-row">
                    <label>Escala X:</label>
                    <input type="range" id="scaleX" min="0.1" max="3" value="1" step="0.01">
                    <input type="number" id="scaleXValue" value="1" step="0.01">
                </div>

                <div class="control-row">
                    <label>Escala Y:</label>
                    <input type="range" id="scaleY" min="0.1" max="3" value="1" step="0.01">
                    <input type="number" id="scaleYValue" value="1" step="0.01">
                </div>

                <div class="control-row">
                    <label>Opacidade:</label>
                    <input type="range" id="opacity" min="0" max="1" value="0.7" step="0.05">
                    <input type="number" id="opacityValue" value="0.7" step="0.05">
                </div>

                <div class="control-row">
                    <label>Skew X:</label>
                    <input type="range" id="skewX" min="-45" max="45" value="0" step="0.5">
                    <input type="number" id="skewXValue" value="0" step="0.5">
                </div>

                <div class="control-row">
                    <label>Skew Y:</label>
                    <input type="range" id="skewY" min="-45" max="45" value="0" step="0.5">
                    <input type="number" id="skewYValue" value="0" step="0.5">
                </div>
            </div>

            <!-- Perspectiva (Distor√ß√£o 3D) -->
            <div class="control-section">
                <h3>üìê Perspectiva 3D</h3>
                
                <div class="control-row">
                    <label>Perspectiva:</label>
                    <input type="range" id="perspective" min="100" max="2000" value="1000" step="10">
                    <input type="number" id="perspectiveValue" value="1000" step="10">
                </div>

                <div class="control-row">
                    <label>Rot. X:</label>
                    <input type="range" id="rotateX" min="-60" max="60" value="0" step="0.5">
                    <input type="number" id="rotateXValue" value="0" step="0.5">
                </div>

                <div class="control-row">
                    <label>Rot. Y:</label>
                    <input type="range" id="rotateY" min="-60" max="60" value="0" step="0.5">
                    <input type="number" id="rotateYValue" value="0" step="0.5">
                </div>
            </div>

            <!-- Visibilidade -->
            <div class="control-section">
                <h3>üëÅÔ∏è Visibilidade</h3>
                
                <div class="toggle-container">
                    <span>Mostrar Imagem</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showImage" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>

                <div class="toggle-container">
                    <span>Mostrar Pontos de Controle</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showControlPoints" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>

                <div class="toggle-container">
                    <span>Bloquear Arraste</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="lockDrag">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <!-- A√ß√µes -->
            <div class="control-section">
                <h3>‚ö° A√ß√µes</h3>
                <button class="btn btn-warning" onclick="resetTransformations()">üîÑ Resetar Tudo</button>
                <button class="btn btn-success" onclick="saveAlignment()">üíæ Salvar Alinhamento</button>
                <button class="btn btn-secondary" onclick="exportAsJSON()">üì§ Exportar JSON</button>
                <button class="btn btn-secondary" onclick="loadFromJSON()">üì• Importar JSON</button>
            </div>

            <!-- Coordenadas -->
            <div class="control-section">
                <h3>üìç Coordenadas dos Pontos</h3>
                <div id="coordsDisplay" class="coords-display">
                    Carregue uma imagem para ver as coordenadas
                </div>
            </div>

            <!-- Instru√ß√µes -->
            <div class="control-section">
                <h3>üìñ Instru√ß√µes</h3>
                <ul class="instructions">
                    <li>Carregue uma imagem de sat√©lite</li>
                    <li>Arraste a imagem para posicionar</li>
                    <li>Use os pontos coloridos nos cantos para distorcer</li>
                    <li>Ajuste rota√ß√£o, escala e perspectiva</li>
                    <li>Clique em "Salvar Alinhamento" quando terminar</li>
                </ul>
            </div>
        </div>

        <!-- √Årea do Mapa -->
        <div class="map-area">
            <div id="map"></div>
            <div class="image-overlay-container" id="overlayContainer">
                <!-- A imagem de sat√©lite ser√° inserida aqui -->
            </div>
        </div>
    </div>

    <!-- Modal de Resultado -->
    <div class="modal" id="resultModal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal()">&times;</span>
            <h2>‚úÖ Alinhamento Salvo!</h2>
            <p>Par√¢metros de transforma√ß√£o capturados:</p>
            <pre id="resultJSON"></pre>
            <button class="btn btn-primary" onclick="copyToClipboard()" style="margin-top: 15px;">üìã Copiar JSON</button>
            <button class="btn btn-secondary" onclick="downloadJSON()" style="margin-top: 10px;">üíæ Baixar Arquivo</button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // ===== INICIALIZA√á√ÉO =====
        let map;
        let imageElement = null;
        let controlPoints = [];
        let isDragging = false;
        let dragTarget = null;
        let dragOffset = { x: 0, y: 0 };
        let imagePosition = { x: 0, y: 0 };
        let originalImageSize = { width: 0, height: 0 };

        // Pontos de controle originais (relativos √† imagem)
        let cornerOffsets = {
            tl: { x: 0, y: 0 },
            tr: { x: 0, y: 0 },
            bl: { x: 0, y: 0 },
            br: { x: 0, y: 0 }
        };

        // Inicializar mapa
        function initMap() {
            // Centralizado em Campos dos Goytacazes / regi√£o costeira
            map = L.map('map', {
                center: [-22.0, -41.0],
                zoom: 7,
                zoomControl: true
            });

            // Camadas de mapa
            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap'
            });

            const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri'
            });

            const topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenTopoMap'
            });

            // Adicionar camada padr√£o
            osmLayer.addTo(map);

            // Controle de camadas
            L.control.layers({
                'OpenStreetMap': osmLayer,
                'Sat√©lite (Esri)': satelliteLayer,
                'Topogr√°fico': topoLayer
            }).addTo(map);

            // Adicionar escala
            L.control.scale({ imperial: false }).addTo(map);
        }

        // ===== ABRIR CPTEC =====
        function openCPTECPage() {
            window.open('http://satelite.cptec.inpe.br/acervo/goes16.formulario.logic?i=br', '_blank');
        }

        // ===== BUSCAR IMAGEM SAT√âLITE =====
        async function fetchSatelliteImage() {
            const product = document.getElementById('satelliteProduct').value;
            const status = document.getElementById('satStatus');
            const btn = document.getElementById('btnFetchSat');
            
            btn.disabled = true;
            status.innerHTML = '‚è≥ Buscando imagem...';
            status.style.color = '#ffff00';

            // URLs que funcionam sem CORS
            const imageUrls = {
                // Windy tiles (funciona!)
                'windy-satellite': 'https://ims.windy.com/sat/satellite/satellite/2026/01/06/12/satellite_2026010612.jpg',
                'windy-radar': 'https://ims.windy.com/radar/radar/2026/01/06/12/radar_2026010612.jpg',
                
                // NOAA GOES (geralmente funciona)
                'goes16-ssa-ch13': 'https://cdn.star.nesdis.noaa.gov/GOES16/ABI/SECTOR/ssa/13/latest.jpg',
                'goes16-ssa-ch02': 'https://cdn.star.nesdis.noaa.gov/GOES16/ABI/SECTOR/ssa/02/latest.jpg',
                'goes16-ssa-ch08': 'https://cdn.star.nesdis.noaa.gov/GOES16/ABI/SECTOR/ssa/08/latest.jpg',
                'goes16-br-ch13': 'https://cdn.star.nesdis.noaa.gov/GOES16/ABI/SECTOR/ssa/GEOCOLOR/latest.jpg',
            };

            const url = imageUrls[product];
            
            if (!url) {
                status.innerHTML = '‚ùå Produto n√£o dispon√≠vel';
                status.style.color = '#ff4444';
                btn.disabled = false;
                return;
            }

            try {
                // Tentar carregar a imagem
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = function() {
                    loadImage(url);
                    status.innerHTML = '‚úÖ Imagem carregada! Agora alinhe com o mapa.';
                    status.style.color = '#00ff00';
                    btn.disabled = false;
                };
                
                img.onerror = function() {
                    // Se falhar CORS, tentar sem crossOrigin
                    status.innerHTML = '‚ö†Ô∏è Carregando (pode ter restri√ß√£o CORS)...';
                    loadImage(url);
                    status.style.color = '#ffaa00';
                    btn.disabled = false;
                };
                
                img.src = url;
                
            } catch (error) {
                status.innerHTML = `‚ùå Erro: ${error.message}`;
                status.style.color = '#ff4444';
                btn.disabled = false;
            }
        }

        // ===== CARREGAMENTO DE IMAGEM =====
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    loadImage(event.target.result);
                };
                reader.readAsDataURL(file);
            }
        });

        function loadImageFromUrl() {
            const url = document.getElementById('imageUrl').value;
            if (url) {
                loadImage(url);
            }
        }

        function loadImage(src) {
            const container = document.getElementById('overlayContainer');
            
            // Remover imagem anterior
            if (imageElement) {
                imageElement.remove();
                controlPoints.forEach(p => p.remove());
                controlPoints = [];
            }

            // Criar nova imagem
            imageElement = document.createElement('img');
            imageElement.src = src;
            imageElement.className = 'satellite-image';
            imageElement.id = 'satelliteImage';
            
            imageElement.onload = function() {
                originalImageSize = {
                    width: this.naturalWidth,
                    height: this.naturalHeight
                };

                // Ajustar tamanho inicial
                const containerRect = container.getBoundingClientRect();
                const scale = Math.min(
                    containerRect.width * 0.6 / this.naturalWidth,
                    containerRect.height * 0.6 / this.naturalHeight
                );
                
                this.style.width = (this.naturalWidth * scale) + 'px';
                this.style.height = (this.naturalHeight * scale) + 'px';

                // Posicionar no centro
                imagePosition.x = (containerRect.width - this.naturalWidth * scale) / 2;
                imagePosition.y = (containerRect.height - this.naturalHeight * scale) / 2;
                
                updateImageTransform();
                createControlPoints();
                updateCoordsDisplay();
            };

            container.appendChild(imageElement);
            setupImageDrag();
        }

        // ===== PONTOS DE CONTROLE =====
        function createControlPoints() {
            const container = document.getElementById('overlayContainer');
            const corners = ['tl', 'tr', 'bl', 'br'];
            const labels = ['Top-Left', 'Top-Right', 'Bottom-Left', 'Bottom-Right'];
            const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];

            corners.forEach((corner, index) => {
                const point = document.createElement('div');
                point.className = `control-point corner-${corner}`;
                point.dataset.corner = corner;
                point.title = labels[index];
                container.appendChild(point);
                controlPoints.push(point);

                // Reset offset
                cornerOffsets[corner] = { x: 0, y: 0 };

                setupControlPointDrag(point, corner);
            });

            updateControlPointsPosition();
        }

        function updateControlPointsPosition() {
            if (!imageElement) return;

            const rect = imageElement.getBoundingClientRect();
            const containerRect = document.getElementById('overlayContainer').getBoundingClientRect();

            const positions = {
                tl: { x: rect.left - containerRect.left, y: rect.top - containerRect.top },
                tr: { x: rect.right - containerRect.left, y: rect.top - containerRect.top },
                bl: { x: rect.left - containerRect.left, y: rect.bottom - containerRect.top },
                br: { x: rect.right - containerRect.left, y: rect.bottom - containerRect.top }
            };

            controlPoints.forEach(point => {
                const corner = point.dataset.corner;
                const pos = positions[corner];
                const offset = cornerOffsets[corner];
                
                point.style.left = (pos.x + offset.x - 10) + 'px';
                point.style.top = (pos.y + offset.y - 10) + 'px';
            });
        }

        function setupControlPointDrag(point, corner) {
            point.addEventListener('mousedown', function(e) {
                if (document.getElementById('lockDrag').checked) return;
                e.stopPropagation();
                isDragging = true;
                dragTarget = { type: 'control', corner: corner, element: point };
                
                const rect = point.getBoundingClientRect();
                dragOffset = {
                    x: e.clientX - rect.left - 10,
                    y: e.clientY - rect.top - 10
                };
            });
        }

        // ===== ARRASTE DA IMAGEM =====
        function setupImageDrag() {
            imageElement.addEventListener('mousedown', function(e) {
                if (document.getElementById('lockDrag').checked) return;
                if (e.target.classList.contains('control-point')) return;
                
                isDragging = true;
                dragTarget = { type: 'image', element: imageElement };
                dragOffset = {
                    x: e.clientX - imagePosition.x,
                    y: e.clientY - imagePosition.y
                };
            });
        }

        // ===== EVENT LISTENERS GLOBAIS =====
        document.addEventListener('mousemove', function(e) {
            if (!isDragging || !dragTarget) return;

            if (dragTarget.type === 'image') {
                imagePosition.x = e.clientX - dragOffset.x;
                imagePosition.y = e.clientY - dragOffset.y;
                updateImageTransform();
                updateControlPointsPosition();
            } else if (dragTarget.type === 'control') {
                const containerRect = document.getElementById('overlayContainer').getBoundingClientRect();
                const imageRect = imageElement.getBoundingClientRect();
                
                const corner = dragTarget.corner;
                let basePos;
                
                switch(corner) {
                    case 'tl':
                        basePos = { x: imageRect.left - containerRect.left, y: imageRect.top - containerRect.top };
                        break;
                    case 'tr':
                        basePos = { x: imageRect.right - containerRect.left, y: imageRect.top - containerRect.top };
                        break;
                    case 'bl':
                        basePos = { x: imageRect.left - containerRect.left, y: imageRect.bottom - containerRect.top };
                        break;
                    case 'br':
                        basePos = { x: imageRect.right - containerRect.left, y: imageRect.bottom - containerRect.top };
                        break;
                }

                const newX = e.clientX - containerRect.left - dragOffset.x;
                const newY = e.clientY - containerRect.top - dragOffset.y;

                cornerOffsets[corner] = {
                    x: newX - basePos.x + 10,
                    y: newY - basePos.y + 10
                };

                updateControlPointsPosition();
                applyPerspectiveDistortion();
            }

            updateCoordsDisplay();
        });

        document.addEventListener('mouseup', function() {
            isDragging = false;
            dragTarget = null;
        });

        // ===== TRANSFORMA√á√ïES =====
        function updateImageTransform() {
            if (!imageElement) return;

            const rotation = parseFloat(document.getElementById('rotation').value);
            const scaleX = parseFloat(document.getElementById('scaleX').value);
            const scaleY = parseFloat(document.getElementById('scaleY').value);
            const opacity = parseFloat(document.getElementById('opacity').value);
            const skewX = parseFloat(document.getElementById('skewX').value);
            const skewY = parseFloat(document.getElementById('skewY').value);
            const perspective = parseFloat(document.getElementById('perspective').value);
            const rotateX = parseFloat(document.getElementById('rotateX').value);
            const rotateY = parseFloat(document.getElementById('rotateY').value);

            imageElement.style.left = imagePosition.x + 'px';
            imageElement.style.top = imagePosition.y + 'px';
            imageElement.style.opacity = opacity;

            const transform = `
                perspective(${perspective}px)
                rotateX(${rotateX}deg)
                rotateY(${rotateY}deg)
                rotate(${rotation}deg)
                scaleX(${scaleX})
                scaleY(${scaleY})
                skewX(${skewX}deg)
                skewY(${skewY}deg)
            `;

            imageElement.style.transform = transform;
            
            setTimeout(updateControlPointsPosition, 10);
        }

        function applyPerspectiveDistortion() {
            if (!imageElement) return;

            // Calcular matriz de transforma√ß√£o baseada nos offsets dos cantos
            const tl = cornerOffsets.tl;
            const tr = cornerOffsets.tr;
            const bl = cornerOffsets.bl;
            const br = cornerOffsets.br;

            // Usar CSS matrix3d para distor√ß√£o baseada nos pontos de controle
            // Isso √© uma aproxima√ß√£o - distor√ß√£o real requer c√°lculos mais complexos
            const avgSkewX = ((tr.x - tl.x) + (br.x - bl.x)) / 2;
            const avgSkewY = ((bl.y - tl.y) + (br.y - tr.y)) / 2;
            
            // Atualizar skew baseado nos pontos
            // document.getElementById('skewX').value = avgSkewX / 5;
            // document.getElementById('skewXValue').value = avgSkewX / 5;
        }

        // ===== SINCRONIZA√á√ÉO DE CONTROLES =====
        const controls = ['rotation', 'scaleX', 'scaleY', 'opacity', 'skewX', 'skewY', 'perspective', 'rotateX', 'rotateY'];

        controls.forEach(control => {
            const slider = document.getElementById(control);
            const value = document.getElementById(control + 'Value');

            slider.addEventListener('input', function() {
                value.value = this.value;
                updateImageTransform();
            });

            value.addEventListener('change', function() {
                slider.value = this.value;
                updateImageTransform();
            });
        });

        // Toggles
        document.getElementById('showImage').addEventListener('change', function() {
            if (imageElement) {
                imageElement.style.display = this.checked ? 'block' : 'none';
            }
        });

        document.getElementById('showControlPoints').addEventListener('change', function() {
            controlPoints.forEach(p => {
                p.style.display = this.checked ? 'block' : 'none';
            });
        });

        // ===== FUN√á√ïES DE A√á√ÉO =====
        function resetTransformations() {
            document.getElementById('rotation').value = 0;
            document.getElementById('rotationValue').value = 0;
            document.getElementById('scaleX').value = 1;
            document.getElementById('scaleXValue').value = 1;
            document.getElementById('scaleY').value = 1;
            document.getElementById('scaleYValue').value = 1;
            document.getElementById('opacity').value = 0.7;
            document.getElementById('opacityValue').value = 0.7;
            document.getElementById('skewX').value = 0;
            document.getElementById('skewXValue').value = 0;
            document.getElementById('skewY').value = 0;
            document.getElementById('skewYValue').value = 0;
            document.getElementById('perspective').value = 1000;
            document.getElementById('perspectiveValue').value = 1000;
            document.getElementById('rotateX').value = 0;
            document.getElementById('rotateXValue').value = 0;
            document.getElementById('rotateY').value = 0;
            document.getElementById('rotateYValue').value = 0;

            cornerOffsets = {
                tl: { x: 0, y: 0 },
                tr: { x: 0, y: 0 },
                bl: { x: 0, y: 0 },
                br: { x: 0, y: 0 }
            };

            if (imageElement) {
                const containerRect = document.getElementById('overlayContainer').getBoundingClientRect();
                imagePosition.x = (containerRect.width - imageElement.offsetWidth) / 2;
                imagePosition.y = (containerRect.height - imageElement.offsetHeight) / 2;
            }

            updateImageTransform();
            updateControlPointsPosition();
            updateCoordsDisplay();
        }

        function getAlignmentData() {
            if (!imageElement) return null;

            const containerRect = document.getElementById('overlayContainer').getBoundingClientRect();
            const imageRect = imageElement.getBoundingClientRect();
            
            // Converter posi√ß√µes de pixel para coordenadas do mapa
            const mapBounds = map.getBounds();
            const mapContainer = map.getContainer().getBoundingClientRect();

            function pixelToLatLng(x, y) {
                const point = map.containerPointToLatLng([
                    x - mapContainer.left + containerRect.left,
                    y - mapContainer.top + containerRect.top
                ]);
                return { lat: point.lat, lng: point.lng };
            }

            // Posi√ß√µes dos cantos em pixels relativos ao container
            const corners = {
                tl: { 
                    x: imageRect.left - containerRect.left + cornerOffsets.tl.x,
                    y: imageRect.top - containerRect.top + cornerOffsets.tl.y
                },
                tr: { 
                    x: imageRect.right - containerRect.left + cornerOffsets.tr.x,
                    y: imageRect.top - containerRect.top + cornerOffsets.tr.y
                },
                bl: { 
                    x: imageRect.left - containerRect.left + cornerOffsets.bl.x,
                    y: imageRect.bottom - containerRect.top + cornerOffsets.bl.y
                },
                br: { 
                    x: imageRect.right - containerRect.left + cornerOffsets.br.x,
                    y: imageRect.bottom - containerRect.top + cornerOffsets.br.y
                }
            };

            // Converter para coordenadas geogr√°ficas
            const geoCorners = {};
            for (const [key, pos] of Object.entries(corners)) {
                const point = map.containerPointToLatLng([pos.x, pos.y]);
                geoCorners[key] = { lat: point.lat, lng: point.lng };
            }

            return {
                timestamp: new Date().toISOString(),
                mapCenter: { 
                    lat: map.getCenter().lat, 
                    lng: map.getCenter().lng 
                },
                mapZoom: map.getZoom(),
                originalImageSize: originalImageSize,
                displayedImageSize: {
                    width: imageElement.offsetWidth,
                    height: imageElement.offsetHeight
                },
                imagePosition: imagePosition,
                transformations: {
                    rotation: parseFloat(document.getElementById('rotation').value),
                    scaleX: parseFloat(document.getElementById('scaleX').value),
                    scaleY: parseFloat(document.getElementById('scaleY').value),
                    skewX: parseFloat(document.getElementById('skewX').value),
                    skewY: parseFloat(document.getElementById('skewY').value),
                    perspective: parseFloat(document.getElementById('perspective').value),
                    rotateX: parseFloat(document.getElementById('rotateX').value),
                    rotateY: parseFloat(document.getElementById('rotateY').value),
                    opacity: parseFloat(document.getElementById('opacity').value)
                },
                cornerOffsets: cornerOffsets,
                cornerPositionsPixel: corners,
                cornerPositionsGeo: geoCorners,
                boundingBox: {
                    north: Math.max(geoCorners.tl.lat, geoCorners.tr.lat),
                    south: Math.min(geoCorners.bl.lat, geoCorners.br.lat),
                    east: Math.max(geoCorners.tr.lng, geoCorners.br.lng),
                    west: Math.min(geoCorners.tl.lng, geoCorners.bl.lng)
                }
            };
        }

        function saveAlignment() {
            const data = getAlignmentData();
            if (!data) {
                alert('Carregue uma imagem primeiro!');
                return;
            }

            const json = JSON.stringify(data, null, 2);
            document.getElementById('resultJSON').textContent = json;
            document.getElementById('resultModal').style.display = 'flex';

            // Salvar no localStorage tamb√©m
            localStorage.setItem('satelliteAlignment', json);
            console.log('Alinhamento salvo:', data);
        }

        function exportAsJSON() {
            const data = getAlignmentData();
            if (!data) {
                alert('Carregue uma imagem primeiro!');
                return;
            }
            downloadJSONData(data);
        }

        function downloadJSONData(data) {
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `satellite_alignment_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadJSON() {
            const data = getAlignmentData();
            if (data) {
                downloadJSONData(data);
            }
        }

        function loadFromJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            const data = JSON.parse(event.target.result);
                            applyAlignmentData(data);
                        } catch (err) {
                            alert('Erro ao ler arquivo JSON: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function applyAlignmentData(data) {
            // Aplicar transforma√ß√µes
            if (data.transformations) {
                document.getElementById('rotation').value = data.transformations.rotation;
                document.getElementById('rotationValue').value = data.transformations.rotation;
                document.getElementById('scaleX').value = data.transformations.scaleX;
                document.getElementById('scaleXValue').value = data.transformations.scaleX;
                document.getElementById('scaleY').value = data.transformations.scaleY;
                document.getElementById('scaleYValue').value = data.transformations.scaleY;
                document.getElementById('skewX').value = data.transformations.skewX;
                document.getElementById('skewXValue').value = data.transformations.skewX;
                document.getElementById('skewY').value = data.transformations.skewY;
                document.getElementById('skewYValue').value = data.transformations.skewY;
                document.getElementById('perspective').value = data.transformations.perspective;
                document.getElementById('perspectiveValue').value = data.transformations.perspective;
                document.getElementById('rotateX').value = data.transformations.rotateX;
                document.getElementById('rotateXValue').value = data.transformations.rotateX;
                document.getElementById('rotateY').value = data.transformations.rotateY;
                document.getElementById('rotateYValue').value = data.transformations.rotateY;
                document.getElementById('opacity').value = data.transformations.opacity;
                document.getElementById('opacityValue').value = data.transformations.opacity;
            }

            // Aplicar posi√ß√£o
            if (data.imagePosition) {
                imagePosition = data.imagePosition;
            }

            // Aplicar offsets dos cantos
            if (data.cornerOffsets) {
                cornerOffsets = data.cornerOffsets;
            }

            // Aplicar view do mapa
            if (data.mapCenter && data.mapZoom) {
                map.setView([data.mapCenter.lat, data.mapCenter.lng], data.mapZoom);
            }

            updateImageTransform();
            updateControlPointsPosition();
            updateCoordsDisplay();
        }

        function copyToClipboard() {
            const text = document.getElementById('resultJSON').textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert('JSON copiado para a √°rea de transfer√™ncia!');
            });
        }

        function closeModal() {
            document.getElementById('resultModal').style.display = 'none';
        }

        function updateCoordsDisplay() {
            const data = getAlignmentData();
            if (!data) {
                document.getElementById('coordsDisplay').innerHTML = 'Carregue uma imagem para ver as coordenadas';
                return;
            }

            const geo = data.cornerPositionsGeo;
            const html = `
<b>Cantos (Lat, Lng):</b>
TL: ${geo.tl.lat.toFixed(4)}, ${geo.tl.lng.toFixed(4)}
TR: ${geo.tr.lat.toFixed(4)}, ${geo.tr.lng.toFixed(4)}
BL: ${geo.bl.lat.toFixed(4)}, ${geo.bl.lng.toFixed(4)}
BR: ${geo.br.lat.toFixed(4)}, ${geo.br.lng.toFixed(4)}

<b>Bounding Box:</b>
N: ${data.boundingBox.north.toFixed(4)}
S: ${data.boundingBox.south.toFixed(4)}
E: ${data.boundingBox.east.toFixed(4)}
W: ${data.boundingBox.west.toFixed(4)}

<b>Distor√ß√µes:</b>
TL: (${cornerOffsets.tl.x.toFixed(1)}, ${cornerOffsets.tl.y.toFixed(1)})
TR: (${cornerOffsets.tr.x.toFixed(1)}, ${cornerOffsets.tr.y.toFixed(1)})
BL: (${cornerOffsets.bl.x.toFixed(1)}, ${cornerOffsets.bl.y.toFixed(1)})
BR: (${cornerOffsets.br.x.toFixed(1)}, ${cornerOffsets.br.y.toFixed(1)})
            `;
            document.getElementById('coordsDisplay').innerHTML = html;
        }

        // Atualizar coords quando o mapa mover
        function onMapMove() {
            updateCoordsDisplay();
        }

        // ===== INICIALIZA√á√ÉO =====
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            map.on('move', onMapMove);
            map.on('zoom', onMapMove);

            // Carregar alinhamento anterior se existir
            const saved = localStorage.getItem('satelliteAlignment');
            if (saved) {
                console.log('Alinhamento anterior encontrado no localStorage');
            }
        });

        // Prevenir que o mapa capture eventos quando arrastando a imagem
        document.getElementById('overlayContainer').addEventListener('mousedown', function(e) {
            if (e.target.id === 'satelliteImage' || e.target.classList.contains('control-point')) {
                map.dragging.disable();
            }
        });

        document.addEventListener('mouseup', function() {
            map.dragging.enable();
        });
    </script>
</body>
</html>
