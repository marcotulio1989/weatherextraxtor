<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ∞Ô∏è Alinhamento de Imagem Sat√©lite - ECDIS</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a15;
            color: #eee;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Painel de Controle */
        .control-panel {
            width: 340px;
            background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            z-index: 1000;
            flex-shrink: 0;
        }

        .control-panel h1 {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #e94560;
            text-align: center;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }

        .control-section {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(15, 52, 96, 0.5);
            border-radius: 10px;
        }

        .control-section h3 {
            color: #00d9ff;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-size: 0.85em;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e94560, #c23a51);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #0f3460, #16213e);
            color: #00d9ff;
            border: 1px solid #00d9ff;
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894, #00a381);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
            color: #1a1a2e;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* √Årea da Imagem */
        .image-area {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #imageContainer {
            position: relative;
            transform-origin: center center;
        }

        #satelliteImage {
            max-width: none;
            max-height: none;
            display: block;
            image-rendering: auto;
        }

        /* Pontos de controle na imagem */
        .image-point {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #ff00ff;
            border: 3px solid #fff;
            border-radius: 50%;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            box-shadow: 0 0 15px rgba(255,0,255,0.8);
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        .image-point:hover {
            transform: translate(-50%, -50%) scale(1.2);
            background: #00ffff;
        }

        /* Lista de GCPs */
        .gcp-list {
            max-height: 250px;
            overflow-y: auto;
            background: #0a0a15;
            border-radius: 5px;
            padding: 8px;
        }

        .gcp-item {
            padding: 8px;
            margin-bottom: 6px;
            background: rgba(15, 52, 96, 0.7);
            border-radius: 5px;
            font-size: 0.8em;
            border-left: 3px solid #ff00ff;
        }

        .gcp-item .gcp-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .gcp-item .gcp-number {
            background: #ff00ff;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .gcp-item .gcp-coords {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .gcp-item input {
            width: 100%;
            padding: 5px;
            background: #1a1a2e;
            border: 1px solid #0f3460;
            color: #fff;
            border-radius: 3px;
            text-align: center;
            font-size: 0.9em;
        }

        .gcp-item label {
            font-size: 0.75em;
            color: #888;
        }

        .gcp-item button.remove-btn {
            background: #e94560;
            border: none;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-left: auto;
        }

        .gcp-mode-active {
            background: linear-gradient(135deg, #ff00ff, #cc00cc) !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255,0,255,0.5); }
            50% { box-shadow: 0 0 20px rgba(255,0,255,0.8); }
        }

        /* Controles de zoom da imagem */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 500;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #0f3460;
        }

        .zoom-btn {
            width: 50px;
            height: 50px;
            background: rgba(22, 33, 62, 0.95);
            border: 2px solid #00d9ff;
            color: #00d9ff;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            touch-action: manipulation;
        }

        .zoom-btn:hover, .zoom-btn:active {
            background: #0f3460;
            transform: scale(1.05);
        }

        .zoom-level {
            text-align: center;
            font-size: 0.9em;
            color: #00d9ff;
            padding: 5px;
            font-weight: bold;
        }

        /* Info de posi√ß√£o do mouse */
        .mouse-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.85em;
            z-index: 500;
            border: 1px solid #0f3460;
        }

        /* Modal para preview de alinhamento */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #16213e;
            border-radius: 15px;
            width: 95%;
            height: 90%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 15px 20px;
            background: #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            color: #00d9ff;
            font-size: 1.2em;
        }

        .close-modal {
            font-size: 1.5em;
            color: #e94560;
            cursor: pointer;
            background: none;
            border: none;
        }

        #previewMap {
            flex: 1;
            width: 100%;
        }

        /* Touch-friendly - prevenir zoom do browser */
        .image-area {
            touch-action: none;
        }

        /* Status */
        .status-bar {
            font-size: 0.8em;
            color: #888;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }

        .instructions {
            font-size: 0.75em;
            color: #666;
            line-height: 1.4;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Painel de Controle -->
        <div class="control-panel">
            <h1>üõ∞Ô∏è Alinhamento ECDIS</h1>

            <!-- Carregar Imagem -->
            <div class="control-section">
                <h3>üìÅ Carregar Imagem</h3>
                
                <!-- Bot√µes NOAA -->
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px; margin-bottom:10px;">
                    <button class="btn" onclick="loadNoaaImage('goes19')" style="background:#e74c3c; font-size:0.8em; padding:8px;">
                        üõ∞Ô∏è GOES-19
                    </button>
                    <button class="btn" onclick="loadNoaaImage('goes16')" style="background:#3498db; font-size:0.8em; padding:8px;">
                        üõ∞Ô∏è GOES-16
                    </button>
                </div>
                
                <div class="file-input-wrapper">
                    <button class="btn btn-primary">üìÇ Selecionar Arquivo</button>
                    <input type="file" id="imageInput" accept="image/*">
                </div>
                <input type="text" id="imageUrl" placeholder="Ou cole URL da imagem..." 
                       style="width: 100%; padding: 8px; margin-top: 8px; background: #1a1a2e; border: 1px solid #0f3460; color: #fff; border-radius: 5px; font-size: 0.85em;">
                <button class="btn btn-secondary" onclick="loadImageFromUrl()" style="margin-top: 5px;">üîó Carregar URL</button>
                <div class="status-bar" id="imageStatus">Nenhuma imagem carregada</div>
            </div>

            <!-- Marcar Pontos -->
            <div class="control-section">
                <h3>üìå Pontos de Refer√™ncia (GCP)</h3>
                
                <!-- Presets de alinhamento -->
                <div style="margin-bottom:10px;">
                    <label style="font-size:0.8em; color:#888;">Usar preset:</label>
                    <select id="presetSelect" onchange="loadPreset(this.value)" style="width:100%; padding:6px; background:#1a1a2e; border:1px solid #0f3460; color:#fff; border-radius:4px; font-size:0.85em; margin-top:4px;">
                        <option value="">-- Selecione --</option>
                        <option value="goes_ssa">GOES SSA (Am√©rica do Sul)</option>
                        <option value="goes_car">GOES CAR (Caribe)</option>
                        <option value="goes_gm">GOES GM (Golfo M√©xico)</option>
                    </select>
                </div>
                
                <!-- Cidade r√°pida -->
                <div style="margin-bottom:10px;">
                    <label style="font-size:0.8em; color:#888;">Adicionar cidade:</label>
                    <select id="citySelect" onchange="addCityPoint(this.value)" style="width:100%; padding:6px; background:#1a1a2e; border:1px solid #0f3460; color:#fff; border-radius:4px; font-size:0.85em; margin-top:4px;">
                        <option value="">-- Clique na cidade e escolha --</option>
                        <option value="bsas">Buenos Aires (-34.6, -58.4)</option>
                        <option value="rio">Rio de Janeiro (-22.9, -43.2)</option>
                        <option value="sp">S√£o Paulo (-23.5, -46.6)</option>
                        <option value="montevideo">Montevid√©u (-34.9, -56.2)</option>
                        <option value="santiago">Santiago (-33.4, -70.6)</option>
                        <option value="lima">Lima (-12.0, -77.0)</option>
                        <option value="bogota">Bogot√° (4.7, -74.1)</option>
                        <option value="caracas">Caracas (10.5, -66.9)</option>
                        <option value="manaus">Manaus (-3.1, -60.0)</option>
                        <option value="recife">Recife (-8.1, -34.9)</option>
                        <option value="porto">Porto Alegre (-30.0, -51.2)</option>
                        <option value="floripa">Florian√≥polis (-27.6, -48.5)</option>
                    </select>
                    <p class="instructions" style="font-size:0.7em; color:#666; margin-top:4px;">
                        1Ô∏è‚É£ Clique em "Marcar Ponto" ‚Üí clique na cidade na imagem<br>
                        2Ô∏è‚É£ Selecione a cidade aqui para preencher as coordenadas
                    </p>
                </div>
                
                <button class="btn btn-primary" id="btnGcpMode" onclick="toggleGcpMode()">
                    üéØ Marcar Ponto na Imagem
                </button>
                <p class="instructions" id="gcpInstructions" style="display:none;">
                    ‚ú® Clique na imagem para marcar um ponto.<br>
                    üìç Depois escolha a cidade ou digite as coordenadas.<br>
                    üî¢ M√≠nimo 2 pontos para alinhar (3+ recomendado).
                </p>
                
                <button class="btn" id="btnMeasureMode" onclick="toggleMeasureMode()" style="background:#6c5ce7; margin-top:8px;">
                    üìè Medir Dist√¢ncia (Range & Bearing)
                </button>
                <p class="instructions" id="measureInstructions" style="display:none;">
                    üìç Clique no PRIMEIRO ponto de medi√ß√£o.<br>
                    üìç Clique no SEGUNDO ponto.<br>
                    üìê Ver√° a dist√¢ncia e rumo entre eles.
                </p>
                <div id="measureResult" style="display:none; background:#2a2a4a; padding:12px; border-radius:8px; margin-top:8px; border:2px solid #6c5ce7;">
                </div>
                
                <div class="gcp-list" id="gcpList">
                    <p style="color:#666; font-size:0.85em; text-align:center;">
                        Nenhum ponto marcado
                    </p>
                </div>
                
                <button class="btn btn-warning" onclick="clearAllPoints()" style="margin-top:8px;">
                    üóëÔ∏è Limpar Pontos
                </button>
            </div>

            <!-- A√ß√µes -->
            <div class="control-section">
                <h3>‚ö° A√ß√µes</h3>
                <button class="btn btn-success" onclick="previewAlignment()" id="btnPreview">
                    üó∫Ô∏è Ver Alinhamento no Mapa
                </button>
                <button class="btn" onclick="downloadImage()" style="background:#e17055;">
                    üíæ Baixar Imagem
                </button>
                <button class="btn btn-secondary" onclick="exportAlignment()">
                    üì§ Exportar JSON
                </button>
                <button class="btn btn-secondary" onclick="importAlignment()">
                    üì• Importar JSON
                </button>
            </div>

            <!-- Resumo -->
            <div class="control-section">
                <h3>üìä Resumo</h3>
                <div id="summaryDisplay" class="status-bar">
                    Carregue uma imagem e marque os pontos
                </div>
            </div>
        </div>

        <!-- √Årea da Imagem -->
        <div class="image-area" id="imageArea">
            <div id="imageContainer">
                <img id="satelliteImage" src="" alt="Carregue uma imagem" style="display:none;">
            </div>
            
            <div class="mouse-info" id="mouseInfo">
                Pixel: -- , --
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomImage(1.2)" title="Zoom In">+</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="zoom-btn" onclick="zoomImage(0.8)" title="Zoom Out">‚àí</button>
                <button class="zoom-btn" onclick="centerImage()" title="Centralizar" style="font-size:16px;">‚äï</button>
                <button class="zoom-btn" onclick="resetZoom()" title="Ajustar √† tela" style="font-size:16px;">‚ü≤</button>
            </div>
        </div>
    </div>

    <!-- Modal de Preview -->
    <div class="modal" id="previewModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üó∫Ô∏è Preview do Alinhamento</h2>
                <button class="close-modal" onclick="closePreview()">√ó</button>
            </div>
            <div id="previewMap"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // ===== ESTADO GLOBAL =====
        let imageElement = null;
        let imageLoaded = false;
        let imageNaturalSize = { width: 0, height: 0 };
        let currentZoom = 1;
        let gcpMode = false;
        let gcpPoints = [];  // {id, pixelX, pixelY, lat, lng, element}
        let gcpCounter = 0;
        let isDragging = false;
        let dragTarget = null;
        let dragOffset = { x: 0, y: 0 };
        let imageOffset = { x: 0, y: 0 };
        let previewMap = null;
        
        // Estado para medi√ß√£o
        let measureMode = false;
        let measurePoints = []; // {pixelX, pixelY, lat, lng}
        let measureMarkers = [];

        // ===== INICIALIZA√á√ÉO =====
        document.addEventListener('DOMContentLoaded', function() {
            imageElement = document.getElementById('satelliteImage');
            setupImageDrag();
            setupTouchEvents();
            setupMouseTracking();
        });

        // ===== CARREGAR IMAGEM =====
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    loadImage(event.target.result, file.name);
                };
                reader.readAsDataURL(file);
            }
        });

        function loadImageFromUrl() {
            const url = document.getElementById('imageUrl').value.trim();
            if (url) {
                loadImage(url, 'URL');
            }
        }

        // ===== PRESETS DE ALINHAMENTO GOES =====
        // IMPORTANTE: Estes presets N√ÉO definem posi√ß√µes de pixel corretas!
        // Os pontos s√£o apenas MARCADORES para voc√™ arrastar para os locais corretos na imagem.
        // Use caracter√≠sticas geogr√°ficas identific√°veis como:
        // - Fernando de Noronha (ilha isolada)
        // - Foz do Rio Amazonas
        // - Ponta de praias/cabos
        // - Lagos grandes (Lagoa dos Patos, Titicaca)
        const ALIGNMENT_PRESETS = {
            goes_ssa: {
                name: 'GOES SSA (Am√©rica do Sul)',
                description: 'Arraste cada ponto para o local indicado na imagem',
                // Pontos come√ßam no CENTRO - voc√™ deve arrastar para a posi√ß√£o correta!
                gcpPoints: [
                    // Fernando de Noronha - ilha bem vis√≠vel no Atl√¢ntico
                    { pixelX: 100, pixelY: 100, lat: -3.8544, lng: -32.4297, label: 'Fernando de Noronha' },
                    // Foz do Amazonas - delta bem caracter√≠stico
                    { pixelX: 200, pixelY: 100, lat: -0.0389, lng: -49.5167, label: 'Foz do Amazonas' },
                    // Cabo Frio - ponta caracter√≠stica no RJ
                    { pixelX: 300, pixelY: 100, lat: -22.8833, lng: -42.0167, label: 'Cabo Frio' },
                    // Lagoa dos Patos - lago bem vis√≠vel no RS
                    { pixelX: 400, pixelY: 100, lat: -31.0000, lng: -51.0000, label: 'Lagoa dos Patos' }
                ]
            },
            goes_car: {
                name: 'GOES CAR (Caribe)',
                description: 'Arraste cada ponto para o local indicado na imagem',
                gcpPoints: [
                    // Cuba - ponta oeste
                    { pixelX: 100, pixelY: 100, lat: 21.9000, lng: -84.9500, label: 'Ponta W Cuba' },
                    // Jamaica - centro da ilha
                    { pixelX: 200, pixelY: 100, lat: 18.1096, lng: -77.2975, label: 'Jamaica' },
                    // Porto Rico - bem definido
                    { pixelX: 300, pixelY: 100, lat: 18.2208, lng: -66.5901, label: 'Porto Rico' },
                    // Trinidad - sul do Caribe
                    { pixelX: 400, pixelY: 100, lat: 10.4500, lng: -61.2500, label: 'Trinidad' }
                ]
            },
            goes_gm: {
                name: 'GOES GM (Golfo M√©xico)',
                description: 'Arraste cada ponto para o local indicado na imagem',
                gcpPoints: [
                    // Delta do Mississippi
                    { pixelX: 100, pixelY: 100, lat: 29.1500, lng: -89.2500, label: 'Delta Mississippi' },
                    // Ponta Yucat√°n
                    { pixelX: 200, pixelY: 100, lat: 21.5000, lng: -86.9500, label: 'Canc√∫n/Yucat√°n' },
                    // Cabo Catoche - extremo NE Yucat√°n
                    { pixelX: 300, pixelY: 100, lat: 21.6000, lng: -87.1000, label: 'Cabo Catoche' },
                    // Florida Keys
                    { pixelX: 400, pixelY: 100, lat: 24.5500, lng: -81.8000, label: 'Florida Keys' }
                ]
            }
        };

        function loadPreset(presetId) {
            if (!presetId || !ALIGNMENT_PRESETS[presetId]) {
                return;
            }
            
            const preset = ALIGNMENT_PRESETS[presetId];
            
            // Limpar pontos existentes
            clearAllPoints();
            
            // Adicionar pontos do preset
            preset.gcpPoints.forEach(p => {
                gcpCounter++;
                const id = gcpCounter;
                
                const pointEl = document.createElement('div');
                pointEl.className = 'image-point';
                pointEl.innerHTML = id;
                pointEl.dataset.id = id;
                document.getElementById('imageContainer').appendChild(pointEl);
                pointEl.style.left = (p.pixelX * currentZoom) + 'px';
                pointEl.style.top = (p.pixelY * currentZoom) + 'px';
                setupPointDrag(pointEl);

                gcpPoints.push({
                    id: id,
                    pixelX: p.pixelX,
                    pixelY: p.pixelY,
                    lat: p.lat,
                    lng: p.lng,
                    label: p.label || null,
                    element: pointEl
                });
            });
            
            updateGcpList();
            updateSummary();
            
            alert(`Preset "${preset.name}" carregado!\n\n‚ö†Ô∏è IMPORTANTE:\n\nOs pontos N√ÉO est√£o nas posi√ß√µes corretas!\nVoc√™ DEVE arrastar cada ponto para o local indicado:\n\n${preset.gcpPoints.map((p,i) => `${i+1}. ${p.label || 'Ponto '+(i+1)}`).join('\n')}\n\nUse o zoom para identificar as fei√ß√µes geogr√°ficas.`);
        }

        // ===== CIDADES CONHECIDAS =====
        const KNOWN_CITIES = {
            bsas: { name: 'Buenos Aires', lat: -34.6037, lng: -58.3816 },
            rio: { name: 'Rio de Janeiro', lat: -22.9068, lng: -43.1729 },
            sp: { name: 'S√£o Paulo', lat: -23.5505, lng: -46.6333 },
            montevideo: { name: 'Montevid√©u', lat: -34.9011, lng: -56.1645 },
            santiago: { name: 'Santiago', lat: -33.4489, lng: -70.6693 },
            lima: { name: 'Lima', lat: -12.0464, lng: -77.0428 },
            bogota: { name: 'Bogot√°', lat: 4.7110, lng: -74.0721 },
            caracas: { name: 'Caracas', lat: 10.4806, lng: -66.9036 },
            manaus: { name: 'Manaus', lat: -3.1190, lng: -60.0217 },
            recife: { name: 'Recife', lat: -8.0476, lng: -34.8770 },
            porto: { name: 'Porto Alegre', lat: -30.0346, lng: -51.2177 },
            floripa: { name: 'Florian√≥polis', lat: -27.5954, lng: -48.5480 }
        };

        function addCityPoint(cityId) {
            if (!cityId || !KNOWN_CITIES[cityId]) {
                return;
            }
            
            const city = KNOWN_CITIES[cityId];
            
            // Verificar se h√° um ponto recente sem coordenadas
            const lastPoint = gcpPoints[gcpPoints.length - 1];
            if (lastPoint && lastPoint.lat === 0 && lastPoint.lng === 0) {
                // Atualizar o √∫ltimo ponto com as coordenadas da cidade
                lastPoint.lat = city.lat;
                lastPoint.lng = city.lng;
                updateGcpList();
                updateSummary();
                
                // Resetar o select
                document.getElementById('citySelect').value = '';
                return;
            }
            
            // Se n√£o h√° ponto recente, avisar o usu√°rio
            alert(`Para usar esta op√ß√£o:\n1. Clique em "Marcar Ponto na Imagem"\n2. Clique na localiza√ß√£o de ${city.name} na imagem\n3. Ent√£o selecione ${city.name} nesta lista`);
            document.getElementById('citySelect').value = '';
        }

        // ===== CARREGAR IMAGEM NOAA DIRETO =====
        const NOAA_URLS = {
            goes19: {
                name: 'GOES-19 (SSA)',
                url: 'https://cdn.star.nesdis.noaa.gov/GOES19/ABI/SECTOR/ssa/13/latest.jpg'
            },
            goes16: {
                name: 'GOES-16 (SSA)',
                url: 'https://cdn.star.nesdis.noaa.gov/GOES16/ABI/SECTOR/ssa/13/latest.jpg'
            }
        };

        function loadNoaaImage(satellite) {
            const sat = NOAA_URLS[satellite];
            if (!sat) return;

            const status = document.getElementById('imageStatus');
            status.innerHTML = `‚è≥ Baixando ${sat.name}...`;
            status.style.color = '#ffff00';

            // Adicionar timestamp para evitar cache
            const urlWithCache = sat.url + '?t=' + Date.now();
            
            loadImage(urlWithCache, sat.name);
        }

        function loadImage(src, name) {
            const status = document.getElementById('imageStatus');
            status.innerHTML = '‚è≥ Carregando...';
            status.style.color = '#ffff00';

            imageElement.onload = function() {
                imageNaturalSize = {
                    width: this.naturalWidth,
                    height: this.naturalHeight
                };
                
                imageElement.style.display = 'block';
                imageLoaded = true;
                resetZoom();
                
                status.innerHTML = `‚úÖ ${name}<br>üìê ${imageNaturalSize.width} √ó ${imageNaturalSize.height} px`;
                status.style.color = '#00ff00';
                
                updateSummary();
            };

            imageElement.onerror = function() {
                status.innerHTML = '‚ùå Erro ao carregar imagem';
                status.style.color = '#ff4444';
            };

            imageElement.src = src;
        }

        // ===== ZOOM DA IMAGEM =====
        function zoomImage(factor) {
            currentZoom *= factor;
            currentZoom = Math.max(0.1, Math.min(10, currentZoom));
            applyZoom();
        }

        function resetZoom() {
            if (!imageLoaded) return;
            
            const area = document.getElementById('imageArea');
            const areaRect = area.getBoundingClientRect();
            
            // Calcular zoom para caber na √°rea
            const scaleX = (areaRect.width - 100) / imageNaturalSize.width;
            const scaleY = (areaRect.height - 100) / imageNaturalSize.height;
            currentZoom = Math.min(scaleX, scaleY, 1);
            
            imageOffset = { x: 0, y: 0 };
            applyZoom();
        }

        function centerImage() {
            if (!imageLoaded) return;
            
            // Resetar offset para centralizar (flexbox j√° centraliza quando offset √© 0)
            imageOffset.x = 0;
            imageOffset.y = 0;
            
            // For√ßar aplica√ß√£o
            const container = document.getElementById('imageContainer');
            container.style.transform = `translate(0px, 0px) scale(${currentZoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
            updatePointPositions();
        }

        function applyZoom() {
            const container = document.getElementById('imageContainer');
            container.style.transform = `translate(${imageOffset.x}px, ${imageOffset.y}px) scale(${currentZoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
            updatePointPositions();
        }

        // ===== ARRASTAR IMAGEM (PAN) =====
        function setupImageDrag() {
            const area = document.getElementById('imageArea');
            
            area.addEventListener('mousedown', function(e) {
                // N√£o arrastar se clicar em ponto GCP ou marcador de medi√ß√£o
                if (e.target.classList.contains('image-point')) return;
                if (e.target.classList.contains('measure-marker')) return;
                
                // N√£o arrastar se estiver em modo GCP ou medi√ß√£o
                if (gcpMode || measureMode) return;
                
                // S√≥ arrasta com bot√£o esquerdo
                if (e.button !== 0) return;
                
                e.preventDefault();
                isDragging = true;
                dragTarget = 'image';
                dragOffset = {
                    x: e.clientX - imageOffset.x,
                    y: e.clientY - imageOffset.y
                };
                area.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                if (dragTarget === 'image') {
                    imageOffset.x = e.clientX - dragOffset.x;
                    imageOffset.y = e.clientY - dragOffset.y;
                    applyZoom();
                } else if (dragTarget && dragTarget.type === 'point') {
                    updatePointDrag(e, dragTarget.point);
                }
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    dragTarget = null;
                    updateCursor();
                }
            });
        }

        function updateCursor() {
            const area = document.getElementById('imageArea');
            if (gcpMode || measureMode) {
                area.style.cursor = 'crosshair';
            } else {
                area.style.cursor = 'grab';
            }
        }

        // ===== SUPORTE A TOUCH (TABLET/CELULAR) =====
        let touchState = {
            lastTouches: null,
            initialDistance: 0,
            initialZoom: 1,
            isPanning: false,
            isPinching: false
        };

        function setupTouchEvents() {
            const area = document.getElementById('imageArea');
            
            // Prevenir comportamentos padr√£o do browser
            area.addEventListener('touchstart', handleTouchStart, { passive: false });
            area.addEventListener('touchmove', handleTouchMove, { passive: false });
            area.addEventListener('touchend', handleTouchEnd, { passive: false });
            area.addEventListener('touchcancel', handleTouchEnd, { passive: false });
        }

        function handleTouchStart(e) {
            e.preventDefault();
            
            const touches = e.touches;
            
            if (touches.length === 1) {
                // Um dedo = pan ou clique
                const touch = touches[0];
                
                // Verificar se tocou em ponto GCP
                if (e.target.classList.contains('image-point')) {
                    // Iniciar arrasto de ponto
                    const pointId = parseInt(e.target.dataset.id);
                    const point = gcpPoints.find(p => p.id === pointId);
                    if (point) {
                        isDragging = true;
                        dragTarget = { type: 'point', point: point };
                    }
                    return;
                }
                
                // Se em modo GCP ou medi√ß√£o, tratar como clique
                if (gcpMode || measureMode) {
                    // Simular click
                    if (gcpMode) {
                        addGcpPointFromTouch(touch);
                    }
                    return;
                }
                
                // Sen√£o, iniciar pan
                touchState.isPanning = true;
                touchState.lastTouches = [{ x: touch.clientX, y: touch.clientY }];
                
            } else if (touches.length === 2) {
                // Dois dedos = pinch to zoom
                touchState.isPanning = false;
                touchState.isPinching = true;
                
                const dist = getTouchDistance(touches[0], touches[1]);
                touchState.initialDistance = dist;
                touchState.initialZoom = currentZoom;
                
                // Centro entre os dois toques para pan durante pinch
                touchState.lastTouches = [
                    { x: touches[0].clientX, y: touches[0].clientY },
                    { x: touches[1].clientX, y: touches[1].clientY }
                ];
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            const touches = e.touches;
            
            if (touchState.isPanning && touches.length === 1) {
                // Pan com um dedo
                const touch = touches[0];
                const dx = touch.clientX - touchState.lastTouches[0].x;
                const dy = touch.clientY - touchState.lastTouches[0].y;
                
                imageOffset.x += dx;
                imageOffset.y += dy;
                applyZoom();
                
                touchState.lastTouches = [{ x: touch.clientX, y: touch.clientY }];
                
            } else if (isDragging && dragTarget && dragTarget.type === 'point' && touches.length === 1) {
                // Arrastando ponto GCP
                const touch = touches[0];
                updatePointDragFromTouch(touch, dragTarget.point);
                
            } else if (touchState.isPinching && touches.length === 2) {
                // Pinch to zoom
                const dist = getTouchDistance(touches[0], touches[1]);
                const scale = dist / touchState.initialDistance;
                
                let newZoom = touchState.initialZoom * scale;
                newZoom = Math.max(0.1, Math.min(10, newZoom));
                
                // Calcular centro do pinch
                const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                const centerY = (touches[0].clientY + touches[1].clientY) / 2;
                
                // Zoom em dire√ß√£o ao centro do pinch
                const zoomRatio = newZoom / currentZoom;
                
                // Ajustar offset para manter centro
                const area = document.getElementById('imageArea');
                const rect = area.getBoundingClientRect();
                const areaCenterX = rect.left + rect.width / 2;
                const areaCenterY = rect.top + rect.height / 2;
                
                const dx = centerX - areaCenterX;
                const dy = centerY - areaCenterY;
                
                imageOffset.x = imageOffset.x - dx * (zoomRatio - 1);
                imageOffset.y = imageOffset.y - dy * (zoomRatio - 1);
                
                currentZoom = newZoom;
                applyZoom();
                
                // Tamb√©m fazer pan durante o pinch
                const oldCenterX = (touchState.lastTouches[0].x + touchState.lastTouches[1].x) / 2;
                const oldCenterY = (touchState.lastTouches[0].y + touchState.lastTouches[1].y) / 2;
                
                imageOffset.x += centerX - oldCenterX;
                imageOffset.y += centerY - oldCenterY;
                applyZoom();
                
                touchState.lastTouches = [
                    { x: touches[0].clientX, y: touches[0].clientY },
                    { x: touches[1].clientX, y: touches[1].clientY }
                ];
            }
        }

        function handleTouchEnd(e) {
            touchState.isPanning = false;
            touchState.isPinching = false;
            touchState.lastTouches = null;
            
            if (isDragging) {
                isDragging = false;
                dragTarget = null;
            }
        }

        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function addGcpPointFromTouch(touch) {
            const pixel = clientToImagePixel(touch.clientX, touch.clientY);
            if (!pixel) return;
            
            gcpCounter++;
            const id = gcpCounter;
            
            const pointEl = document.createElement('div');
            pointEl.className = 'image-point';
            pointEl.innerHTML = id;
            pointEl.dataset.id = id;
            document.getElementById('imageContainer').appendChild(pointEl);
            
            pointEl.style.left = (pixel.x * currentZoom) + 'px';
            pointEl.style.top = (pixel.y * currentZoom) + 'px';
            
            setupPointDrag(pointEl);

            gcpPoints.push({
                id: id,
                pixelX: pixel.x,
                pixelY: pixel.y,
                lat: 0,
                lng: 0,
                element: pointEl
            });

            updateGcpList();
            updateSummary();
        }

        function updatePointDragFromTouch(touch, point) {
            const pixel = clientToImagePixel(touch.clientX, touch.clientY);
            if (!pixel) return;
            
            point.pixelX = pixel.x;
            point.pixelY = pixel.y;
            point.element.style.left = (pixel.x * currentZoom) + 'px';
            point.element.style.top = (pixel.y * currentZoom) + 'px';
            
            updateGcpList();
        }

        // ===== RASTREAR MOUSE =====
        function setupMouseTracking() {
            const area = document.getElementById('imageArea');
            
            area.addEventListener('mousemove', function(e) {
                if (!imageLoaded) return;
                
                const pixel = clientToImagePixel(e.clientX, e.clientY);
                if (pixel) {
                    let info = `Pixel: <b>${Math.round(pixel.x)}</b> , <b>${Math.round(pixel.y)}</b>`;
                    
                    // Se temos alinhamento, mostrar coordenadas estimadas
                    const geo = pixelToGeo(pixel.x, pixel.y);
                    if (geo) {
                        const latDir = geo.lat >= 0 ? 'N' : 'S';
                        const lngDir = geo.lng >= 0 ? 'E' : 'W';
                        info += `<br><span style="color:#00ff00;">‚âà ${Math.abs(geo.lat).toFixed(4)}¬∞${latDir}, ${Math.abs(geo.lng).toFixed(4)}¬∞${lngDir}</span>`;
                    }
                    
                    document.getElementById('mouseInfo').innerHTML = info;
                }
            });

            area.addEventListener('click', function(e) {
                if (gcpMode && !e.target.classList.contains('image-point')) {
                    addGcpPoint(e);
                }
                if (measureMode && !e.target.classList.contains('measure-marker')) {
                    addMeasurePoint(e);
                }
            });
        }

        function clientToImagePixel(clientX, clientY) {
            const container = document.getElementById('imageContainer');
            const rect = container.getBoundingClientRect();
            const imgRect = imageElement.getBoundingClientRect();
            
            // Posi√ß√£o relativa √† imagem escalada
            const relX = clientX - imgRect.left;
            const relY = clientY - imgRect.top;
            
            // Converter para coordenadas de pixel original
            const pixelX = relX / currentZoom;
            const pixelY = relY / currentZoom;
            
            if (pixelX >= 0 && pixelX <= imageNaturalSize.width &&
                pixelY >= 0 && pixelY <= imageNaturalSize.height) {
                return { x: pixelX, y: pixelY };
            }
            return null;
        }

        // ===== GCP POINTS =====
        function toggleGcpMode() {
            gcpMode = !gcpMode;
            const btn = document.getElementById('btnGcpMode');
            const instructions = document.getElementById('gcpInstructions');
            
            if (gcpMode) {
                // Desativar modo medi√ß√£o se estiver ativo
                if (measureMode) toggleMeasureMode();
                
                btn.classList.add('gcp-mode-active');
                btn.innerHTML = 'üéØ CLIQUE NA IMAGEM!';
                instructions.style.display = 'block';
            } else {
                btn.classList.remove('gcp-mode-active');
                btn.innerHTML = 'üéØ Marcar Ponto na Imagem';
                instructions.style.display = 'none';
            }
            updateCursor();
        }

        // ===== FUN√á√ïES DE MEDI√á√ÉO (RANGE & BEARING) =====
        function toggleMeasureMode() {
            measureMode = !measureMode;
            const btn = document.getElementById('btnMeasureMode');
            const instructions = document.getElementById('measureInstructions');
            
            if (measureMode) {
                // Desativar modo GCP se estiver ativo
                if (gcpMode) toggleGcpMode();
                
                // Limpar medi√ß√£o anterior
                clearMeasurePoints();
                
                btn.style.background = '#00b894';
                btn.innerHTML = 'üìè CLIQUE 2 PONTOS NA IMAGEM!';
                instructions.style.display = 'block';
            } else {
                btn.style.background = '#6c5ce7';
                btn.innerHTML = 'üìè Medir Dist√¢ncia (Range & Bearing)';
                instructions.style.display = 'none';
            }
            updateCursor();
        }

        function clearMeasurePoints() {
            measureMarkers.forEach(m => m.remove());
            measureMarkers = [];
            measurePoints = [];
            document.getElementById('measureResult').style.display = 'none';
            
            // Remover linha de medi√ß√£o se existir
            const existingLine = document.getElementById('measureLine');
            if (existingLine) existingLine.remove();
        }

        function addMeasurePoint(e) {
            if (!imageLoaded) return;
            if (measurePoints.length >= 2) {
                clearMeasurePoints();
            }

            const pixel = clientToImagePixel(e.clientX, e.clientY);
            if (!pixel) return;

            // Calcular coordenada geogr√°fica deste pixel usando alinhamento
            const geo = pixelToGeo(pixel.x, pixel.y);
            if (!geo) {
                alert('Configure pelo menos 2 pontos GCP com coordenadas primeiro!');
                return;
            }

            const pointNum = measurePoints.length + 1;

            // Criar marcador visual
            const marker = document.createElement('div');
            marker.className = 'measure-marker';
            marker.innerHTML = pointNum;
            marker.style.cssText = `
                position: absolute;
                width: 24px;
                height: 24px;
                background: #6c5ce7;
                border: 2px solid white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                font-size: 12px;
                transform: translate(-50%, -50%);
                z-index: 200;
                pointer-events: none;
                left: ${pixel.x * currentZoom}px;
                top: ${pixel.y * currentZoom}px;
            `;
            document.getElementById('imageContainer').appendChild(marker);
            measureMarkers.push(marker);

            measurePoints.push({
                pixelX: pixel.x,
                pixelY: pixel.y,
                lat: geo.lat,
                lng: geo.lng
            });

            // Se temos 2 pontos, calcular e mostrar resultado
            if (measurePoints.length === 2) {
                drawMeasureLine();
                showMeasureResult();
                toggleMeasureMode();
            }
        }

        function pixelToGeo(pixelX, pixelY) {
            // Calcular coordenadas geogr√°ficas usando transforma√ß√£o afim
            const validPoints = gcpPoints.filter(p => p.lat !== 0 || p.lng !== 0);
            if (validPoints.length < 2) return null;

            // Usar transforma√ß√£o afim se dispon√≠vel
            if (affineTransform) {
                return applyAffineTransform(affineTransform, pixelX, pixelY);
            }
            
            // Recalcular se necess√°rio
            const transform = calculateAffineTransform(validPoints);
            if (!transform) return null;
            
            return applyAffineTransform(transform, pixelX, pixelY);
        }

        function drawMeasureLine() {
            const container = document.getElementById('imageContainer');
            
            // Remover linha anterior
            const existingLine = document.getElementById('measureLine');
            if (existingLine) existingLine.remove();

            const p1 = measurePoints[0];
            const p2 = measurePoints[1];

            const x1 = p1.pixelX * currentZoom;
            const y1 = p1.pixelY * currentZoom;
            const x2 = p2.pixelX * currentZoom;
            const y2 = p2.pixelY * currentZoom;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.id = 'measureLine';
            svg.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 150;
            `;
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="10" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#6c5ce7" />
                    </marker>
                </defs>
                <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                      stroke="#6c5ce7" stroke-width="3" stroke-dasharray="8,4"
                      marker-end="url(#arrowhead)" />
            `;
            container.appendChild(svg);
        }

        function showMeasureResult() {
            const p1 = measurePoints[0];
            const p2 = measurePoints[1];

            // Calcular dist√¢ncia usando f√≥rmula de Haversine
            const distance = haversineDistance(p1.lat, p1.lng, p2.lat, p2.lng);
            
            // Calcular bearing (rumo)
            const bearing = calculateBearing(p1.lat, p1.lng, p2.lat, p2.lng);

            const resultEl = document.getElementById('measureResult');
            resultEl.style.display = 'block';
            resultEl.innerHTML = `
                <div style="text-align:center; margin-bottom:10px;">
                    <span style="font-size:1.5em; color:#6c5ce7;">üìè Resultado da Medi√ß√£o</span>
                </div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; font-size:0.85em;">
                    <div style="background:#1a1a2e; padding:8px; border-radius:4px;">
                        <div style="color:#888; font-size:0.8em;">Ponto 1</div>
                        <div style="color:#00ff00;">${formatCoord(p1.lat, p1.lng)}</div>
                    </div>
                    <div style="background:#1a1a2e; padding:8px; border-radius:4px;">
                        <div style="color:#888; font-size:0.8em;">Ponto 2</div>
                        <div style="color:#00ff00;">${formatCoord(p2.lat, p2.lng)}</div>
                    </div>
                </div>
                <div style="margin-top:12px; padding:12px; background:#1a1a2e; border-radius:8px; text-align:center;">
                    <div style="font-size:1.8em; color:#00ff00; font-weight:bold;">
                        ${distance.toFixed(2)} NM
                    </div>
                    <div style="color:#888; font-size:0.85em;">Dist√¢ncia (${(distance * 1.852).toFixed(2)} km)</div>
                    <div style="margin-top:10px; font-size:1.5em; color:#6c5ce7; font-weight:bold;">
                        ${bearing.toFixed(1)}¬∞
                    </div>
                    <div style="color:#888; font-size:0.85em;">Rumo (Bearing)</div>
                </div>
                <button onclick="clearMeasurePoints()" style="width:100%; margin-top:10px; padding:8px; background:#e74c3c; border:none; border-radius:4px; color:white; cursor:pointer;">
                    üóëÔ∏è Limpar Medi√ß√£o
                </button>
            `;
        }

        function formatCoord(lat, lng) {
            const latDir = lat >= 0 ? 'N' : 'S';
            const lngDir = lng >= 0 ? 'E' : 'W';
            return `${Math.abs(lat).toFixed(6)}¬∞${latDir}, ${Math.abs(lng).toFixed(6)}¬∞${lngDir}`;
        }

        function haversineDistance(lat1, lng1, lat2, lng2) {
            // Raio da Terra em milhas n√°uticas
            const R = 3440.065; // NM
            
            const dLat = toRad(lat2 - lat1);
            const dLng = toRad(lng2 - lng1);
            
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }

        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLng = toRad(lng2 - lng1);
            const lat1Rad = toRad(lat1);
            const lat2Rad = toRad(lat2);
            
            const y = Math.sin(dLng) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                      Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);
            
            let bearing = toDeg(Math.atan2(y, x));
            return (bearing + 360) % 360; // Normalizar para 0-360
        }

        function toRad(deg) {
            return deg * Math.PI / 180;
        }

        function toDeg(rad) {
            return rad * 180 / Math.PI;
        }

        function addGcpPoint(e) {
            if (!imageLoaded) {
                alert('Carregue uma imagem primeiro!');
                return;
            }

            const pixel = clientToImagePixel(e.clientX, e.clientY);
            if (!pixel) return;

            gcpCounter++;
            const id = gcpCounter;

            // Criar elemento visual
            const pointEl = document.createElement('div');
            pointEl.className = 'image-point';
            pointEl.innerHTML = id;
            pointEl.dataset.id = id;
            document.getElementById('imageContainer').appendChild(pointEl);

            // Posicionar
            pointEl.style.left = (pixel.x * currentZoom) + 'px';
            pointEl.style.top = (pixel.y * currentZoom) + 'px';

            // Permitir arrastar
            setupPointDrag(pointEl);

            // Adicionar ao array
            const point = {
                id: id,
                pixelX: pixel.x,
                pixelY: pixel.y,
                lat: 0,
                lng: 0,
                element: pointEl
            };
            gcpPoints.push(point);

            updateGcpList();
            updateSummary();
            
            // Desativar modo ap√≥s adicionar
            toggleGcpMode();
        }

        function setupPointDrag(pointEl) {
            pointEl.addEventListener('mousedown', function(e) {
                e.stopPropagation();
                isDragging = true;
                const id = parseInt(pointEl.dataset.id);
                const point = gcpPoints.find(p => p.id === id);
                dragTarget = { type: 'point', point: point };
            });
        }

        function updatePointDrag(e, point) {
            const pixel = clientToImagePixel(e.clientX, e.clientY);
            if (pixel) {
                point.pixelX = pixel.x;
                point.pixelY = pixel.y;
                point.element.style.left = (pixel.x * currentZoom) + 'px';
                point.element.style.top = (pixel.y * currentZoom) + 'px';
                updateGcpList();
            }
        }

        function updatePointPositions() {
            gcpPoints.forEach(point => {
                point.element.style.left = (point.pixelX * currentZoom) + 'px';
                point.element.style.top = (point.pixelY * currentZoom) + 'px';
            });
            
            // Atualizar posi√ß√£o dos marcadores de medi√ß√£o
            measureMarkers.forEach((marker, i) => {
                if (measurePoints[i]) {
                    marker.style.left = (measurePoints[i].pixelX * currentZoom) + 'px';
                    marker.style.top = (measurePoints[i].pixelY * currentZoom) + 'px';
                }
            });
            
            // Redesenhar linha de medi√ß√£o se existir
            if (measurePoints.length === 2) {
                drawMeasureLine();
            }
        }

        function updateGcpList() {
            const listEl = document.getElementById('gcpList');
            
            if (gcpPoints.length === 0) {
                listEl.innerHTML = '<p style="color:#666; font-size:0.85em; text-align:center;">Nenhum ponto marcado</p>';
                return;
            }
            
            let html = '';
            gcpPoints.forEach(point => {
                const labelHtml = point.label 
                    ? `<div style="color:#ff00ff; font-size:0.8em; font-weight:bold; margin-bottom:4px;">üìç ${point.label}</div>` 
                    : '';
                html += `
                    <div class="gcp-item" data-id="${point.id}">
                        <div class="gcp-header">
                            <span class="gcp-number">${point.id}</span>
                            <span style="color:#888; font-size:0.8em;">Pixel: ${Math.round(point.pixelX)}, ${Math.round(point.pixelY)}</span>
                            <button class="remove-btn" onclick="removePoint(${point.id})">√ó</button>
                        </div>
                        ${labelHtml}
                        <div class="gcp-coords">
                            <div>
                                <label>Latitude</label>
                                <input type="number" step="0.000001" value="${point.lat}" 
                                       placeholder="-22.123456"
                                       onchange="updatePointCoord(${point.id}, 'lat', this.value)">
                            </div>
                            <div>
                                <label>Longitude</label>
                                <input type="number" step="0.000001" value="${point.lng}" 
                                       placeholder="-41.567890"
                                       onchange="updatePointCoord(${point.id}, 'lng', this.value)">
                            </div>
                        </div>
                    </div>
                `;
            });
            
            listEl.innerHTML = html;
        }

        function updatePointCoord(id, field, value) {
            const point = gcpPoints.find(p => p.id === id);
            if (point) {
                point[field] = parseFloat(value) || 0;
                updateSummary();
            }
        }

        function removePoint(id) {
            const index = gcpPoints.findIndex(p => p.id === id);
            if (index !== -1) {
                gcpPoints[index].element.remove();
                gcpPoints.splice(index, 1);
                updateGcpList();
                updateSummary();
            }
        }

        function clearAllPoints() {
            gcpPoints.forEach(p => p.element.remove());
            gcpPoints = [];
            gcpCounter = 0;
            updateGcpList();
            updateSummary();
        }

        // ===== CALCULAR ALINHAMENTO COM TRANSFORMA√á√ÉO AFIM =====
        // Matriz de transforma√ß√£o global (pixel -> geo)
        let affineTransform = null;
        
        function calculateAffineTransform(points) {
            // Calcular transforma√ß√£o afim usando m√≠nimos quadrados
            // Para pelo menos 3 pontos, resolve o sistema linear
            // [lng]   [a b c] [pixelX]
            // [lat] = [d e f] [pixelY]
            //                 [1     ]
            
            const n = points.length;
            
            if (n < 2) return null;
            
            if (n === 2) {
                // Com apenas 2 pontos, assumir sem rota√ß√£o
                const p1 = points[0];
                const p2 = points[1];
                
                const dPixelX = p2.pixelX - p1.pixelX;
                const dPixelY = p2.pixelY - p1.pixelY;
                const dLng = p2.lng - p1.lng;
                const dLat = p2.lat - p1.lat;
                
                // Calcular escala m√©dia
                const pixelDist = Math.sqrt(dPixelX * dPixelX + dPixelY * dPixelY);
                const geoDist = Math.sqrt(dLng * dLng + dLat * dLat);
                
                if (pixelDist === 0) return null;
                
                // Estimar escala separada para X e Y
                let scaleX, scaleY;
                
                if (Math.abs(dPixelX) > 1) {
                    scaleX = dLng / dPixelX;
                } else {
                    scaleX = geoDist / pixelDist;
                }
                
                if (Math.abs(dPixelY) > 1) {
                    scaleY = dLat / dPixelY;
                } else {
                    scaleY = -geoDist / pixelDist; // Negativo porque Y aumenta para baixo
                }
                
                // Ajuste: latitude decresce quando Y aumenta (imagem)
                // Offset calculado a partir do primeiro ponto
                const offsetLng = p1.lng - (p1.pixelX * scaleX);
                const offsetLat = p1.lat - (p1.pixelY * scaleY);
                
                return {
                    a: scaleX, b: 0, c: offsetLng,
                    d: 0, e: scaleY, f: offsetLat
                };
            }
            
            // Para 3+ pontos: resolver usando m√≠nimos quadrados
            // Construir matrizes para o sistema Ax = b
            
            // Para longitude: a*px + b*py + c = lng
            // Para latitude:  d*px + e*py + f = lat
            
            let sumPx = 0, sumPy = 0, sumPx2 = 0, sumPy2 = 0, sumPxPy = 0;
            let sumLng = 0, sumLat = 0;
            let sumPxLng = 0, sumPyLng = 0, sumPxLat = 0, sumPyLat = 0;
            
            points.forEach(p => {
                sumPx += p.pixelX;
                sumPy += p.pixelY;
                sumPx2 += p.pixelX * p.pixelX;
                sumPy2 += p.pixelY * p.pixelY;
                sumPxPy += p.pixelX * p.pixelY;
                sumLng += p.lng;
                sumLat += p.lat;
                sumPxLng += p.pixelX * p.lng;
                sumPyLng += p.pixelY * p.lng;
                sumPxLat += p.pixelX * p.lat;
                sumPyLat += p.pixelY * p.lat;
            });
            
            // Matriz A (3x3) para o sistema normal
            const A = [
                [sumPx2, sumPxPy, sumPx],
                [sumPxPy, sumPy2, sumPy],
                [sumPx, sumPy, n]
            ];
            
            // Resolver para longitude (a, b, c)
            const bLng = [sumPxLng, sumPyLng, sumLng];
            const lngCoeffs = solveLinearSystem(A, bLng);
            
            // Resolver para latitude (d, e, f)
            const bLat = [sumPxLat, sumPyLat, sumLat];
            const latCoeffs = solveLinearSystem(A, bLat);
            
            if (!lngCoeffs || !latCoeffs) return null;
            
            return {
                a: lngCoeffs[0], b: lngCoeffs[1], c: lngCoeffs[2],
                d: latCoeffs[0], e: latCoeffs[1], f: latCoeffs[2]
            };
        }
        
        function solveLinearSystem(A, b) {
            // Resolver sistema 3x3 usando elimina√ß√£o de Gauss
            const n = 3;
            const aug = A.map((row, i) => [...row, b[i]]);
            
            for (let col = 0; col < n; col++) {
                // Pivota√ß√£o parcial
                let maxRow = col;
                for (let row = col + 1; row < n; row++) {
                    if (Math.abs(aug[row][col]) > Math.abs(aug[maxRow][col])) {
                        maxRow = row;
                    }
                }
                [aug[col], aug[maxRow]] = [aug[maxRow], aug[col]];
                
                if (Math.abs(aug[col][col]) < 1e-10) return null; // Matriz singular
                
                // Elimina√ß√£o
                for (let row = col + 1; row < n; row++) {
                    const factor = aug[row][col] / aug[col][col];
                    for (let j = col; j <= n; j++) {
                        aug[row][j] -= factor * aug[col][j];
                    }
                }
            }
            
            // Substitui√ß√£o reversa
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = aug[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= aug[i][j] * x[j];
                }
                x[i] /= aug[i][i];
            }
            
            return x;
        }
        
        function applyAffineTransform(transform, pixelX, pixelY) {
            return {
                lng: transform.a * pixelX + transform.b * pixelY + transform.c,
                lat: transform.d * pixelX + transform.e * pixelY + transform.f
            };
        }
        
        function calculateAlignment() {
            if (gcpPoints.length < 2) {
                return null;
            }

            // Verificar se todos os pontos t√™m coordenadas
            const validPoints = gcpPoints.filter(p => p.lat !== 0 || p.lng !== 0);
            if (validPoints.length < 2) {
                return null;
            }

            // Calcular transforma√ß√£o afim
            affineTransform = calculateAffineTransform(validPoints);
            if (!affineTransform) return null;
            
            // Calcular bounds usando os 4 cantos da imagem
            const corners = [
                { x: 0, y: 0 },                                           // Top-left
                { x: imageNaturalSize.width, y: 0 },                      // Top-right
                { x: 0, y: imageNaturalSize.height },                     // Bottom-left
                { x: imageNaturalSize.width, y: imageNaturalSize.height } // Bottom-right
            ];
            
            const cornerGeo = corners.map(c => applyAffineTransform(affineTransform, c.x, c.y));
            
            // Encontrar bounds geogr√°ficos
            const lats = cornerGeo.map(g => g.lat);
            const lngs = cornerGeo.map(g => g.lng);
            
            const north = Math.max(...lats);
            const south = Math.min(...lats);
            const east = Math.max(...lngs);
            const west = Math.min(...lngs);
            
            // Calcular erro RMS para diagn√≥stico
            let sumError2 = 0;
            validPoints.forEach(p => {
                const predicted = applyAffineTransform(affineTransform, p.pixelX, p.pixelY);
                const errLat = predicted.lat - p.lat;
                const errLng = predicted.lng - p.lng;
                sumError2 += errLat * errLat + errLng * errLng;
            });
            const rmsError = Math.sqrt(sumError2 / validPoints.length);

            return {
                bounds: { north, south, east, west },
                transform: affineTransform,
                rmsError: rmsError,
                gcpPoints: validPoints.map(p => ({
                    pixelX: p.pixelX,
                    pixelY: p.pixelY,
                    lat: p.lat,
                    lng: p.lng
                })),
                imageSize: imageNaturalSize
            };
        }

        function updateSummary() {
            const el = document.getElementById('summaryDisplay');
            const validPoints = gcpPoints.filter(p => p.lat !== 0 || p.lng !== 0);
            
            if (!imageLoaded) {
                el.innerHTML = 'Carregue uma imagem';
                return;
            }
            
            if (gcpPoints.length === 0) {
                el.innerHTML = `üìê Imagem: ${imageNaturalSize.width}√ó${imageNaturalSize.height}px<br>üìå Marque pontos de refer√™ncia`;
                return;
            }

            let html = `üìê Imagem: ${imageNaturalSize.width}√ó${imageNaturalSize.height}px<br>`;
            html += `üìå Pontos: ${validPoints.length} com coordenadas / ${gcpPoints.length} total<br>`;

            const alignment = calculateAlignment();
            if (alignment) {
                html += `<br><b style="color:#00ff00;">‚úÖ Pronto para alinhar!</b><br>`;
                html += `N: ${alignment.bounds.north.toFixed(4)}¬∞<br>`;
                html += `S: ${alignment.bounds.south.toFixed(4)}¬∞<br>`;
                html += `E: ${alignment.bounds.east.toFixed(4)}¬∞<br>`;
                html += `W: ${alignment.bounds.west.toFixed(4)}¬∞<br>`;
                
                if (alignment.rmsError !== undefined) {
                    const errorKm = alignment.rmsError * 111; // ~111 km por grau
                    const errorColor = errorKm < 10 ? '#00ff00' : errorKm < 50 ? '#ffff00' : '#ff6600';
                    html += `<br><span style="color:${errorColor};">üìä Erro RMS: ~${errorKm.toFixed(1)} km</span>`;
                    
                    if (validPoints.length < 3) {
                        html += `<br><span style="color:#ffaa00;">‚ö†Ô∏è Adicione mais pontos para melhor precis√£o</span>`;
                    } else if (validPoints.length >= 4) {
                        html += `<br><span style="color:#00ff00;">‚ú® ${validPoints.length} pontos = boa precis√£o</span>`;
                    }
                }
            } else {
                html += `<span style="color:#ffaa00;">‚ö†Ô∏è Adicione coordenadas aos pontos</span>`;
            }

            el.innerHTML = html;
        }

        // ===== PREVIEW NO MAPA =====
        function previewAlignment() {
            const alignment = calculateAlignment();
            
            if (!alignment) {
                alert('Voc√™ precisa de pelo menos 2 pontos com coordenadas para ver o alinhamento!');
                return;
            }

            document.getElementById('previewModal').style.display = 'flex';

            // Inicializar mapa se n√£o existir
            setTimeout(() => {
                if (!previewMap) {
                    previewMap = L.map('previewMap', {
                        zoomControl: true
                    });

                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap'
                    }).addTo(previewMap);
                }

                // Limpar camadas anteriores
                previewMap.eachLayer(layer => {
                    if (layer instanceof L.ImageOverlay || layer instanceof L.Marker || layer instanceof L.Circle || layer instanceof L.Polygon) {
                        previewMap.removeLayer(layer);
                    }
                });

                // Adicionar overlay da imagem
                const bounds = L.latLngBounds(
                    [alignment.bounds.south, alignment.bounds.west],
                    [alignment.bounds.north, alignment.bounds.east]
                );

                L.imageOverlay(imageElement.src, bounds, {
                    opacity: 0.75
                }).addTo(previewMap);

                // √çcone personalizado para GCPs
                const gcpIcon = L.divIcon({
                    className: 'gcp-map-marker',
                    html: '<div style="background:#ff00ff;border:2px solid white;border-radius:50%;width:16px;height:16px;box-shadow:0 0 10px rgba(255,0,255,0.8);"></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });

                // Adicionar marcadores dos GCPs com c√≠rculos de erro
                alignment.gcpPoints.forEach((p, i) => {
                    // Marcador do GCP
                    L.marker([p.lat, p.lng], {icon: gcpIcon})
                        .bindPopup(`<b>GCP ${i+1}</b><br>Lat: ${p.lat.toFixed(6)}¬∞<br>Lng: ${p.lng.toFixed(6)}¬∞<br>Pixel: (${Math.round(p.pixelX)}, ${Math.round(p.pixelY)})`)
                        .addTo(previewMap);
                    
                    // Mostrar posi√ß√£o calculada pela transforma√ß√£o
                    if (affineTransform) {
                        const calculated = applyAffineTransform(affineTransform, p.pixelX, p.pixelY);
                        // C√≠rculo mostrando a posi√ß√£o calculada
                        L.circle([calculated.lat, calculated.lng], {
                            radius: 5000, // 5km
                            color: '#00ff00',
                            fillColor: '#00ff00',
                            fillOpacity: 0.3,
                            weight: 2
                        }).bindPopup(`Posi√ß√£o calculada para GCP ${i+1}`).addTo(previewMap);
                    }
                });

                // Desenhar ret√¢ngulo dos bounds
                const boundsRect = L.polygon([
                    [alignment.bounds.north, alignment.bounds.west],
                    [alignment.bounds.north, alignment.bounds.east],
                    [alignment.bounds.south, alignment.bounds.east],
                    [alignment.bounds.south, alignment.bounds.west]
                ], {
                    color: '#00d9ff',
                    weight: 2,
                    fillOpacity: 0,
                    dashArray: '5, 5'
                }).addTo(previewMap);

                previewMap.fitBounds(bounds);
                previewMap.invalidateSize();
            }, 100);
        }

        function closePreview() {
            document.getElementById('previewModal').style.display = 'none';
        }

        // ===== BAIXAR IMAGEM =====
        function downloadImage() {
            if (!imageLoaded || !imageElement.src) {
                alert('Carregue uma imagem primeiro!');
                return;
            }

            // Criar link de download
            const a = document.createElement('a');
            a.href = imageElement.src;
            
            // Extrair nome do arquivo ou gerar um
            let filename = 'satellite_image.png';
            if (imageElement.src.startsWith('data:')) {
                // √â uma imagem carregada localmente (base64)
                const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
                filename = `satellite_${timestamp}.png`;
            } else {
                // Tenta extrair nome da URL
                const urlParts = imageElement.src.split('/');
                const lastPart = urlParts[urlParts.length - 1].split('?')[0];
                if (lastPart && lastPart.includes('.')) {
                    filename = lastPart;
                }
            }
            
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // ===== EXPORTAR/IMPORTAR =====
        function exportAlignment() {
            const alignment = calculateAlignment();
            if (!alignment) {
                alert('Configure os pontos de refer√™ncia primeiro!');
                return;
            }

            const data = {
                timestamp: new Date().toISOString(),
                ...alignment
            };

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `alignment_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importAlignment() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            const data = JSON.parse(event.target.result);
                            applyImportedAlignment(data);
                        } catch (err) {
                            alert('Erro ao ler arquivo: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function applyImportedAlignment(data) {
            if (data.gcpPoints) {
                clearAllPoints();
                data.gcpPoints.forEach(p => {
                    gcpCounter++;
                    const id = gcpCounter;
                    
                    const pointEl = document.createElement('div');
                    pointEl.className = 'image-point';
                    pointEl.innerHTML = id;
                    pointEl.dataset.id = id;
                    document.getElementById('imageContainer').appendChild(pointEl);
                    pointEl.style.left = (p.pixelX * currentZoom) + 'px';
                    pointEl.style.top = (p.pixelY * currentZoom) + 'px';
                    setupPointDrag(pointEl);

                    gcpPoints.push({
                        id: id,
                        pixelX: p.pixelX,
                        pixelY: p.pixelY,
                        lat: p.lat,
                        lng: p.lng,
                        element: pointEl
                    });
                });
                updateGcpList();
                updateSummary();
            }
        }

        // Scroll para zoom
        document.getElementById('imageArea').addEventListener('wheel', function(e) {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            zoomImage(factor);
        });
    </script>
</body>
</html>
