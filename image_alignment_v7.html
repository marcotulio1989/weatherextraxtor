<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ∞Ô∏è Alinhamento V7 - Cantos Arrast√°veis</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #0a0a15;
            color: #eee;
            overflow: hidden;
        }
        .container { display: flex; height: 100vh; }
        
        .control-panel {
            width: 320px;
            background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
            padding: 12px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            z-index: 1000;
            flex-shrink: 0;
        }
        .control-panel h1 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #e94560;
            text-align: center;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 8px;
        }
        .control-section {
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(15, 52, 96, 0.5);
            border-radius: 8px;
        }
        .control-section h3 {
            color: #00d9ff;
            margin-bottom: 8px;
            font-size: 0.8em;
        }
        .btn {
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8em;
            transition: all 0.2s;
        }
        .btn-primary { background: linear-gradient(135deg, #e94560, #c23a51); color: white; }
        .btn-secondary { background: #0f3460; color: #00d9ff; border: 1px solid #00d9ff; }
        .btn-success { background: linear-gradient(135deg, #00b894, #00a381); color: white; }
        .btn-warning { background: linear-gradient(135deg, #fdcb6e, #e17055); color: #1a1a2e; }
        .btn-danger { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 3px 10px rgba(0,0,0,0.3); }
        .btn.active { background: #ff00ff !important; animation: pulse 1s infinite; }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255,0,255,0.5); }
            50% { box-shadow: 0 0 15px rgba(255,0,255,0.8); }
        }
        
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
        .btn-grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; }
        
        #map { flex: 1; background: #1a1a2e; position: relative; }
        
        .slider-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            gap: 6px;
        }
        .slider-row label {
            width: 65px;
            font-size: 0.7em;
            color: #aaa;
        }
        .slider-row input[type="range"] {
            flex: 1;
            height: 5px;
            border-radius: 3px;
            background: #0f3460;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
        }
        .slider-row .value {
            width: 45px;
            font-size: 0.7em;
            color: #00ff00;
            text-align: right;
            font-family: monospace;
        }
        
        .status-bar {
            font-size: 0.75em;
            color: #888;
            padding: 6px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            margin-top: 6px;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
        }
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0; top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%; height: 100%;
        }
        
        .instructions {
            font-size: 0.7em;
            color: #888;
            line-height: 1.4;
            padding: 6px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            border-left: 2px solid #00d9ff;
        }
        .instructions.highlight {
            border-left-color: #00ff00;
            background: rgba(0,255,0,0.1);
            color: #00ff00;
        }
        
        /* Marcadores de canto */
        .corner-marker {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border: 2px solid white;
        }
        .corner-nw { background: #e74c3c; }
        .corner-ne { background: #3498db; }
        .corner-sw { background: #f39c12; }
        .corner-se { background: #27ae60; }
        
        /* Garantir que marcadores Leaflet fiquem acima dos canvas */
        .leaflet-marker-pane {
            z-index: 600 !important;
        }
        .leaflet-popup-pane {
            z-index: 700 !important;
        }
        
        /* Marcador de ponto de grade */
        .control-point {
            width: 14px;
            height: 14px;
            background: #ff00ff;
            border: 2px solid white;
            border-radius: 50%;
            cursor: move;
            box-shadow: 0 0 8px rgba(255,0,255,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            font-weight: bold;
            color: white;
        }
        
        /* Canvas overlay - z-index baixo para n√£o bloquear marcadores Leaflet */
        #imageCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 200;
        }
        
        #selectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 250;
        }
        
        .corner-coords {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 4px;
            font-size: 0.7em;
            margin-top: 8px;
        }
        .corner-coords span {
            padding: 3px 5px;
            background: #0a0a15;
            border-radius: 3px;
        }
        .corner-coords .label { 
            font-weight: bold; 
        }
        .corner-coords .nw { color: #e74c3c; }
        .corner-coords .ne { color: #3498db; }
        .corner-coords .sw { color: #f39c12; }
        .corner-coords .se { color: #27ae60; }
        
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }
        
        .delete-mode-active {
            border: 3px solid #e74c3c !important;
        }
        
        .triangle-list {
            max-height: 100px;
            overflow-y: auto;
            background: #0a0a15;
            padding: 4px;
            border-radius: 4px;
            margin-top: 6px;
        }
        .triangle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 3px 6px;
            margin-bottom: 2px;
            background: rgba(255,0,0,0.2);
            border-radius: 3px;
            font-size: 0.65em;
            border-left: 3px solid #e74c3c;
        }
        .triangle-item button {
            background: #00b894;
            border: none;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <h1>üõ∞Ô∏è Alinhamento V7</h1>

            <!-- Carregar Imagem -->
            <div class="control-section">
                <h3>üìÅ Imagem</h3>
                <div class="btn-grid">
                    <button class="btn btn-primary" onclick="loadNoaaImage('goes19')" style="font-size:0.7em;">üõ∞Ô∏è GOES-19</button>
                    <button class="btn btn-primary" onclick="loadNoaaImage('goes16')" style="font-size:0.7em; background:#3498db;">üõ∞Ô∏è GOES-16</button>
                </div>
                <div class="btn-grid" style="margin-top: 4px;">
                    <button class="btn btn-success" onclick="loadFullDisk('goes19')" style="font-size:0.65em;">üåé Full Disk 19</button>
                    <button class="btn btn-success" onclick="loadFullDisk('goes16')" style="font-size:0.65em;">üåé Full Disk 16</button>
                </div>
                <div class="file-input-wrapper">
                    <button class="btn btn-secondary">üìÇ Arquivo Local</button>
                    <input type="file" id="imageInput" accept="image/*">
                </div>
                <div class="status-bar" id="imageStatus">Nenhuma imagem carregada</div>
            </div>

            <!-- Reproje√ß√£o Full Disk -->
            <div class="control-section" id="reprojectionSection" style="display: none;">
                <h3>üåç Reproje√ß√£o Full Disk ‚Üí Plano</h3>
                <div class="instructions" style="margin-bottom: 8px;">
                    Transforma o disco esf√©rico em mapa plano (Plate Carr√©e).
                </div>
                <button class="btn btn-warning" onclick="reprojectFullDisk()" id="btnReproject">
                    üîÑ Reprojetar para Plano
                </button>
                <div class="slider-row" style="margin-top: 8px;">
                    <label>Qualidade:</label>
                    <input type="range" id="reprojQuality" min="200" max="1000" step="100" value="600">
                    <span class="value" id="reprojQualityVal">600px</span>
                </div>
                <div class="slider-row">
                    <label>Sat Lon:</label>
                    <input type="range" id="satLongitude" min="-180" max="0" step="0.1" value="-75.2">
                    <span class="value" id="satLongitudeVal">-75.2¬∞</span>
                </div>
                <div class="status-bar" id="reprojStatus">Aguardando...</div>
            </div>

            <!-- Mapa de Fundo -->
            <div class="control-section">
                <h3>üó∫Ô∏è Mapa de Fundo</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                    <button class="btn btn-secondary map-layer-btn active" data-layer="contornos" onclick="setMapLayer('contornos')" style="font-size:0.65em;">
                        üìç Contornos
                    </button>
                    <button class="btn btn-secondary map-layer-btn" data-layer="contornosEscuro" onclick="setMapLayer('contornosEscuro')" style="font-size:0.65em;">
                        üåë Escuro
                    </button>
                    <button class="btn btn-secondary map-layer-btn" data-layer="fronteiras" onclick="setMapLayer('fronteiras')" style="font-size:0.65em;">
                        üî≤ Fronteiras
                    </button>
                    <button class="btn btn-secondary map-layer-btn" data-layer="osm" onclick="setMapLayer('osm')" style="font-size:0.65em;">
                        üèôÔ∏è OSM
                    </button>
                    <button class="btn btn-secondary map-layer-btn" data-layer="satelite" onclick="setMapLayer('satelite')" style="font-size:0.65em; grid-column: span 2;">
                        üõ∞Ô∏è Sat√©lite ESRI
                    </button>
                </div>
                <div class="slider-row" style="margin-top: 8px;">
                    <label>Opac. Mapa:</label>
                    <input type="range" id="mapOpacity" min="10" max="100" step="5" value="60" oninput="updateMapOpacity()">
                    <span class="value" id="mapOpacityVal">60%</span>
                </div>
            </div>

            <!-- NOVO: Cantos Arrast√°veis -->
            <div class="control-section">
                <h3>üìç Cantos da Imagem (ARRASTE NO MAPA!)</h3>
                <div class="instructions highlight">
                    <b>ARRASTE os 4 marcadores coloridos</b> no mapa para definir os cantos da imagem:
                    <br>üî¥ NW (Noroeste) | üîµ NE (Nordeste)
                    <br>üü† SW (Sudoeste) | üü¢ SE (Sudeste)
                </div>
                
                <div class="corner-coords">
                    <span class="label nw">üî¥ NW:</span>
                    <span id="nwLat">-</span>
                    <span id="nwLng">-</span>
                    
                    <span class="label ne">üîµ NE:</span>
                    <span id="neLat">-</span>
                    <span id="neLng">-</span>
                    
                    <span class="label sw">üü† SW:</span>
                    <span id="swLat">-</span>
                    <span id="swLng">-</span>
                    
                    <span class="label se">üü¢ SE:</span>
                    <span id="seLat">-</span>
                    <span id="seLng">-</span>
                </div>
                
                <button class="btn btn-success" onclick="fitToCorners()" style="margin-top:8px;">
                    üéØ Aplicar Cantos √† Imagem
                </button>
            </div>

            <!-- Presets de √Årea -->
            <div class="control-section">
                <h3>‚ö° Presets de √Årea</h3>
                <div class="preset-grid">
                    <button class="btn btn-secondary" onclick="setPreset('goes_ssa')" style="font-size:0.65em;">
                        üõ∞Ô∏è GOES SSA
                    </button>
                    <button class="btn btn-secondary" onclick="setPreset('goes_full')" style="font-size:0.65em;">
                        üåé GOES Full Disk
                    </button>
                    <button class="btn btn-secondary" onclick="setPreset('brazil')" style="font-size:0.65em;">
                        üáßüá∑ Brasil
                    </button>
                    <button class="btn btn-secondary" onclick="setPreset('south_america')" style="font-size:0.65em;">
                        üåé Am√©rica do Sul
                    </button>
                </div>
            </div>

            <!-- Grade -->
            <div class="control-section">
                <h3>üìê Grade de Pontos</h3>
                
                <!-- Grade Customizada -->
                <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <label style="font-size: 0.7em; color: #aaa;">Linhas:</label>
                        <input type="number" id="customRows" min="2" max="50" value="4" 
                               style="width: 50px; padding: 4px; border-radius: 4px; border: 1px solid #0f3460; 
                                      background: #0a0a15; color: #00d9ff; font-size: 0.8em; text-align: center;">
                    </div>
                    <span style="color: #666;">√ó</span>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <label style="font-size: 0.7em; color: #aaa;">Colunas:</label>
                        <input type="number" id="customCols" min="2" max="50" value="4" 
                               style="width: 50px; padding: 4px; border-radius: 4px; border: 1px solid #0f3460; 
                                      background: #0a0a15; color: #00d9ff; font-size: 0.8em; text-align: center;">
                    </div>
                </div>
                <button class="btn btn-success" onclick="applyCustomGrid()" style="font-size: 0.75em; margin-bottom: 8px;">
                    ‚úÖ Aplicar Grade Customizada
                </button>
                
                <!-- Presets r√°pidos -->
                <div style="font-size: 0.65em; color: #888; margin-bottom: 4px;">Presets r√°pidos:</div>
                <div class="btn-grid-3">
                    <button class="btn btn-secondary" onclick="setGrid(2,2)" style="font-size:0.65em;">2√ó2</button>
                    <button class="btn btn-secondary" onclick="setGrid(3,3)" style="font-size:0.65em;">3√ó3</button>
                    <button class="btn btn-secondary" onclick="setGrid(5,5)" style="font-size:0.65em;">5√ó5</button>
                    <button class="btn btn-secondary" onclick="setGrid(10,10)" style="font-size:0.65em;">10√ó10</button>
                    <button class="btn btn-secondary" onclick="setGrid(15,15)" style="font-size:0.65em;">15√ó15</button>
                    <button class="btn btn-secondary" onclick="setGrid(20,20)" style="font-size:0.65em;">20√ó20</button>
                </div>
                <div class="status-bar">Pontos: <span id="pointCount">0</span> | Tri√¢ngulos: <span id="triangleCount">0</span></div>
            </div>

            <!-- NOVO: Deslocamento Global -->
            <div class="control-section">
                <h3>üéØ Mover Imagem Toda</h3>
                <div class="instructions" style="margin-bottom: 8px;">
                    Use os bot√µes ou sliders para deslocar toda a imagem de sat√©lite.
                </div>
                
                <!-- Bot√µes direcionais -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-bottom: 10px;">
                    <div></div>
                    <button class="btn btn-secondary" onclick="moveImage(0, -1)" style="font-size: 1.2em; padding: 8px;">‚¨ÜÔ∏è</button>
                    <div></div>
                    <button class="btn btn-secondary" onclick="moveImage(-1, 0)" style="font-size: 1.2em; padding: 8px;">‚¨ÖÔ∏è</button>
                    <button class="btn btn-warning" onclick="resetOffset()" style="font-size: 0.7em; padding: 8px;">üéØ</button>
                    <button class="btn btn-secondary" onclick="moveImage(1, 0)" style="font-size: 1.2em; padding: 8px;">‚û°Ô∏è</button>
                    <div></div>
                    <button class="btn btn-secondary" onclick="moveImage(0, 1)" style="font-size: 1.2em; padding: 8px;">‚¨áÔ∏è</button>
                    <div></div>
                </div>
                
                <!-- Sliders de offset -->
                <div class="slider-row">
                    <label>Offset X:</label>
                    <input type="range" id="offsetX" min="-500" max="500" step="1" value="0" oninput="redraw()">
                    <span class="value" id="offsetXVal">0px</span>
                </div>
                <div class="slider-row">
                    <label>Offset Y:</label>
                    <input type="range" id="offsetY" min="-500" max="500" step="1" value="0" oninput="redraw()">
                    <span class="value" id="offsetYVal">0px</span>
                </div>
                
                <!-- Passo do movimento -->
                <div style="display: flex; gap: 8px; align-items: center; margin-top: 8px;">
                    <label style="font-size: 0.7em; color: #aaa;">Passo (px):</label>
                    <input type="number" id="moveStep" min="1" max="100" value="10" 
                           style="width: 60px; padding: 4px; border-radius: 4px; border: 1px solid #0f3460; 
                                  background: #0a0a15; color: #00d9ff; font-size: 0.8em; text-align: center;">
                </div>
            </div>

            <!-- NOVO: Perspectiva/Trap√©zio -->
            <div class="control-section">
                <h3>üìê Perspectiva (Esticar/Encolher)</h3>
                <div class="instructions" style="margin-bottom: 8px;">
                    Ajuste a largura da parte superior ou inferior separadamente.
                </div>
                
                <!-- Parte Superior -->
                <div style="margin-bottom: 10px;">
                    <div style="font-size: 0.7em; color: #e74c3c; margin-bottom: 4px;">üî∫ Parte Superior</div>
                    <div class="slider-row">
                        <label>Largura:</label>
                        <input type="range" id="topScale" min="0.5" max="1.5" step="0.01" value="1" oninput="redraw()">
                        <span class="value" id="topScaleVal">1.00</span>
                    </div>
                    <div class="slider-row">
                        <label>Offset Y:</label>
                        <input type="range" id="topOffsetY" min="-200" max="200" step="1" value="0" oninput="redraw()">
                        <span class="value" id="topOffsetYVal">0px</span>
                    </div>
                </div>
                
                <!-- Parte Inferior -->
                <div style="margin-bottom: 10px;">
                    <div style="font-size: 0.7em; color: #27ae60; margin-bottom: 4px;">üîª Parte Inferior</div>
                    <div class="slider-row">
                        <label>Largura:</label>
                        <input type="range" id="bottomScale" min="0.5" max="1.5" step="0.01" value="1" oninput="redraw()">
                        <span class="value" id="bottomScaleVal">1.00</span>
                    </div>
                    <div class="slider-row">
                        <label>Offset Y:</label>
                        <input type="range" id="bottomOffsetY" min="-200" max="200" step="1" value="0" oninput="redraw()">
                        <span class="value" id="bottomOffsetYVal">0px</span>
                    </div>
                </div>
                
                <button class="btn btn-warning" onclick="resetPerspective()" style="font-size:0.7em;">
                    ‚Ü©Ô∏è Resetar Perspectiva
                </button>
            </div>

            <!-- Ajustes Finos -->
            <div class="control-section">
                <h3>üîß Ajustes Finos</h3>
                <div class="slider-row">
                    <label>Rota√ß√£o:</label>
                    <input type="range" id="rotation" min="-15" max="15" step="0.1" value="0" oninput="redraw()">
                    <span class="value" id="rotationVal">0¬∞</span>
                </div>
                <div class="slider-row">
                    <label>Escala X:</label>
                    <input type="range" id="scaleX" min="0.8" max="1.2" step="0.005" value="1" oninput="redraw()">
                    <span class="value" id="scaleXVal">1.00</span>
                </div>
                <div class="slider-row">
                    <label>Escala Y:</label>
                    <input type="range" id="scaleY" min="0.8" max="1.2" step="0.005" value="1" oninput="redraw()">
                    <span class="value" id="scaleYVal">1.00</span>
                </div>
                <div class="slider-row">
                    <label>Opacidade:</label>
                    <input type="range" id="opacity" min="10" max="100" step="1" value="95" oninput="redraw()">
                    <span class="value" id="opacityVal">95%</span>
                </div>
                <button class="btn btn-warning" onclick="resetFineAdjust()" style="font-size:0.7em;">
                    ‚Ü©Ô∏è Resetar Ajustes
                </button>
            </div>

            <!-- Deletar Tri√¢ngulos -->
            <div class="control-section">
                <h3>üóëÔ∏è Remover √Åreas</h3>
                <button class="btn btn-danger" id="btnDeleteMode" onclick="toggleDeleteMode()">
                    ‚úÇÔ∏è Modo Deletar
                </button>
                <div class="instructions" id="deleteInstructions" style="display:none;">
                    Clique nos tri√¢ngulos para exclu√≠-los.
                </div>
                <div id="deletedList" class="triangle-list" style="display:none;">
                    <div id="deletedItems"></div>
                </div>
                <button class="btn btn-secondary" onclick="restoreAllTriangles()" style="margin-top:5px; font-size:0.7em;">
                    ‚Ü©Ô∏è Restaurar Todos
                </button>
            </div>

            <!-- Exportar/Importar -->
            <div class="control-section">
                <h3>üíæ Salvar/Carregar</h3>
                <div class="btn-grid">
                    <button class="btn btn-success" onclick="exportConfig()">üì§ Exportar</button>
                    <button class="btn btn-secondary" onclick="importConfig()">üì• Importar</button>
                </div>
            </div>
        </div>

        <div id="map">
            <canvas id="imageCanvas"></canvas>
            <canvas id="selectionCanvas"></canvas>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
    <script>
        // ===== ESTADO =====
        let map = null;
        let imageElement = null;
        let imageLoaded = false;
        let canvas, ctx;
        let selCanvas, selCtx;
        
        // NOVO: Marcadores de canto
        let cornerMarkers = {
            nw: null, ne: null, sw: null, se: null
        };
        let cornerBounds = {
            nw: { lat: 15, lng: -100 },
            ne: { lat: 15, lng: -30 },
            sw: { lat: -55, lng: -100 },
            se: { lat: -55, lng: -30 }
        };
        let boundsRectangle = null;
        
        // Pontos de controle
        let controlPoints = [];
        let gridRows = 4, gridCols = 4;
        let pointIdCounter = 0;
        
        // Triangula√ß√£o
        let triangles = [];
        let deletedTriangles = new Set();
        
        // Modo deletar
        let deleteMode = false;

        // Presets conhecidos
        const PRESETS = {
            goes_ssa: {
                name: 'GOES SSA (South America Sector)',
                nw: { lat: 14.98, lng: -101.04 },
                ne: { lat: 14.98, lng: -30.98 },
                sw: { lat: -54.98, lng: -101.04 },
                se: { lat: -54.98, lng: -30.98 }
            },
            goes_full: {
                name: 'GOES Full Disk',
                nw: { lat: 60, lng: -135 },
                ne: { lat: 60, lng: 15 },
                sw: { lat: -60, lng: -135 },
                se: { lat: -60, lng: 15 }
            },
            brazil: {
                name: 'Brasil',
                nw: { lat: 5.5, lng: -74 },
                ne: { lat: 5.5, lng: -34 },
                sw: { lat: -34, lng: -74 },
                se: { lat: -34, lng: -34 }
            },
            south_america: {
                name: 'Am√©rica do Sul',
                nw: { lat: 15, lng: -82 },
                ne: { lat: 15, lng: -34 },
                sw: { lat: -56, lng: -82 },
                se: { lat: -56, lng: -34 }
            }
        };

        // ===== INIT =====
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            initCanvas();
            initCornerMarkers();
            setupEvents();
        });

        // Op√ß√µes de mapa de fundo
        const MAP_LAYERS = {
            contornos: {
                name: 'Contornos',
                url: 'https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png',
                attribution: '¬© CartoDB'
            },
            contornosEscuro: {
                name: 'Contornos Escuro',
                url: 'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png',
                attribution: '¬© CartoDB'
            },
            fronteiras: {
                name: 'S√≥ Fronteiras',
                url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lines/{z}/{x}/{y}{r}.png',
                attribution: '¬© Stamen'
            },
            osm: {
                name: 'OpenStreetMap',
                url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                attribution: '¬© OSM'
            },
            satelite: {
                name: 'Sat√©lite ESRI',
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                attribution: '¬© ESRI'
            }
        };
        let currentBaseLayer = null;

        function initMap() {
            map = L.map('map', {
                center: [-20, -55],
                zoom: 4
            });

            // Usar mapa de contornos por padr√£o (sem cidades/labels)
            setMapLayer('contornos');

            map.on('move zoom moveend zoomend', redraw);
        }

        function setMapLayer(layerKey) {
            const layer = MAP_LAYERS[layerKey];
            if (!layer) return;
            
            if (currentBaseLayer) {
                map.removeLayer(currentBaseLayer);
            }
            
            const opacity = parseFloat(document.getElementById('mapOpacity').value) / 100;
            
            currentBaseLayer = L.tileLayer(layer.url, {
                attribution: layer.attribution,
                opacity: opacity,
                subdomains: 'abcd'
            }).addTo(map);
            
            // Atualizar bot√µes ativos
            document.querySelectorAll('.map-layer-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.layer === layerKey) {
                    btn.classList.add('active');
                }
            });
        }
        
        function updateMapOpacity() {
            const opacity = parseFloat(document.getElementById('mapOpacity').value) / 100;
            document.getElementById('mapOpacityVal').textContent = document.getElementById('mapOpacity').value + '%';
            if (currentBaseLayer) {
                currentBaseLayer.setOpacity(opacity);
            }
        }

        function initCanvas() {
            canvas = document.getElementById('imageCanvas');
            ctx = canvas.getContext('2d');
            
            selCanvas = document.getElementById('selectionCanvas');
            selCtx = selCanvas.getContext('2d');
            
            resizeCanvas();
            new ResizeObserver(resizeCanvas).observe(document.getElementById('map'));
        }

        function resizeCanvas() {
            const mapEl = document.getElementById('map');
            canvas.width = selCanvas.width = mapEl.offsetWidth;
            canvas.height = selCanvas.height = mapEl.offsetHeight;
            redraw();
        }

        // ===== MARCADORES DE CANTO =====
        function initCornerMarkers() {
            const corners = [
                { key: 'nw', label: 'NW', color: 'corner-nw' },
                { key: 'ne', label: 'NE', color: 'corner-ne' },
                { key: 'sw', label: 'SW', color: 'corner-sw' },
                { key: 'se', label: 'SE', color: 'corner-se' }
            ];

            corners.forEach(c => {
                const icon = L.divIcon({
                    className: `corner-marker ${c.color}`,
                    html: c.label,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });

                cornerMarkers[c.key] = L.marker(
                    [cornerBounds[c.key].lat, cornerBounds[c.key].lng],
                    { icon: icon, draggable: true }
                ).addTo(map);

                cornerMarkers[c.key].on('drag dragend', function() {
                    const ll = cornerMarkers[c.key].getLatLng();
                    cornerBounds[c.key].lat = ll.lat;
                    cornerBounds[c.key].lng = ll.lng;
                    updateCornerDisplay();
                    updateBoundsRectangle();
                });
            });

            // Ret√¢ngulo mostrando os limites
            boundsRectangle = L.rectangle([
                [cornerBounds.nw.lat, cornerBounds.nw.lng],
                [cornerBounds.se.lat, cornerBounds.se.lng]
            ], {
                color: '#ff00ff',
                weight: 2,
                fill: false,
                dashArray: '10, 5'
            }).addTo(map);

            updateCornerDisplay();
        }

        function updateCornerDisplay() {
            document.getElementById('nwLat').textContent = cornerBounds.nw.lat.toFixed(2) + '¬∞';
            document.getElementById('nwLng').textContent = cornerBounds.nw.lng.toFixed(2) + '¬∞';
            document.getElementById('neLat').textContent = cornerBounds.ne.lat.toFixed(2) + '¬∞';
            document.getElementById('neLng').textContent = cornerBounds.ne.lng.toFixed(2) + '¬∞';
            document.getElementById('swLat').textContent = cornerBounds.sw.lat.toFixed(2) + '¬∞';
            document.getElementById('swLng').textContent = cornerBounds.sw.lng.toFixed(2) + '¬∞';
            document.getElementById('seLat').textContent = cornerBounds.se.lat.toFixed(2) + '¬∞';
            document.getElementById('seLng').textContent = cornerBounds.se.lng.toFixed(2) + '¬∞';
        }

        function updateBoundsRectangle() {
            if (boundsRectangle) {
                // Usar os 4 cantos para fazer um pol√≠gono
                boundsRectangle.setLatLngs([
                    [cornerBounds.nw.lat, cornerBounds.nw.lng],
                    [cornerBounds.ne.lat, cornerBounds.ne.lng],
                    [cornerBounds.se.lat, cornerBounds.se.lng],
                    [cornerBounds.sw.lat, cornerBounds.sw.lng]
                ]);
            }
        }

        function fitToCorners() {
            if (!imageLoaded) {
                alert('Carregue uma imagem primeiro!');
                return;
            }
            createGridFromCorners();
            triangulate();
            redraw();
        }

        function setPreset(presetKey) {
            const preset = PRESETS[presetKey];
            if (!preset) return;

            // Atualizar bounds
            cornerBounds.nw = { ...preset.nw };
            cornerBounds.ne = { ...preset.ne };
            cornerBounds.sw = { ...preset.sw };
            cornerBounds.se = { ...preset.se };

            // Mover marcadores
            cornerMarkers.nw.setLatLng([preset.nw.lat, preset.nw.lng]);
            cornerMarkers.ne.setLatLng([preset.ne.lat, preset.ne.lng]);
            cornerMarkers.sw.setLatLng([preset.sw.lat, preset.sw.lng]);
            cornerMarkers.se.setLatLng([preset.se.lat, preset.se.lng]);

            updateCornerDisplay();
            updateBoundsRectangle();

            // Ajustar vis√£o do mapa
            map.fitBounds([
                [preset.nw.lat, preset.nw.lng],
                [preset.se.lat, preset.se.lng]
            ], { padding: [20, 20] });

            // Se tiver imagem, recriar grade
            if (imageLoaded) {
                createGridFromCorners();
                triangulate();
                redraw();
            }
        }

        // ===== EVENTOS =====
        function setupEvents() {
            document.getElementById('imageInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => loadImage(ev.target.result, file.name);
                    reader.readAsDataURL(file);
                }
            });

            selCanvas.addEventListener('click', function(e) {
                if (!deleteMode || !imageLoaded) return;
                const rect = selCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                clickOnTriangle(x, y);
            });

            selCanvas.addEventListener('mousemove', function(e) {
                if (!deleteMode) return;
                selCanvas.style.cursor = 'crosshair';
            });
            
            // Eventos para sliders de reproje√ß√£o
            document.getElementById('reprojQuality').addEventListener('input', function() {
                document.getElementById('reprojQualityVal').textContent = this.value + 'px';
            });
            
            document.getElementById('satLongitude').addEventListener('input', function() {
                document.getElementById('satLongitudeVal').textContent = parseFloat(this.value).toFixed(1) + '¬∞';
            });
        }

        // ===== CARREGAR IMAGEM =====
        const NOAA = {
            goes19: { name: 'GOES-19', url: 'https://cdn.star.nesdis.noaa.gov/GOES19/ABI/SECTOR/ssa/13/latest.jpg' },
            goes16: { name: 'GOES-16', url: 'https://cdn.star.nesdis.noaa.gov/GOES16/ABI/SECTOR/ssa/13/latest.jpg' }
        };
        
        const NOAA_FULLDISK = {
            goes19: { 
                name: 'GOES-19 Full Disk', 
                url: 'https://cdn.star.nesdis.noaa.gov/GOES19/ABI/FD/GEOCOLOR/latest.jpg',
                longitude: -75.2 // GOES-19 est√° em -75.2¬∞W
            },
            goes16: { 
                name: 'GOES-16 Full Disk', 
                url: 'https://cdn.star.nesdis.noaa.gov/GOES16/ABI/FD/GEOCOLOR/latest.jpg',
                longitude: -75.2 // GOES-16 est√° em -75.2¬∞W
            }
        };
        
        let isFullDisk = false;
        let originalFullDiskImage = null;

        function loadNoaaImage(sat) {
            const s = NOAA[sat];
            document.getElementById('imageStatus').innerHTML = '‚è≥ Baixando ' + s.name + '...';
            
            // Esconder se√ß√£o de reproje√ß√£o
            document.getElementById('reprojectionSection').style.display = 'none';
            isFullDisk = false;
            
            // Aplicar preset GOES SSA automaticamente
            setPreset('goes_ssa');
            
            loadImage(s.url + '?t=' + Date.now(), s.name);
        }
        
        function loadFullDisk(sat) {
            const s = NOAA_FULLDISK[sat];
            document.getElementById('imageStatus').innerHTML = '‚è≥ Baixando ' + s.name + '...';
            document.getElementById('satLongitude').value = s.longitude;
            document.getElementById('satLongitudeVal').textContent = s.longitude + '¬∞';
            
            isFullDisk = true;
            
            // Mostrar se√ß√£o de reproje√ß√£o
            document.getElementById('reprojectionSection').style.display = 'block';
            document.getElementById('reprojStatus').innerHTML = '‚è≥ Carregando disco...';
            
            // Aplicar preset full disk
            setPreset('goes_full');
            
            // Carregar imagem original
            originalFullDiskImage = new Image();
            originalFullDiskImage.crossOrigin = 'anonymous';
            
            originalFullDiskImage.onload = function() {
                document.getElementById('imageStatus').innerHTML = `‚úÖ ${s.name} (${this.width}√ó${this.height})`;
                document.getElementById('imageStatus').style.color = '#00ff00';
                document.getElementById('reprojStatus').innerHTML = '‚úÖ Pronto! Clique em "Reprojetar para Plano"';
                document.getElementById('reprojStatus').style.color = '#00ff00';
            };
            
            originalFullDiskImage.onerror = function() {
                document.getElementById('imageStatus').innerHTML = '‚ùå Erro ao carregar';
                document.getElementById('imageStatus').style.color = '#ff4444';
            };
            
            originalFullDiskImage.src = s.url + '?t=' + Date.now();
        }
        
        // ===== REPROJE√á√ÉO GEOESTACION√ÅRIA ‚Üí PLATE CARR√âE =====
        function reprojectFullDisk() {
            if (!originalFullDiskImage) {
                alert('Carregue uma imagem Full Disk primeiro!');
                return;
            }
            
            document.getElementById('reprojStatus').innerHTML = 'üîÑ Reprojetando...';
            document.getElementById('btnReproject').disabled = true;
            
            // Usar setTimeout para permitir UI update
            setTimeout(() => {
                try {
                    const reprojectedCanvas = geostatToPlateCarree(originalFullDiskImage);
                    
                    // Converter canvas para imagem
                    imageElement = new Image();
                    imageElement.onload = function() {
                        imageLoaded = true;
                        isFullDisk = false; // Agora √© uma imagem plana
                        
                        document.getElementById('reprojStatus').innerHTML = '‚úÖ Reproje√ß√£o conclu√≠da!';
                        document.getElementById('reprojStatus').style.color = '#00ff00';
                        document.getElementById('btnReproject').disabled = false;
                        
                        // Aplicar bounds da √°rea vis√≠vel do sat√©lite
                        const satLonDeg = parseFloat(document.getElementById('satLongitude').value);
                        const visibleRange = 81; // graus de visibilidade do sat√©lite
                        
                        // Definir cantos para √°rea vis√≠vel do sat√©lite
                        cornerBounds.nw = { lat: visibleRange, lng: satLonDeg - visibleRange };
                        cornerBounds.ne = { lat: visibleRange, lng: satLonDeg + visibleRange };
                        cornerBounds.sw = { lat: -visibleRange, lng: satLonDeg - visibleRange };
                        cornerBounds.se = { lat: -visibleRange, lng: satLonDeg + visibleRange };
                        
                        // Atualizar marcadores
                        cornerMarkers.nw.setLatLng([cornerBounds.nw.lat, cornerBounds.nw.lng]);
                        cornerMarkers.ne.setLatLng([cornerBounds.ne.lat, cornerBounds.ne.lng]);
                        cornerMarkers.sw.setLatLng([cornerBounds.sw.lat, cornerBounds.sw.lng]);
                        cornerMarkers.se.setLatLng([cornerBounds.se.lat, cornerBounds.se.lng]);
                        
                        updateCornerDisplay();
                        updateBoundsRectangle();
                        
                        // Ajustar vis√£o do mapa
                        map.fitBounds([
                            [cornerBounds.nw.lat, cornerBounds.nw.lng],
                            [cornerBounds.se.lat, cornerBounds.se.lng]
                        ], { padding: [20, 20] });
                        
                        createGridFromCorners();
                        triangulate();
                        redraw();
                    };
                    imageElement.src = reprojectedCanvas.toDataURL('image/png');
                    
                } catch (err) {
                    document.getElementById('reprojStatus').innerHTML = '‚ùå Erro: ' + err.message;
                    document.getElementById('reprojStatus').style.color = '#ff4444';
                    document.getElementById('btnReproject').disabled = false;
                }
            }, 50);
        }
        
        function geostatToPlateCarree(srcImg) {
            const quality = parseInt(document.getElementById('reprojQuality').value) || 600;
            const satLonDeg = parseFloat(document.getElementById('satLongitude').value);
            const satLon = satLonDeg * Math.PI / 180;
            
            // √Årea vis√≠vel do sat√©lite (aproximadamente 81¬∞ em cada dire√ß√£o)
            const visibleRange = 81 * Math.PI / 180; // em radianos
            
            // Limites da √°rea vis√≠vel
            const minLon = satLon - visibleRange;
            const maxLon = satLon + visibleRange;
            const minLat = -visibleRange;
            const maxLat = visibleRange;
            
            // Dimens√µes da imagem de sa√≠da (apenas √°rea vis√≠vel)
            const outWidth = quality;
            const outHeight = quality; // Quadrado para √°rea vis√≠vel
            
            // Criar canvas de sa√≠da
            const outCanvas = document.createElement('canvas');
            outCanvas.width = outWidth;
            outCanvas.height = outHeight;
            const outCtx = outCanvas.getContext('2d');
            
            // Criar canvas tempor√°rio para ler pixels da imagem fonte
            const srcCanvas = document.createElement('canvas');
            srcCanvas.width = srcImg.naturalWidth;
            srcCanvas.height = srcImg.naturalHeight;
            const srcCtx = srcCanvas.getContext('2d');
            srcCtx.drawImage(srcImg, 0, 0);
            
            const srcData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
            const outData = outCtx.createImageData(outWidth, outHeight);
            
            // Centro e raio do disco na imagem fonte
            const cx = srcCanvas.width / 2;
            const cy = srcCanvas.height / 2;
            const radius = Math.min(cx, cy) * 0.98; // Um pouco menor para evitar bordas
            
            // Para cada pixel na imagem de sa√≠da (Plate Carr√©e - apenas √°rea vis√≠vel)
            for (let y = 0; y < outHeight; y++) {
                for (let x = 0; x < outWidth; x++) {
                    // Converter posi√ß√£o para lat/lon (dentro da √°rea vis√≠vel)
                    const lon = minLon + (x / outWidth) * (maxLon - minLon);
                    const lat = maxLat - (y / outHeight) * (maxLat - minLat);
                    
                    // Diferen√ßa de longitude em rela√ß√£o ao sat√©lite
                    const lonDiff = lon - satLon;
                    
                    // Proje√ß√£o inversa: lat/lon ‚Üí posi√ß√£o no disco
                    // F√≥rmula simplificada para proje√ß√£o geoestacion√°ria
                    const cosLat = Math.cos(lat);
                    const sinLat = Math.sin(lat);
                    const cosLonDiff = Math.cos(lonDiff);
                    const sinLonDiff = Math.sin(lonDiff);
                    
                    // Verificar se o ponto est√° no lado vis√≠vel da Terra
                    const cosc = sinLat * 0 + cosLat * cosLonDiff;
                    if (cosc < 0.1) {
                        const idx = (y * outWidth + x) * 4;
                        outData.data[idx] = 0;
                        outData.data[idx + 1] = 0;
                        outData.data[idx + 2] = 0;
                        outData.data[idx + 3] = 0;
                        continue;
                    }
                    
                    // Coordenadas normalizadas no disco (-1 a 1)
                    const diskX = cosLat * sinLonDiff;
                    const diskY = -sinLat; // Y invertido
                    
                    // Converter para coordenadas de pixel na imagem fonte
                    const srcX = Math.round(cx + diskX * radius);
                    const srcY = Math.round(cy + diskY * radius);
                    
                    // Verificar limites
                    if (srcX < 0 || srcX >= srcCanvas.width || srcY < 0 || srcY >= srcCanvas.height) {
                        const idx = (y * outWidth + x) * 4;
                        outData.data[idx] = 0;
                        outData.data[idx + 1] = 0;
                        outData.data[idx + 2] = 0;
                        outData.data[idx + 3] = 0;
                        continue;
                    }
                    
                    // Copiar pixel
                    const srcIdx = (srcY * srcCanvas.width + srcX) * 4;
                    const dstIdx = (y * outWidth + x) * 4;
                    
                    outData.data[dstIdx] = srcData.data[srcIdx];
                    outData.data[dstIdx + 1] = srcData.data[srcIdx + 1];
                    outData.data[dstIdx + 2] = srcData.data[srcIdx + 2];
                    outData.data[dstIdx + 3] = srcData.data[srcIdx + 3];
                }
            }
            
            outCtx.putImageData(outData, 0, 0);
            return outCanvas;
        }

        function loadImage(src, name) {
            imageElement = new Image();
            imageElement.crossOrigin = 'anonymous';
            
            imageElement.onload = function() {
                imageLoaded = true;
                document.getElementById('imageStatus').innerHTML = `‚úÖ ${name} (${this.width}√ó${this.height})`;
                document.getElementById('imageStatus').style.color = '#00ff00';
                
                createGridFromCorners();
                triangulate();
                redraw();
            };
            
            imageElement.onerror = function() {
                document.getElementById('imageStatus').innerHTML = '‚ùå Erro ao carregar';
                document.getElementById('imageStatus').style.color = '#ff4444';
            };
            
            imageElement.src = src;
        }

        // ===== GRID DE PONTOS =====
        function setGrid(rows, cols) {
            gridRows = rows;
            gridCols = cols;
            // Atualizar os inputs customizados
            document.getElementById('customRows').value = rows;
            document.getElementById('customCols').value = cols;
            if (imageLoaded) {
                createGridFromCorners();
                triangulate();
                redraw();
            }
        }

        function applyCustomGrid() {
            const rows = parseInt(document.getElementById('customRows').value) || 4;
            const cols = parseInt(document.getElementById('customCols').value) || 4;
            
            // Validar limites
            const validRows = Math.max(2, Math.min(50, rows));
            const validCols = Math.max(2, Math.min(50, cols));
            
            // Atualizar inputs se foram corrigidos
            document.getElementById('customRows').value = validRows;
            document.getElementById('customCols').value = validCols;
            
            gridRows = validRows;
            gridCols = validCols;
            
            if (imageLoaded) {
                createGridFromCorners();
                triangulate();
                redraw();
            } else {
                alert('Carregue uma imagem primeiro!');
            }
        }

        function createGridFromCorners() {
            // Limpar pontos antigos
            controlPoints.forEach(p => { if (p.marker) map.removeLayer(p.marker); });
            controlPoints = [];
            pointIdCounter = 0;
            deletedTriangles.clear();

            // Interpolar posi√ß√µes baseado nos 4 cantos
            for (let r = 0; r < gridRows; r++) {
                for (let c = 0; c < gridCols; c++) {
                    // Fatores de interpola√ß√£o
                    const u = c / (gridCols - 1); // 0 a 1 (esquerda a direita)
                    const v = r / (gridRows - 1); // 0 a 1 (cima a baixo)
                    
                    // Interpola√ß√£o bilinear dos 4 cantos
                    const lat = (1-v) * ((1-u) * cornerBounds.nw.lat + u * cornerBounds.ne.lat) +
                                v * ((1-u) * cornerBounds.sw.lat + u * cornerBounds.se.lat);
                    
                    const lng = (1-v) * ((1-u) * cornerBounds.nw.lng + u * cornerBounds.ne.lng) +
                                v * ((1-u) * cornerBounds.sw.lng + u * cornerBounds.se.lng);
                    
                    // Posi√ß√£o na imagem (0-1)
                    const srcX = c / (gridCols - 1);
                    const srcY = r / (gridRows - 1);
                    
                    addControlPoint(srcX, srcY, lat, lng);
                }
            }
            
            document.getElementById('pointCount').textContent = controlPoints.length;
        }

        function addControlPoint(srcX, srcY, lat, lng) {
            pointIdCounter++;
            const id = pointIdCounter;
            
            const icon = L.divIcon({
                className: 'control-point',
                html: id,
                iconSize: [14, 14],
                iconAnchor: [7, 7]
            });
            
            const marker = L.marker([lat, lng], {
                icon: icon,
                draggable: true
            }).addTo(map);
            
            marker.on('drag dragend', function() {
                const ll = marker.getLatLng();
                const pt = controlPoints.find(p => p.id === id);
                if (pt) {
                    pt.lat = ll.lat;
                    pt.lng = ll.lng;
                }
                redraw();
            });
            
            controlPoints.push({ id, marker, srcX, srcY, lat, lng });
        }

        // ===== TRIANGULA√á√ÉO =====
        function triangulate() {
            if (controlPoints.length < 3) {
                triangles = [];
                return;
            }
            
            const coords = [];
            controlPoints.forEach(p => {
                const pt = map.latLngToContainerPoint([p.lat, p.lng]);
                coords.push(pt.x, pt.y);
            });
            
            try {
                const delaunay = new Delaunator(coords);
                triangles = Array.from(delaunay.triangles);
            } catch (e) {
                triangles = [];
            }
            
            document.getElementById('triangleCount').textContent = triangles.length / 3;
        }

        // ===== DESENHAR =====
        function redraw() {
            if (!ctx) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);
            
            updateSliderDisplays();
            
            if (!imageLoaded || !imageElement || controlPoints.length < 3) return;
            
            triangulate();
            
            const opacity = parseFloat(document.getElementById('opacity').value) / 100;
            ctx.globalAlpha = opacity;
            
            const imgW = imageElement.naturalWidth;
            const imgH = imageElement.naturalHeight;
            
            // Ajustes finos
            const scaleX = parseFloat(document.getElementById('scaleX').value);
            const scaleY = parseFloat(document.getElementById('scaleY').value);
            const rotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
            
            // Desenhar cada tri√¢ngulo
            for (let i = 0; i < triangles.length; i += 3) {
                const triIndex = i / 3;
                
                if (deletedTriangles.has(triIndex)) continue;
                
                const i0 = triangles[i];
                const i1 = triangles[i + 1];
                const i2 = triangles[i + 2];
                
                const p0 = controlPoints[i0];
                const p1 = controlPoints[i1];
                const p2 = controlPoints[i2];
                
                if (!p0 || !p1 || !p2) continue;
                
                // Posi√ß√µes na imagem
                const src0 = [p0.srcX * imgW, p0.srcY * imgH];
                const src1 = [p1.srcX * imgW, p1.srcY * imgH];
                const src2 = [p2.srcX * imgW, p2.srcY * imgH];
                
                // Posi√ß√µes na tela
                const dst0 = getTransformedPoint(p0.lat, p0.lng, scaleX, scaleY, rotation);
                const dst1 = getTransformedPoint(p1.lat, p1.lng, scaleX, scaleY, rotation);
                const dst2 = getTransformedPoint(p2.lat, p2.lng, scaleX, scaleY, rotation);
                
                drawTriangle(ctx, imageElement, src0, src1, src2, dst0, dst1, dst2);
            }
            
            if (deleteMode) {
                drawTriangleOutlines();
            }
        }

        function getTransformedPoint(lat, lng, scaleX, scaleY, rotation) {
            const pt = map.latLngToContainerPoint([lat, lng]);
            
            // Offset global (deslocamento da imagem toda)
            const offsetX = parseFloat(document.getElementById('offsetX').value) || 0;
            const offsetY = parseFloat(document.getElementById('offsetY').value) || 0;
            
            // Perspectiva (esticar/encolher topo e base separadamente)
            const topScale = parseFloat(document.getElementById('topScale').value) || 1;
            const bottomScale = parseFloat(document.getElementById('bottomScale').value) || 1;
            const topOffsetY = parseFloat(document.getElementById('topOffsetY').value) || 0;
            const bottomOffsetY = parseFloat(document.getElementById('bottomOffsetY').value) || 0;
            
            // Centro = centro dos 4 cantos
            const centerLat = (cornerBounds.nw.lat + cornerBounds.se.lat) / 2;
            const centerLng = (cornerBounds.nw.lng + cornerBounds.se.lng) / 2;
            const center = map.latLngToContainerPoint([centerLat, centerLng]);
            
            // Calcular a posi√ß√£o vertical relativa (0 = topo, 1 = base)
            const topPt = map.latLngToContainerPoint([cornerBounds.nw.lat, centerLng]);
            const bottomPt = map.latLngToContainerPoint([cornerBounds.sw.lat, centerLng]);
            const totalHeight = bottomPt.y - topPt.y;
            
            let verticalRatio = 0.5; // padr√£o no centro
            if (totalHeight > 0) {
                verticalRatio = (pt.y - topPt.y) / totalHeight;
                verticalRatio = Math.max(0, Math.min(1, verticalRatio));
            }
            
            // Calcular escala horizontal baseada na posi√ß√£o vertical (interpola√ß√£o linear)
            const perspectiveScaleX = topScale * (1 - verticalRatio) + bottomScale * verticalRatio;
            
            // Calcular offset Y baseado na posi√ß√£o vertical
            const perspectiveOffsetY = topOffsetY * (1 - verticalRatio) + bottomOffsetY * verticalRatio;
            
            let x = pt.x - center.x;
            let y = pt.y - center.y;
            
            // Aplicar escala de perspectiva (apenas horizontal, baseado na posi√ß√£o vertical)
            x *= perspectiveScaleX;
            
            // Escala global
            x *= scaleX;
            y *= scaleY;
            
            // Rota√ß√£o
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);
            const rx = x * cos - y * sin;
            const ry = x * sin + y * cos;
            
            // Aplicar offset global + offset de perspectiva AP√ìS escala e rota√ß√£o
            return [rx + center.x + offsetX, ry + center.y + offsetY + perspectiveOffsetY];
        }

        function drawTriangle(ctx, img, src0, src1, src2, dst0, dst1, dst2) {
            ctx.save();
            
            ctx.beginPath();
            ctx.moveTo(dst0[0], dst0[1]);
            ctx.lineTo(dst1[0], dst1[1]);
            ctx.lineTo(dst2[0], dst2[1]);
            ctx.closePath();
            ctx.clip();
            
            const denom = (src0[0] - src2[0]) * (src1[1] - src2[1]) - (src1[0] - src2[0]) * (src0[1] - src2[1]);
            if (Math.abs(denom) < 0.001) { ctx.restore(); return; }
            
            const a = ((dst0[0] - dst2[0]) * (src1[1] - src2[1]) - (dst1[0] - dst2[0]) * (src0[1] - src2[1])) / denom;
            const b = ((src0[0] - src2[0]) * (dst1[0] - dst2[0]) - (src1[0] - src2[0]) * (dst0[0] - dst2[0])) / denom;
            const c = dst0[0] - a * src0[0] - b * src0[1];
            const d = ((dst0[1] - dst2[1]) * (src1[1] - src2[1]) - (dst1[1] - dst2[1]) * (src0[1] - src2[1])) / denom;
            const e = ((src0[0] - src2[0]) * (dst1[1] - dst2[1]) - (src1[0] - src2[0]) * (dst0[1] - dst2[1])) / denom;
            const f = dst0[1] - d * src0[0] - e * src0[1];
            
            ctx.setTransform(a, d, b, e, c, f);
            ctx.drawImage(img, 0, 0);
            
            ctx.restore();
        }

        function drawTriangleOutlines() {
            const scaleX = parseFloat(document.getElementById('scaleX').value);
            const scaleY = parseFloat(document.getElementById('scaleY').value);
            const rotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
            
            for (let i = 0; i < triangles.length; i += 3) {
                const triIndex = i / 3;
                
                if (deletedTriangles.has(triIndex)) {
                    selCtx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                    selCtx.setLineDash([5, 5]);
                } else {
                    selCtx.strokeStyle = 'rgba(255, 0, 100, 0.6)';
                    selCtx.setLineDash([]);
                }
                selCtx.lineWidth = 2;
                
                const p0 = controlPoints[triangles[i]];
                const p1 = controlPoints[triangles[i + 1]];
                const p2 = controlPoints[triangles[i + 2]];
                
                if (!p0 || !p1 || !p2) continue;
                
                const dst0 = getTransformedPoint(p0.lat, p0.lng, scaleX, scaleY, rotation);
                const dst1 = getTransformedPoint(p1.lat, p1.lng, scaleX, scaleY, rotation);
                const dst2 = getTransformedPoint(p2.lat, p2.lng, scaleX, scaleY, rotation);
                
                selCtx.beginPath();
                selCtx.moveTo(dst0[0], dst0[1]);
                selCtx.lineTo(dst1[0], dst1[1]);
                selCtx.lineTo(dst2[0], dst2[1]);
                selCtx.closePath();
                selCtx.stroke();
            }
        }

        // ===== MODO DELETAR =====
        function toggleDeleteMode() {
            deleteMode = !deleteMode;
            const btn = document.getElementById('btnDeleteMode');
            const instr = document.getElementById('deleteInstructions');
            
            if (deleteMode) {
                btn.classList.add('active');
                btn.innerHTML = '‚úÇÔ∏è CLICANDO...';
                instr.style.display = 'block';
                selCanvas.style.pointerEvents = 'auto';
                document.getElementById('map').classList.add('delete-mode-active');
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '‚úÇÔ∏è Modo Deletar';
                instr.style.display = 'none';
                selCanvas.style.pointerEvents = 'none';
                selCanvas.style.cursor = 'default';
                document.getElementById('map').classList.remove('delete-mode-active');
            }
            
            redraw();
        }

        function clickOnTriangle(x, y) {
            const scaleX = parseFloat(document.getElementById('scaleX').value);
            const scaleY = parseFloat(document.getElementById('scaleY').value);
            const rotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
            
            for (let i = 0; i < triangles.length; i += 3) {
                const triIndex = i / 3;
                
                const p0 = controlPoints[triangles[i]];
                const p1 = controlPoints[triangles[i + 1]];
                const p2 = controlPoints[triangles[i + 2]];
                
                if (!p0 || !p1 || !p2) continue;
                
                const dst0 = getTransformedPoint(p0.lat, p0.lng, scaleX, scaleY, rotation);
                const dst1 = getTransformedPoint(p1.lat, p1.lng, scaleX, scaleY, rotation);
                const dst2 = getTransformedPoint(p2.lat, p2.lng, scaleX, scaleY, rotation);
                
                if (pointInTriangle(x, y, dst0, dst1, dst2)) {
                    if (deletedTriangles.has(triIndex)) {
                        deletedTriangles.delete(triIndex);
                    } else {
                        deletedTriangles.add(triIndex);
                    }
                    updateDeletedList();
                    redraw();
                    return;
                }
            }
        }

        function pointInTriangle(px, py, v0, v1, v2) {
            const area = 0.5 * (-v1[1] * v2[0] + v0[1] * (-v1[0] + v2[0]) + v0[0] * (v1[1] - v2[1]) + v1[0] * v2[1]);
            const s = 1 / (2 * area) * (v0[1] * v2[0] - v0[0] * v2[1] + (v2[1] - v0[1]) * px + (v0[0] - v2[0]) * py);
            const t = 1 / (2 * area) * (v0[0] * v1[1] - v0[1] * v1[0] + (v0[1] - v1[1]) * px + (v1[0] - v0[0]) * py);
            return s >= 0 && t >= 0 && (1 - s - t) >= 0;
        }

        function updateDeletedList() {
            const list = document.getElementById('deletedList');
            const items = document.getElementById('deletedItems');
            
            if (deletedTriangles.size === 0) {
                list.style.display = 'none';
                return;
            }
            
            list.style.display = 'block';
            let html = '';
            deletedTriangles.forEach(idx => {
                html += `<div class="triangle-item">
                    Tri√¢ngulo #${idx + 1}
                    <button onclick="restoreTriangle(${idx})">‚Ü©Ô∏è</button>
                </div>`;
            });
            items.innerHTML = html;
        }

        function restoreTriangle(idx) {
            deletedTriangles.delete(idx);
            updateDeletedList();
            redraw();
        }

        function restoreAllTriangles() {
            deletedTriangles.clear();
            updateDeletedList();
            redraw();
        }

        // ===== AJUSTES =====
        function moveImage(dx, dy) {
            const step = parseInt(document.getElementById('moveStep').value) || 10;
            const offsetXEl = document.getElementById('offsetX');
            const offsetYEl = document.getElementById('offsetY');
            
            let newX = parseInt(offsetXEl.value) + (dx * step);
            let newY = parseInt(offsetYEl.value) + (dy * step);
            
            // Limitar aos valores do slider
            newX = Math.max(-500, Math.min(500, newX));
            newY = Math.max(-500, Math.min(500, newY));
            
            offsetXEl.value = newX;
            offsetYEl.value = newY;
            
            redraw();
        }
        
        function resetOffset() {
            document.getElementById('offsetX').value = 0;
            document.getElementById('offsetY').value = 0;
            redraw();
        }
        
        function resetPerspective() {
            document.getElementById('topScale').value = 1;
            document.getElementById('bottomScale').value = 1;
            document.getElementById('topOffsetY').value = 0;
            document.getElementById('bottomOffsetY').value = 0;
            redraw();
        }
        
        function resetFineAdjust() {
            document.getElementById('rotation').value = 0;
            document.getElementById('scaleX').value = 1;
            document.getElementById('scaleY').value = 1;
            document.getElementById('offsetX').value = 0;
            document.getElementById('offsetY').value = 0;
            resetPerspective();
        }

        function updateSliderDisplays() {
            document.getElementById('scaleXVal').textContent = parseFloat(document.getElementById('scaleX').value).toFixed(2);
            document.getElementById('scaleYVal').textContent = parseFloat(document.getElementById('scaleY').value).toFixed(2);
            document.getElementById('rotationVal').textContent = parseFloat(document.getElementById('rotation').value).toFixed(1) + '¬∞';
            document.getElementById('opacityVal').textContent = document.getElementById('opacity').value + '%';
            document.getElementById('offsetXVal').textContent = document.getElementById('offsetX').value + 'px';
            document.getElementById('offsetYVal').textContent = document.getElementById('offsetY').value + 'px';
            document.getElementById('topScaleVal').textContent = parseFloat(document.getElementById('topScale').value).toFixed(2);
            document.getElementById('bottomScaleVal').textContent = parseFloat(document.getElementById('bottomScale').value).toFixed(2);
            document.getElementById('topOffsetYVal').textContent = document.getElementById('topOffsetY').value + 'px';
            document.getElementById('bottomOffsetYVal').textContent = document.getElementById('bottomOffsetY').value + 'px';
        }

        // ===== EXPORT/IMPORT =====
        function exportConfig() {
            const data = {
                timestamp: new Date().toISOString(),
                version: 'v7',
                corners: cornerBounds,
                grid: { rows: gridRows, cols: gridCols },
                points: controlPoints.map(p => ({ srcX: p.srcX, srcY: p.srcY, lat: p.lat, lng: p.lng })),
                deletedTriangles: Array.from(deletedTriangles),
                adjustments: {
                    scaleX: document.getElementById('scaleX').value,
                    scaleY: document.getElementById('scaleY').value,
                    rotation: document.getElementById('rotation').value,
                    opacity: document.getElementById('opacity').value,
                    offsetX: document.getElementById('offsetX').value,
                    offsetY: document.getElementById('offsetY').value,
                    topScale: document.getElementById('topScale').value,
                    bottomScale: document.getElementById('bottomScale').value,
                    topOffsetY: document.getElementById('topOffsetY').value,
                    bottomOffsetY: document.getElementById('bottomOffsetY').value
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `alignment_v7_${new Date().toISOString().slice(0,16).replace(/:/g,'-')}.json`;
            a.click();
        }

        function importConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const reader = new FileReader();
                reader.onload = function(ev) {
                    try {
                        const data = JSON.parse(ev.target.result);
                        applyConfig(data);
                    } catch (err) {
                        alert('Erro ao importar: ' + err.message);
                    }
                };
                reader.readAsText(e.target.files[0]);
            };
            input.click();
        }

        function applyConfig(data) {
            // Aplicar cantos
            if (data.corners) {
                cornerBounds = data.corners;
                cornerMarkers.nw.setLatLng([data.corners.nw.lat, data.corners.nw.lng]);
                cornerMarkers.ne.setLatLng([data.corners.ne.lat, data.corners.ne.lng]);
                cornerMarkers.sw.setLatLng([data.corners.sw.lat, data.corners.sw.lng]);
                cornerMarkers.se.setLatLng([data.corners.se.lat, data.corners.se.lng]);
                updateCornerDisplay();
                updateBoundsRectangle();
            }
            
            // Aplicar ajustes
            if (data.adjustments) {
                Object.keys(data.adjustments).forEach(key => {
                    const el = document.getElementById(key);
                    if (el) el.value = data.adjustments[key];
                });
            }
            
            // Aplicar grade
            if (data.grid) {
                gridRows = data.grid.rows;
                gridCols = data.grid.cols;
            }
            
            // Aplicar pontos individuais
            if (data.points && imageLoaded) {
                controlPoints.forEach(p => { if (p.marker) map.removeLayer(p.marker); });
                controlPoints = [];
                pointIdCounter = 0;
                data.points.forEach(p => addControlPoint(p.srcX, p.srcY, p.lat, p.lng));
            }
            
            // Aplicar tri√¢ngulos deletados
            if (data.deletedTriangles) {
                deletedTriangles = new Set(data.deletedTriangles);
            }
            
            triangulate();
            updateDeletedList();
            redraw();
        }
    </script>
</body>
</html>
