
<!DOCTYPE html>
<html>
<head>
    <title>Monitor de Vento - Tempo Real - Deepwater Aquila</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; padding: 0; 
            background: #0a0a0a; 
            font-family: 'Consolas', 'Monaco', monospace; 
            color: #e0e0e0; 
        }
        
        /* Layout Principal */
        .container {
            display: flex;
            height: 100vh;
        }
        
        /* Painel Lateral */
        .sidebar {
            width: 380px;
            background: #111;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 15px;
        }
        
        /* Mapa */
        #map { 
            flex: 1;
            height: 100vh;
        }
        
        /* Estilos do Painel */
        h1 {
            font-size: 16px;
            color: #00ffcc;
            border-bottom: 2px solid #00ffcc;
            padding-bottom: 10px;
            margin: 0 0 15px 0;
        }
        
        h2 {
            font-size: 13px;
            color: #ff9900;
            margin: 20px 0 10px 0;
            text-transform: uppercase;
        }
        
        .section {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .section-title {
            font-size: 12px;
            color: #00ffcc;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Se√ß√µes Colaps√°veis */
        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 8px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            user-select: none;
        }
        
        .collapsible-header:hover {
            color: #00ffcc;
        }
        
        .collapsible-header h2 {
            margin: 0;
            font-size: 13px;
            color: #ff9900;
            text-transform: uppercase;
        }
        
        .collapsible-arrow {
            font-size: 12px;
            transition: transform 0.3s;
            color: #888;
        }
        
        .collapsible-header.collapsed .collapsible-arrow {
            transform: rotate(-90deg);
        }
        
        .collapsible-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s;
            opacity: 1;
        }
        
        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .status-indicator.active { background: #00ff00; }
        .status-indicator.loading { background: #ffff00; animation: pulse 1s infinite; }
        .status-indicator.error { background: #ff0000; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Anima√ß√£o DMW - movimento suave ondulante */
        @keyframes dmw-wave {
            0%, 100% { transform: translateY(0px) scale(1); }
            25% { transform: translateY(-3px) scale(1.05); }
            50% { transform: translateY(0px) scale(1); }
            75% { transform: translateY(3px) scale(0.95); }
        }
        
        .dmw-wind-arrow {
            animation: dmw-wave 2.5s ease-in-out infinite;
        }
        
        /* Inputs */
        label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
        }
        
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 3px;
            font-family: inherit;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        input:focus {
            outline: none;
            border-color: #00ffcc;
        }
        
        button {
            padding: 8px 16px;
            background: #00ffcc;
            color: #000;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        button:hover {
            background: #00ddaa;
        }
        
        button.secondary {
            background: #444;
            color: #fff;
        }
        
        button.secondary:hover {
            background: #555;
        }
        
        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        /* Toggle Button para Sat√©lite */
        .toggle-btn {
            flex: 1;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #555;
            color: #888;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        
        .toggle-btn:hover {
            background: #444;
            color: #ccc;
        }
        
        .toggle-btn.active {
            background: #00cc99;
            border-color: #00ffcc;
            color: #000;
        }
        
        /* Log de Status */
        .log-area {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-size: 11px;
            border-radius: 3px;
        }
        
        .log-entry {
            margin-bottom: 4px;
            padding-left: 10px;
            border-left: 2px solid #444;
        }
        
        .log-entry.info { border-left-color: #00ffcc; }
        .log-entry.success { border-left-color: #00ff00; }
        .log-entry.error { border-left-color: #ff0000; }
        .log-entry.warning { border-left-color: #ffff00; }
        
        /* Dados de Vento */
        .wind-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .stat-box {
            background: #222;
            padding: 10px;
            text-align: center;
            border-radius: 3px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #00ffcc;
        }
        
        .stat-label {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        /* Legenda */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        /* Checkbox customizado */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .checkbox-item input {
            width: 16px;
            height: 16px;
        }
        
        /* Fonte info */
        .source-info {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }
        
        /* Estilos para setas de vento DMW - com anima√ß√£o ondulante */
        .dmw-wind-arrow {
            background: transparent !important;
            border: none !important;
            /* Anima√ß√£o aplicada via keyframes acima */
        }
        
        .source-info a {
            color: #00aaff;
        }
        
        /* Forecast Tabs - Tabela Horizontal GIGANTE para visualiza√ß√£o de 10m */
        .forecast-tabs-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #000;
            border-bottom: 4px solid #00ffcc;
            padding: 5px 5px 10px 5px;
            z-index: 2000;
        }
        
        /* Linha 1: T√≠tulo + Per√≠odo */
        .forecast-row-1 {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 0 5px;
        }
        
        .forecast-title {
            color: #00ffcc;
            font-size: 18px;
            font-weight: bold;
            white-space: nowrap;
        }
        
        .forecast-period-tabs {
            display: flex;
            gap: 8px;
        }
        
        .forecast-period-btn {
            padding: 8px 20px;
            background: #333;
            border: 2px solid #555;
            color: #888;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.2s;
        }
        
        .forecast-period-btn:hover {
            background: #444;
            color: #ccc;
        }
        
        .forecast-period-btn.active {
            background: #00cc99;
            border-color: #00ffcc;
            color: #000;
        }
        
        .forecast-status {
            font-size: 14px;
            color: #666;
            white-space: nowrap;
        }
        
        /* Tabela de Forecast - FULL WIDTH */
        .forecast-grid-container {
            overflow-x: auto;
            scrollbar-width: thin;
            scrollbar-color: #444 #1a1a1a;
            width: 100%;
        }
        
        .forecast-grid-container::-webkit-scrollbar {
            height: 8px;
        }
        
        .forecast-grid-container::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .forecast-grid-container::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        
        .forecast-grid {
            display: grid;
            grid-template-rows: auto auto auto auto;
            gap: 2px;
            width: 100%;
        }
        
        .forecast-row {
            display: flex;
            align-items: center;
            width: 100%;
        }
        
        .forecast-row-label {
            width: 90px;
            flex-shrink: 0;
            font-size: 16px;
            color: #ffcc00;
            padding-right: 10px;
            text-align: right;
            font-weight: bold;
        }
        
        .forecast-row-data {
            display: flex;
            flex: 1;
            gap: 2px;
        }
        
        .forecast-cell {
            flex: 1;
            min-width: 40px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            border-radius: 3px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .forecast-cell:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .forecast-cell.selected {
            outline: 3px solid #fff;
            outline-offset: -2px;
        }
        
        /* C√©lulas de Hor√°rio */
        .forecast-cell.hour {
            background: #2a2a3a;
            color: #88ccff;
            font-weight: bold;
            font-size: 18px;
        }
        
        /* C√©lulas de Vento com cores por intensidade */
        /* Escala: Verde < 20kn, Amarelo 25-35kn, Vermelho > 35kn */
        .forecast-cell.wind-calm { background: #006600; color: #fff; }     /* 0-10 kn: Verde escuro */
        .forecast-cell.wind-light { background: #00aa00; color: #fff; }    /* 10-15 kn: Verde m√©dio */
        .forecast-cell.wind-moderate { background: #00dd00; color: #000; } /* 15-20 kn: Verde claro */
        .forecast-cell.wind-fresh { background: #aadd00; color: #000; }    /* 20-25 kn: Verde-amarelo */
        .forecast-cell.wind-strong { background: #ffdd00; color: #000; }   /* 25-30 kn: Amarelo */
        .forecast-cell.wind-gale { background: #ff9900; color: #000; }     /* 30-35 kn: Laranja */
        .forecast-cell.wind-storm { background: #ff3300; color: #fff; }    /* 35-45 kn: Vermelho */
        .forecast-cell.wind-violent { background: #cc00cc; color: #fff; }  /* > 45 kn: Roxo */
        
        /* C√©lulas de Dire√ß√£o */
        .forecast-cell.direction {
            background: #1a2a4a;
            color: #88ccff;
            font-size: 26px;
        }
        
        /* Info do ponto selecionado */
        .forecast-selected-info {
            display: none;
            align-items: center;
            gap: 25px;
            margin-top: 8px;
            padding: 8px 15px;
            background: rgba(0,100,100,0.3);
            border-radius: 4px;
            font-size: 18px;
        }
        
        .forecast-selected-info.visible {
            display: flex;
        }
        
        .forecast-selected-info .item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .forecast-selected-info .item .val {
            color: #00ffcc;
            font-weight: bold;
            font-size: 22px;
        }
        
        .forecast-weights {
            margin-left: auto;
            display: flex;
            gap: 15px;
            font-size: 14px;
        }
        
        /* Bot√£o toggle info */
        .forecast-toggle-info {
            background: transparent;
            border: 2px solid #444;
            color: #888;
            padding: 6px 15px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 15px;
        }
        
        .forecast-toggle-info:hover {
            background: #333;
            color: #ccc;
        }
        
        .forecast-toggle-info.active {
            background: #00666688;
            border-color: #00ffcc;
            color: #00ffcc;
        }
        
        /* Ajustar layout para dar espa√ßo para o header GRANDE */
        .sidebar {
            margin-top: 210px;
            height: calc(100vh - 210px);
        }
        
        #map {
            margin-top: 210px;
            height: calc(100vh - 210px) !important;
        }
        
        /* Canvas Layer para gradiente L2 */
        .leaflet-canvas-layer {
            position: absolute;
            pointer-events: none;
            z-index: 250;
        }
        
        /* Info Icon com Tooltip */
        .input-with-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .input-with-info input {
            flex: 1;
            margin-bottom: 0;
        }
        
        .info-icon {
            width: 20px;
            height: 20px;
            background: #0088ff;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            position: relative;
            flex-shrink: 0;
        }
        
        .info-icon:hover {
            background: #00aaff;
        }
        
        .info-tooltip {
            display: none;
            position: absolute;
            left: 30px;
            top: -10px;
            background: #222;
            border: 1px solid #00aaff;
            border-radius: 6px;
            padding: 12px;
            width: 280px;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        .info-icon:hover .info-tooltip {
            display: block;
        }
        
        .info-tooltip h4 {
            color: #00ffcc;
            margin: 0 0 8px 0;
            font-size: 12px;
        }
        
        .info-tooltip p {
            color: #ccc;
            font-size: 11px;
            margin: 6px 0;
            line-height: 1.4;
        }
        
        .info-tooltip ol {
            color: #aaa;
            font-size: 11px;
            margin: 8px 0;
            padding-left: 16px;
            line-height: 1.6;
        }
        
        .info-tooltip a {
            color: #00aaff;
            text-decoration: underline;
        }
        
        .info-tooltip .highlight {
            background: #333;
            padding: 4px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #ffcc00;
        }
    </style>
</head>
<body>

<!-- ABA DE PREVIS√ÉO NO TOPO - FULL WIDTH -->
<div class="forecast-tabs-container" id="forecast-container">
    <!-- LINHA 1: T√≠tulo + Status -->
    <div class="forecast-row-1">
        <div class="forecast-title">üåä PREVIS√ÉO DE VENTO</div>
        <div class="forecast-status" id="forecast-status">‚è∞ 15min</div>
        <button class="forecast-toggle-info" id="forecast-toggle-btn" onclick="toggleForecastInfo()">‚ñº Detalhes</button>
    </div>
    
    <!-- TABELA DE FORECAST -->
    <div class="forecast-grid-container">
        <div class="forecast-grid" id="forecast-grid">
            <!-- Linha de Hor√°rios -->
            <div class="forecast-row">
                <div class="forecast-row-label">Hora</div>
                <div class="forecast-row-data" id="forecast-hours"></div>
            </div>
            <!-- Linha de Velocidade -->
            <div class="forecast-row">
                <div class="forecast-row-label">üí® Vento</div>
                <div class="forecast-row-data" id="forecast-winds"></div>
            </div>
            <!-- Linha de Rajada -->
            <div class="forecast-row">
                <div class="forecast-row-label">‚ö° Rajada</div>
                <div class="forecast-row-data" id="forecast-gusts"></div>
            </div>
            <!-- Linha de Dire√ß√£o -->
            <div class="forecast-row">
                <div class="forecast-row-label">üß≠ Dire√ß√£o</div>
                <div class="forecast-row-data" id="forecast-dirs"></div>
            </div>
        </div>
    </div>
    
    <!-- Info do Ponto Selecionado -->
    <div class="forecast-selected-info" id="forecast-selected-info">
        <div class="item">üìÖ <span class="val" id="forecast-datetime">--</span></div>
        <div class="item">üí® <span class="val" id="forecast-speed">--</span> kn</div>
        <div class="item">‚ö° <span class="val" id="forecast-gust">--</span> kn</div>
        <div class="item">üß≠ <span class="val" id="forecast-dir">--</span>¬∞</div>
    </div>
</div>

<div class="container">
    <!-- PAINEL LATERAL -->
    <div class="sidebar">
        
        <!-- SELETOR DE PER√çODO -->
        <div class="section" style="padding:8px;">
            <div style="display:flex; gap:5px;">
                <button class="forecast-period-btn active" onclick="selectForecastPeriod(24)" style="flex:1;">24h</button>
                <button class="forecast-period-btn" onclick="selectForecastPeriod(48)" style="flex:1;">48h</button>
                <button class="forecast-period-btn" onclick="selectForecastPeriod(72)" style="flex:1;">72h</button>
            </div>
        </div>
        
        <!-- POSI√á√ÉO DO NAVIO -->
        <div class="section">
            <div class="section-title">
                <span class="status-indicator active"></span>
                POSI√á√ÉO: Deepwater Aquila
            </div>
            <div class="wind-stats">
                <div class="stat-box">
                    <div class="stat-value">-22.5¬∞</div>
                    <div class="stat-label">LATITUDE</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">-40.5¬∞</div>
                    <div class="stat-label">LONGITUDE</div>
                </div>
            </div>
        </div>
        
        <!-- ESTAT√çSTICAS DE VENTO (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üìä DADOS DE VENTO</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section">
                <!-- M√©dia Multi-Modelo -->
                <div style="background:#1a2a1a; border:1px solid #00aa00; border-radius:4px; padding:10px; margin-bottom:10px;">
                    <div style="font-size:10px; color:#00ff00; margin-bottom:5px;">üåç VENTO ATUAL</div>
                    <div style="display:flex; gap:10px; align-items:center;">
                        <div style="text-align:center;">
                            <div style="font-size:24px; font-weight:bold; color:#00ffcc;" id="avg-model-speed">--</div>
                            <div style="font-size:9px; color:#888;">Velocidade (kn)</div>
                        </div>
                        <div style="text-align:center;">
                            <div style="font-size:24px; font-weight:bold; color:#00ffcc;" id="avg-model-dir">--</div>
                            <div style="font-size:9px; color:#888;">Dire√ß√£o (¬∞)</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- FONTES DE DADOS (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üì° FONTES DE DADOS</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #666;">
                <div class="section-title">
                    <span class="status-indicator" id="openmeteo-status"></span>
                    OPEN-METEO (Modelo)
                </div>
                <p class="source-info">‚úÖ GRATUITO - Atualiza 15 min</p>
                <button onclick="fetchOpenMeteoData()">üîÑ Atualizar</button>
                <button class="secondary" onclick="clearOpenMeteoData()">üóëÔ∏è Limpar</button>
            </div>
        </div>
        
        <!-- Sat√©lite (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üõ∞Ô∏è SAT√âLITE</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #00ff00;">
                <div class="section-title">
                    <span class="status-indicator" id="satellite-status"></span>
                    <span id="satellite-name">GOES-19</span>
                </div>
                
                <div style="display:flex; gap:5px; margin-bottom:8px;">
                    <button id="btn-goes19" class="toggle-btn active" onclick="selectSatellite('goes19')" style="flex:1;">GOES-19</button>
                    <button id="btn-goes16" class="toggle-btn" onclick="selectSatellite('goes16')" style="flex:1;">GOES-16</button>
                </div>
                
                <select id="satellite-product" style="width:100%; margin-bottom:6px; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:3px; font-size:11px;">
                    <option value="GEOCOLOR" selected>üåç GeoColor</option>
                    <option value="13">üå°Ô∏è IR (Band 13)</option>
                    <option value="08">üíß Vapor d'√Ågua</option>
                    <option value="AirMass">üåÄ Air Mass</option>
                </select>
                
                <select id="satellite-quality" style="width:100%; margin-bottom:6px; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:3px; font-size:11px;">
                    <option value="low">R√°pida</option>
                    <option value="medium" selected>M√©dia</option>
                    <option value="high">Alta</option>
                </select>
                
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                    <span style="font-size:10px;">Opacidade:</span>
                    <input type="range" id="satellite-opacity" min="0" max="100" value="75" style="flex:1;" oninput="updateSatelliteOpacity(this.value)">
                    <span id="opacity-value" style="font-size:10px;">75%</span>
                </div>
                
                <div style="display:flex; gap:5px; margin-bottom:6px;">
                    <button id="btn-autoextract-on" class="toggle-btn active" onclick="toggleAutoExtract(true)" style="flex:1; font-size:10px;">Auto ‚úÖ</button>
                    <button id="btn-autoextract-off" class="toggle-btn" onclick="toggleAutoExtract(false)" style="flex:1; font-size:10px;">Auto ‚ùå</button>
                </div>
                
                <div style="display:flex; gap:5px;">
                    <button onclick="loadSatelliteWithReprojection()" style="flex:1;">üåç CARREGAR</button>
                    <button class="secondary" onclick="toggleSatelliteLayer()">üëÅÔ∏è</button>
                </div>
                
                <div id="satellite-progress" style="display:none; margin-top:8px;">
                    <div style="background:#333; border-radius:3px; height:4px; overflow:hidden;">
                        <div id="satellite-progress-bar" style="width:0%; height:100%; background:#00d4ff;"></div>
                    </div>
                    <div id="satellite-progress-text" style="font-size:9px; color:#888; margin-top:2px;">0%</div>
                </div>
                <div id="satellite-info" style="margin-top:6px; font-size:9px; color:#888;"></div>
            </div>
        </div>
        
        <!-- VENTOS DMW (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üå¨Ô∏è VENTOS DMW</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #ff9900;">
                <div class="section-title">
                    <span class="status-indicator" id="dmw-status"></span>
                    Derived Motion Winds
                </div>
                
                <div style="display:flex; gap:5px; margin-bottom:8px;">
                    <button id="btn-dmw-on" class="toggle-btn" onclick="toggleDMW(true)" style="flex:1;">‚úÖ ON</button>
                    <button id="btn-dmw-off" class="toggle-btn active" onclick="toggleDMW(false)" style="flex:1;">‚ùå OFF</button>
                </div>
                
                <select id="dmw-level" style="width:100%; margin-bottom:6px; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:3px; font-size:11px;" onchange="loadDMWWinds()">
                    <option value="low" selected>Baixo (&lt;3km)</option>
                    <option value="mid">M√©dio (3-7km)</option>
                    <option value="high">Alto (&gt;7km)</option>
                    <option value="all">Todos</option>
                </select>
                
                <button onclick="loadDMWWinds()" style="width:100%; margin-bottom:6px;">üîÑ ATUALIZAR</button>
                
                <div id="dmw-info" style="font-size:9px; color:#888;">üìÖ Aguardando...</div>
                <div id="dmw-next-update" style="font-size:9px; color:#ff9900; display:none;">‚è∞ --:05</div>
            </div>
        </div>
        
        <!-- PRODUTOS L2 (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üìä PRODUTOS L2</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="section" style="border-left: 3px solid #00d4ff;">
                <div class="section-title">
                    <span class="status-indicator" id="l2-status"></span>
                    CAPE, LI, TPW, Nuvens
                </div>
                
                <div style="display:flex; gap:5px; margin-bottom:8px;">
                    <button id="btn-l2-on" class="toggle-btn" onclick="toggleL2(true)" style="flex:1;">‚úÖ ON</button>
                    <button id="btn-l2-off" class="toggle-btn active" onclick="toggleL2(false)" style="flex:1;">‚ùå OFF</button>
                </div>
                
                <!-- Modo de visualiza√ß√£o: √Årea ou Marcadores -->
                <div style="display:flex; gap:5px; margin-bottom:8px;">
                    <button id="btn-l2-area" class="toggle-btn active" onclick="toggleL2DisplayMode('area')" style="flex:1; font-size:10px;">üé® √Årea</button>
                    <button id="btn-l2-markers" class="toggle-btn" onclick="toggleL2DisplayMode('markers')" style="flex:1; font-size:10px;">‚≠ï Pontos</button>
                </div>
                
                <select id="l2-variable" style="width:100%; margin-bottom:6px; padding:5px; background:#222; color:#fff; border:1px solid #444; border-radius:3px; font-size:11px;" onchange="updateL2Display(); createL2Legend(this.value);">
                    <option value="CAPE" selected>‚ö° CAPE</option>
                    <option value="LI">üå°Ô∏è LI</option>
                    <option value="TPW">üíß TPW</option>
                    <option value="HT">‚òÅÔ∏è Altura</option>
                    <option value="Phase">üßä Fase</option>
                </select>
                
                <!-- Controle de Opacidade -->
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                    <label style="font-size:10px; color:#888; width:60px;">Opacidade:</label>
                    <input type="range" id="l2-opacity" min="10" max="100" value="70" 
                           style="flex:1; height:4px; cursor:pointer;"
                           oninput="updateL2Opacity(this.value)">
                    <span id="l2-opacity-value" style="font-size:10px; color:#00d4ff; width:35px;">70%</span>
                </div>
                
                <button onclick="loadL2Data()" style="width:100%; margin-bottom:6px;">üîÑ CARREGAR</button>
                
                <div id="l2-info" style="font-size:9px; color:#888;">üìÖ Aguardando...</div>
                
                <div id="l2-ship-data" style="display:none; background:#0a1a2a; padding:8px; border-radius:4px; margin-top:6px;">
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:3px; font-size:9px;">
                        <div>‚ö° <span id="l2-ship-cape" style="color:#ffcc00;">--</span></div>
                        <div>üå°Ô∏è <span id="l2-ship-li" style="color:#00ff88;">--</span></div>
                        <div>üíß <span id="l2-ship-tpw" style="color:#00ccff;">--</span></div>
                        <div>‚òÅÔ∏è <span id="l2-ship-ht" style="color:#ff88ff;">--</span></div>
                    </div>
                </div>
            </div>
        </div>
        <div id="l2-legend-cape" style="display:none;"></div>
        
        <!-- LOG (Colaps√°vel) -->
        <div class="collapsible-header collapsed" onclick="toggleCollapsible(this)">
            <h2>üìã LOG</h2>
            <span class="collapsible-arrow">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed">
            <div class="log-area" id="log-area" style="height:100px;">
                <div class="log-entry info">Sistema iniciado...</div>
            </div>
            <!-- A√ß√µes -->
            <div style="margin-top: 10px; display:flex; gap:5px;">
                <button onclick="fetchAllSources()" style="flex:1;">üîÑ ATUALIZAR</button>
                <button class="secondary" onclick="clearData()">üóëÔ∏è</button>
            </div>
        </div>
        
    </div>
    
    <!-- MAPA -->
    <div id="map"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
    // =========================================================================
    // CONFIGURA√á√ÉO
    // =========================================================================
    // Raio para visualiza√ß√£o do mapa (c√≠rculo visual)
    const RAIO_VISUAL_NM = 100;  // Raio do c√≠rculo visual no mapa
    const RAIO_VISUAL_GRAUS = RAIO_VISUAL_NM / 60;
    
    // Raio para busca de dados Open-Meteo (igual ao visual para cobrir todo c√≠rculo)
    const RAIO_NM = 100;  // Raio em milhas n√°uticas para busca de dados
    const RAIO_GRAUS = RAIO_NM / 60;  // 1 grau = 60 NM
    
    // IMPORTANTE: Idade m√°xima dos dados em MINUTOS
    // Dados com mais de 60 min ser√£o descartados
    const MAX_DATA_AGE_MINUTES = 60;
    
    const CONFIG = {
        shipLat: -22.5,
        shipLon: -40.5,
        latMin: -22.5 - RAIO_GRAUS,
        latMax: -22.5 + RAIO_GRAUS,
        lonMin: -40.5 - RAIO_GRAUS,
        lonMax: -40.5 + RAIO_GRAUS,
        shipName: "Deepwater Aquila"
    };
    
    // Bounds da imagem de sat√©lite reprojetada (√°rea de interesse)
    // IMPORTANTE: Definir aqui para ser usada por loadDMWWinds antes de ser redefinida abaixo
    const REPROJECTION_BOUNDS = {
        north: 0,
        south: -30,
        west: -60,
        east: -30
    };
    
    let map;
    let windDataPoints = [];  // Armazena todos os dados de vento
    let windLayerGroup;
    let gridLayer;
    
    // =========================================================================
    // INICIALIZA√á√ÉO DO MAPA
    // =========================================================================
    function initMap() {
        map = L.map('map', {
            center: [CONFIG.shipLat, CONFIG.shipLon],
            zoom: 7,
            zoomControl: false
        });

        L.control.zoom({ position: 'topright' }).addTo(map);
        L.control.scale({ position: 'bottomright', imperial: false }).addTo(map);

        // Mapa Base Escuro
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19
        }).addTo(map);
        
        // Grupos de camadas
        windLayerGroup = L.layerGroup().addTo(map);
        gridLayer = L.layerGroup();
        
        log('info', 'üìç Adicionando √≠cone do navio...');

        // √çcone do Navio
        const shipIcon = L.divIcon({
            className: 'ship-icon',
            html: `<svg viewBox="0 0 24 24" width="50" height="50">
                <circle cx="12" cy="12" r="10" fill="rgba(0,255,204,0.3)" stroke="#00ffcc" stroke-width="2"/>
                <circle cx="12" cy="12" r="4" fill="#00ffcc"/>
            </svg>`,
            iconSize: [50, 50],
            iconAnchor: [25, 25]
        });
        L.marker([CONFIG.shipLat, CONFIG.shipLon], { icon: shipIcon })
            .bindPopup(`<b>${CONFIG.shipName}</b><br>Lat: ${CONFIG.shipLat}<br>Lon: ${CONFIG.shipLon}`)
            .addTo(map);
        
        // √Årea de interesse (C√çRCULO VISUAL - 100 NM)
        L.circle([CONFIG.shipLat, CONFIG.shipLon], {
            radius: RAIO_VISUAL_NM * 1852,  // Converter NM para metros
            color: "#00ffcc",
            weight: 1,
            fillOpacity: 0.05,
            dashArray: '5, 5'
        }).addTo(map);
        
        log('info', 'üó∫Ô∏è Mapa base carregado');
        
        // Criar grade
        createGrid();
        
        // Carregar credenciais salvas
        loadSavedCredentials();
        
        log('success', '‚úÖ Mapa inicializado');
        log('info', `üìè √Årea visual: ${RAIO_VISUAL_NM} NM | Grid dados: ${RAIO_NM} NM`);
        
        // Carregar sat√©lite primeiro (500ms)
        log('info', 'üõ∞Ô∏è Iniciando carregamento de sat√©lite...');
        setTimeout(() => loadSatelliteLayer(), 500);
        
        // Buscar dados Open-Meteo (1 segundo)
        log('info', 'üå¨Ô∏è Iniciando busca de dados de vento...');
        setTimeout(() => fetchOpenMeteoData(), 1500);
        
        // Atualiza√ß√£o autom√°tica do Open-Meteo a cada 15 minutos
        setInterval(() => {
            log('info', '‚è∞ Atualiza√ß√£o autom√°tica (15 min)...');
            fetchOpenMeteoData();
        }, 15 * 60 * 1000);  // 15 minutos
        
        // Verifica√ß√£o autom√°tica de nova imagem de sat√©lite a cada 5 minutos
        setInterval(async () => {
            if (!isLoadingSatellite && satelliteEnabled && autoExtractEnabled) {
                const needsUpdate = await shouldLoadSatellite(false);
                if (needsUpdate) {
                    log('info', 'üõ∞Ô∏è Detectada nova imagem de sat√©lite, atualizando...');
                    loadSatelliteWithReprojection(true);
                }
            }
        }, 5 * 60 * 1000);  // 5 minutos
    }
    
    // ============ TOGGLE FORECAST INFO ============
    function toggleForecastInfo() {
        const info = document.getElementById('forecast-selected-info');
        const btn = document.getElementById('forecast-toggle-btn');
        
        if (info.classList.contains('visible')) {
            info.classList.remove('visible');
            btn.classList.remove('active');
            btn.textContent = '‚ñº Detalhes';
        } else {
            info.classList.add('visible');
            btn.classList.add('active');
            btn.textContent = '‚ñ≤ Ocultar';
        }
    }
    
    // =========================================================================
    // CAMADA DE SAT√âLITE (Imagem pr√©-processada)
    // =========================================================================
    let satelliteEnabled = true;
    let satelliteLayer = null;
    let satelliteRefreshInterval = null;
    let satelliteData = null;
    let currentSatellite = 'goes19';  // Sat√©lite padr√£o
    let currentSatelliteTimestamp = null;  // Timestamp da imagem carregada
    let isLoadingSatellite = false;  // Flag para evitar carregamentos simult√¢neos
    let pendingSatelliteLayer = null;  // Camada sendo carregada em background
    let autoExtractEnabled = true;  // Auto-extra√ß√£o ligada por padr√£o
    
    // =========================================================================
    // CAMADA DMW (Derived Motion Winds)
    // =========================================================================
    let dmwEnabled = false;
    let dmwLayer = null;
    let dmwData = null;
    let dmwMarkers = [];
    let dmwAutoRefreshInterval = null;
    let lastDMWHour = -1;  // Para controlar atualiza√ß√£o por hora
    
    // ============ FUN√á√ÉO TOGGLE COLLAPSIBLE ============
    function toggleCollapsible(header) {
        header.classList.toggle('collapsed');
        const content = header.nextElementSibling;
        if (content && content.classList.contains('collapsible-content')) {
            content.classList.toggle('collapsed');
        }
    }
    
    function toggleDMW(enabled) {
        dmwEnabled = enabled;
        
        // Atualizar bot√µes
        document.getElementById('btn-dmw-on').classList.toggle('active', enabled);
        document.getElementById('btn-dmw-off').classList.toggle('active', !enabled);
        
        // Atualizar status
        const statusEl = document.getElementById('dmw-status');
        
        if (enabled) {
            log('success', '‚úÖ DMW LIGADO - Carregando ventos...');
            statusEl.className = 'status-indicator loading';
            loadDMWWinds();
            
            // Iniciar verifica√ß√£o autom√°tica a cada minuto
            startDMWAutoRefresh();
        } else {
            log('info', '‚ùå DMW DESLIGADO');
            statusEl.className = 'status-indicator';
            clearDMWLayer();
            
            // Parar verifica√ß√£o autom√°tica
            stopDMWAutoRefresh();
        }
    }
    
    function startDMWAutoRefresh() {
        // Verificar a cada minuto se est√° no minuto 5
        if (dmwAutoRefreshInterval) {
            clearInterval(dmwAutoRefreshInterval);
        }
        
        // Mostrar pr√≥xima atualiza√ß√£o
        updateNextDMWTime();
        document.getElementById('dmw-next-update').style.display = 'block';
        
        dmwAutoRefreshInterval = setInterval(() => {
            if (!dmwEnabled) return;
            
            const now = new Date();
            const minute = now.getMinutes();
            const hour = now.getHours();
            
            // Atualizar info de pr√≥xima atualiza√ß√£o
            updateNextDMWTime();
            
            // Atualizar no minuto 5 de cada hora (12:05, 13:05, etc)
            // E apenas se ainda n√£o atualizou nessa hora
            if (minute === 5 && hour !== lastDMWHour) {
                lastDMWHour = hour;
                log('info', `üîÑ DMW: Atualiza√ß√£o autom√°tica (${hour}:05)`);
                loadDMWWinds();
            }
        }, 60 * 1000);  // Verificar a cada 1 minuto
        
        log('info', '‚è∞ DMW: Auto-refresh ativado (atualiza em XX:05)');
    }
    
    function updateNextDMWTime() {
        const now = new Date();
        let nextHour = now.getHours();
        
        // Se j√° passou do minuto 5, pr√≥xima √© na pr√≥xima hora
        if (now.getMinutes() >= 5) {
            nextHour = (nextHour + 1) % 24;
        }
        
        const nextUpdateEl = document.getElementById('dmw-next-update');
        if (nextUpdateEl) {
            nextUpdateEl.textContent = `‚è∞ Pr√≥xima atualiza√ß√£o: ${String(nextHour).padStart(2, '0')}:05`;
        }
    }
    
    function stopDMWAutoRefresh() {
        if (dmwAutoRefreshInterval) {
            clearInterval(dmwAutoRefreshInterval);
            dmwAutoRefreshInterval = null;
        }
        lastDMWHour = -1;
        document.getElementById('dmw-next-update').style.display = 'none';
    }
    
    function clearDMWLayer() {
        if (dmwLayer) {
            dmwLayer.clearLayers();
            map.removeLayer(dmwLayer);
            dmwLayer = null;
        }
        dmwMarkers = [];
    }
    
    async function loadDMWWinds() {
        if (!dmwEnabled) return;
        
        const level = document.getElementById('dmw-level').value;
        const statusEl = document.getElementById('dmw-status');
        const infoEl = document.getElementById('dmw-info');
        
        statusEl.className = 'status-indicator loading';
        log('info', 'üå¨Ô∏è Carregando dados DMW do GOES...');
        
        try {
            // N√≠veis de press√£o para filtrar
            const levelConfig = {
                'low': { min: 700, max: 1100, name: 'Baixo N√≠vel (<3km)' },
                'mid': { min: 400, max: 700, name: 'N√≠vel M√©dio (3-7km)' },
                'high': { min: 100, max: 400, name: 'Alto N√≠vel (>7km)' },
                'all': { min: 100, max: 1100, name: 'Todos os N√≠veis' }
            };
            
            const levelInfo = levelConfig[level] || levelConfig['low'];
            
            // Tentar usar API do servidor primeiro, depois fallback para arquivo JSON
            let dmwData = null;
            // Usar os mesmos bounds da imagem de sat√©lite reprojetada
            // para garantir que os vetores fiquem dentro da √°rea vis√≠vel
            const latMin = REPROJECTION_BOUNDS.south;  // -30
            const latMax = REPROJECTION_BOUNDS.north;  // 0
            const lonMin = REPROJECTION_BOUNDS.west;   // -60
            const lonMax = REPROJECTION_BOUNDS.east;   // -30
            
            // Carregar dados DMW do arquivo JSON (gerado pelo dmw_extractor.py)
            console.log('[DMW] Carregando dmw_latest.json...');
            log('info', 'üå¨Ô∏è DMW: Carregando dados...');
            
            const response = await fetch('dmw_latest.json?' + Date.now());
            if (!response.ok) {
                throw new Error(`Dados DMW n√£o encontrados (${response.status})`);
            }
            dmwData = await response.json();
            console.log(`[DMW] Dados carregados: ${dmwData.count || (dmwData.winds ? dmwData.winds.length : 0)} ventos`);
            
            log('success', `‚úÖ DMW carregado: ${dmwData.count || (dmwData.winds ? dmwData.winds.length : 0)} vetores totais`);
            
            // Limpar camada anterior
            clearDMWLayer();
            dmwLayer = L.layerGroup().addTo(map);
            
            const winds = [];
            const allWinds = dmwData.winds || [];
            
            // Limitar quantidade de vetores para n√£o poluir o mapa
            // Subsample: mostrar no m√°ximo ~200 vetores
            const maxVectors = 200;
            const step = allWinds.length > maxVectors ? Math.ceil(allWinds.length / maxVectors) : 1;
            
            for (let i = 0; i < allWinds.length; i += step) {
                const w = allWinds[i];
                
                // Sempre filtrar por √°rea (bounds da imagem de sat√©lite)
                if (w.lat < latMin || w.lat > latMax) continue;
                if (w.lon < lonMin || w.lon > lonMax) continue;
                
                // Filtrar por n√≠vel de press√£o
                if (w.pressure_hpa !== undefined) {
                    if (w.pressure_hpa < levelInfo.min || w.pressure_hpa > levelInfo.max) continue;
                }
                
                winds.push(w);
                
                // Cor baseada na velocidade
                const color = getDMWColor(w.speed_kt);
                
                // Criar seta de vento com press√£o e quality flag
                const pressure = w.pressure_hpa || 0;
                const qf = w.quality_flag !== undefined ? w.quality_flag : -1;
                const arrow = createDMWArrow(w.lat, w.lon, w.direction, w.speed_kt, color, pressure, qf);
                arrow.addTo(dmwLayer);
                dmwMarkers.push(arrow);
            }
            
            // Atualizar info com hor√°rio do arquivo
            const timestamp = dmwData.timestamp ? new Date(dmwData.timestamp) : new Date();
            const scanTime = dmwData.scan_time || timestamp.toISOString();
            infoEl.innerHTML = `üìÖ <strong>${winds.length}</strong> vetores | ${levelInfo.name}<br>` +
                              `üõ∞Ô∏è GOES: ${new Date(scanTime).toLocaleString('pt-BR')}`;
            
            statusEl.className = 'status-indicator active';
            log('success', `‚úÖ DMW: ${winds.length} vetores na √°rea`);
            
        } catch (err) {
            console.error('‚ùå Erro DMW:', err);
            log('error', 'Erro DMW: ' + err.message);
            statusEl.className = 'status-indicator error';
            infoEl.textContent = '‚ùå Erro ao carregar dados';
        }
    }
    
    function getDMWColor(speedKt) {
        // Escala de cores unificada (igual ao Scatterometer)
        if (speedKt < 10) return '#00ff00';      // Verde - Calmo (0-10 kn)
        if (speedKt < 15) return '#88ff00';      // Verde claro - Leve (10-15 kn)
        if (speedKt < 20) return '#ffff00';      // Amarelo - Moderado (15-20 kn)
        if (speedKt < 25) return '#ff9900';      // Laranja - Fresco (20-25 kn)
        if (speedKt < 30) return '#ff0000';      // Vermelho - Forte (25-30 kn)
        return '#ff00ff';                         // Roxo/Magenta - Muito forte (>30 kn)
    }
    
    function createDMWArrow(lat, lon, direction, speed, color, pressure, qualityFlag) {
        // Tamanho da seta GRANDE para visualiza√ß√£o de 10m de dist√¢ncia
        const size = Math.min(50 + speed * 0.8, 80);
        
        // DIRE√á√ÉO: Valor indica DE ONDE o vento vem (conven√ß√£o meteorol√≥gica)
        // Seta aponta PARA ONDE o vento vai (rota√ß√£o +180¬∞)
        const arrowRotation = (direction + 180) % 360;
        
        // Criar HTML da seta usando SVG (formato de seta real) - GRANDE E VIS√çVEL
        const arrowHtml = `
            <div style="transform: rotate(${arrowRotation}deg); width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center;">
                <svg viewBox="0 0 24 24" width="${size - 8}" height="${size - 8}">
                    <path fill="${color}" stroke="#000" stroke-width="1.5" d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
                </svg>
            </div>
            <div style="text-align:center; font-size:18px; font-weight:bold; color:${color}; text-shadow: 2px 2px 4px black, -1px -1px 2px black; margin-top:-4px;">
                ${speed.toFixed(0)}
            </div>
        `;

        const icon = L.divIcon({
            className: 'dmw-wind-arrow',
            html: arrowHtml,
            iconSize: [size, size + 24],
            iconAnchor: [size/2, (size + 24)/2]
        });
        
        // Quality flag descri√ß√£o
        const qfDesc = qualityFlag === 0 ? '‚úÖ √ìtimo' : 
                       qualityFlag === 1 ? '‚ö†Ô∏è Degradado' : 
                       qualityFlag >= 2 ? '‚ùå Ruim' : '‚ùì N/A';
        
        // Popup com informa√ß√µes completas
        const popup = `<b>üå¨Ô∏è Vento DMW (GOES)</b><br>
                       <b>Velocidade:</b> ${speed.toFixed(1)} kt (${(speed * 0.514444).toFixed(1)} m/s)<br>
                       <b>Dire√ß√£o:</b> ${direction.toFixed(0)}¬∞ (de onde vem)<br>
                       <b>Press√£o:</b> ${pressure.toFixed(0)} hPa<br>
                       <b>Qualidade:</b> ${qfDesc} (DQF=${qualityFlag})<br>
                       <hr style="margin:4px 0;border-color:#444;">
                       <b>Lat:</b> ${lat.toFixed(3)}¬∞<br>
                       <b>Lon:</b> ${lon.toFixed(3)}¬∞`;

        return L.marker([lat, lon], { icon: icon })
            .bindPopup(popup);
    }

    // =========================================================================
    // CAMADA L2 GOES (CAPE, LI, Cloud Height, TPW)
    // =========================================================================
    let l2Enabled = false;
    let l2Layer = null;
    let l2Data = null;
    let l2Markers = [];
    let l2CanvasLayer = null;
    let l2DisplayMode = 'area'; // 'area' ou 'markers'
    let l2Opacity = 70; // Opacidade do canvas L2 (0-100)
    
    // Fun√ß√£o para atualizar opacidade do canvas L2
    function updateL2Opacity(value) {
        l2Opacity = parseInt(value);
        document.getElementById('l2-opacity-value').textContent = l2Opacity + '%';
        
        // Redesenhar o canvas com a nova opacidade
        if (l2CanvasLayer && l2DisplayMode === 'area') {
            l2CanvasLayer.draw();
        }
    }
    
    function toggleL2(enabled) {
        l2Enabled = enabled;
        
        // Atualizar bot√µes
        document.getElementById('btn-l2-on').classList.toggle('active', enabled);
        document.getElementById('btn-l2-off').classList.toggle('active', !enabled);
        
        // Atualizar status
        const statusEl = document.getElementById('l2-status');
        
        if (enabled) {
            log('success', '‚úÖ L2 LIGADO - Carregando dados...');
            statusEl.className = 'status-indicator loading';
            loadL2Data();
        } else {
            log('info', '‚ùå L2 DESLIGADO');
            statusEl.className = 'status-indicator';
            clearL2Layer();
            document.getElementById('l2-ship-data').style.display = 'none';
        }
    }
    
    function clearL2Layer() {
        if (l2Layer) {
            l2Layer.clearLayers();
            map.removeLayer(l2Layer);
            l2Layer = null;
        }
        if (l2CanvasLayer) {
            map.removeLayer(l2CanvasLayer);
            l2CanvasLayer = null;
        }
        l2Markers = [];
    }
    
    async function loadL2Data() {
        if (!l2Enabled) return;
        
        const statusEl = document.getElementById('l2-status');
        const infoEl = document.getElementById('l2-info');
        
        try {
            statusEl.className = 'status-indicator loading';
            infoEl.textContent = 'üì° Carregando dados L2...';
            
            // Carregar dados L2 do arquivo JSON (gerado pelo goes_l2_extractor.py)
            console.log('[L2] Carregando goes_l2_latest.json...');
            log('info', 'üì° L2: Carregando dados...');
            
            const response = await fetch('goes_l2_latest.json?' + Date.now());
            if (!response.ok) {
                throw new Error(`Dados L2 n√£o encontrados (${response.status})`);
            }
            
            l2Data = await response.json();
            console.log('[L2] Dados carregados:', l2Data.products ? Object.keys(l2Data.products) : 'sem produtos');
            
            // Limpar camada anterior
            clearL2Layer();
            l2Layer = L.layerGroup().addTo(map);
            
            // Exibir dados com a vari√°vel selecionada
            updateL2Display();
            
            // Atualizar info
            const timestamp = new Date(l2Data.timestamp);
            infoEl.innerHTML = `üìÖ ${timestamp.toLocaleString('pt-BR')}<br>üõ∞Ô∏è ${l2Data.satellite_name || 'GOES-19'}`;
            
            statusEl.className = 'status-indicator active';
            log('success', `‚úÖ L2: Dados carregados`);
            
        } catch (err) {
            console.error('‚ùå Erro L2:', err);
            log('error', 'Erro L2: ' + err.message);
            statusEl.className = 'status-indicator error';
            infoEl.textContent = '‚ùå Erro ao carregar dados';
        }
    }
    
    function updateL2Display() {
        if (!l2Data) return;
        
        // Criar legenda
        const selectedVar = document.getElementById('l2-variable').value;
        createL2Legend(selectedVar);
        
        // Se modo √°rea, usar canvas layer
        if (l2DisplayMode === 'area') {
            if (l2Layer) {
                l2Layer.clearLayers();
            }
            l2Markers = [];
            updateL2CanvasLayer();
            updateL2ShipData();
            return;
        }
        
        // Modo marcadores
        if (!l2Layer) return;
        
        l2Layer.clearLayers();
        l2Markers = [];
        
        const shipData = document.getElementById('l2-ship-data');
        
        // Encontrar qual produto tem a vari√°vel
        let productKey = null;
        let productData = null;
        
        if (selectedVar === 'CAPE' || selectedVar === 'LI' || selectedVar === 'KI' || selectedVar === 'TT' || selectedVar === 'SI') {
            productKey = 'DSIF';
        } else if (selectedVar === 'TPW') {
            productKey = 'TPWF';
        } else if (selectedVar === 'HT') {
            productKey = 'ACHAF';
        } else if (selectedVar === 'Phase') {
            productKey = 'ACTPF';
        }
        
        if (productKey && l2Data.products[productKey] && l2Data.products[productKey].data) {
            productData = l2Data.products[productKey].data;
        }
        
        if (!productData || productData.length === 0) {
            log('warning', `‚ö†Ô∏è Sem dados para ${selectedVar}`);
            return;
        }
        
        // Encontrar dados no ponto do navio (mais pr√≥ximo)
        let closestToShip = null;
        let minDist = Infinity;
        
        for (const point of productData) {
            const dist = Math.sqrt(Math.pow(point.lat - CONFIG.shipLat, 2) + Math.pow(point.lon - CONFIG.shipLon, 2));
            if (dist < minDist) {
                minDist = dist;
                closestToShip = point;
            }
        }
        
        // Exibir dados do ponto mais pr√≥ximo ao navio
        if (closestToShip && minDist < 0.5) {
            shipData.style.display = 'block';
            
            // DSIF
            if (l2Data.products.DSIF && l2Data.products.DSIF.data) {
                const dsif = l2Data.products.DSIF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (dsif) {
                    document.getElementById('l2-ship-cape').textContent = dsif.CAPE ? dsif.CAPE.toFixed(0) + ' J/kg' : '--';
                    document.getElementById('l2-ship-li').textContent = dsif.LI ? dsif.LI.toFixed(1) + ' K' : '--';
                }
            }
            
            // TPW
            if (l2Data.products.TPWF && l2Data.products.TPWF.data) {
                const tpw = l2Data.products.TPWF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (tpw) {
                    document.getElementById('l2-ship-tpw').textContent = tpw.TPW ? tpw.TPW.toFixed(1) + ' mm' : '--';
                }
            }
            
            // Cloud Height
            if (l2Data.products.ACHAF && l2Data.products.ACHAF.data) {
                const ht = l2Data.products.ACHAF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (ht && ht.HT) {
                    document.getElementById('l2-ship-ht').textContent = (ht.HT / 1000).toFixed(1) + ' km';
                } else {
                    document.getElementById('l2-ship-ht').textContent = '‚òÄÔ∏è C√©u limpo';
                }
            }
        }
        
        // Exibir marcadores no mapa
        for (const point of productData) {
            const value = point[selectedVar];
            if (value === undefined || value === null) continue;
            
            const color = getL2Color(selectedVar, value);
            const label = formatL2Value(selectedVar, value);
            
            const marker = createL2Marker(point.lat, point.lon, label, color, selectedVar, point);
            marker.addTo(l2Layer);
            l2Markers.push(marker);
        }
        
        log('info', `üìä L2: ${l2Markers.length} pontos de ${selectedVar}`);
    }
    
    // Atualizar dados do navio (usado por ambos os modos)
    function updateL2ShipData() {
        if (!l2Data) return;
        
        const shipData = document.getElementById('l2-ship-data');
        const selectedVar = document.getElementById('l2-variable').value;
        
        // Encontrar qual produto tem a vari√°vel
        let productKey = null;
        if (selectedVar === 'CAPE' || selectedVar === 'LI' || selectedVar === 'KI' || selectedVar === 'TT' || selectedVar === 'SI') {
            productKey = 'DSIF';
        } else if (selectedVar === 'TPW') {
            productKey = 'TPWF';
        } else if (selectedVar === 'HT') {
            productKey = 'ACHAF';
        } else if (selectedVar === 'Phase') {
            productKey = 'ACTPF';
        }
        
        if (!productKey || !l2Data.products[productKey] || !l2Data.products[productKey].data) {
            return;
        }
        
        const productData = l2Data.products[productKey].data;
        
        // Encontrar dados no ponto do navio (mais pr√≥ximo)
        let closestToShip = null;
        let minDist = Infinity;
        
        for (const point of productData) {
            const dist = Math.sqrt(Math.pow(point.lat - CONFIG.shipLat, 2) + Math.pow(point.lon - CONFIG.shipLon, 2));
            if (dist < minDist) {
                minDist = dist;
                closestToShip = point;
            }
        }
        
        if (closestToShip && minDist < 0.5) {
            shipData.style.display = 'block';
            
            // DSIF
            if (l2Data.products.DSIF && l2Data.products.DSIF.data) {
                const dsif = l2Data.products.DSIF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (dsif) {
                    document.getElementById('l2-ship-cape').textContent = dsif.CAPE ? dsif.CAPE.toFixed(0) + ' J/kg' : '--';
                    document.getElementById('l2-ship-li').textContent = dsif.LI ? dsif.LI.toFixed(1) + ' K' : '--';
                }
            }
            
            // TPW
            if (l2Data.products.TPWF && l2Data.products.TPWF.data) {
                const tpw = l2Data.products.TPWF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (tpw) {
                    document.getElementById('l2-ship-tpw').textContent = tpw.TPW ? tpw.TPW.toFixed(1) + ' mm' : '--';
                }
            }
            
            // Cloud Height
            if (l2Data.products.ACHAF && l2Data.products.ACHAF.data) {
                const ht = l2Data.products.ACHAF.data.find(p => 
                    Math.abs(p.lat - closestToShip.lat) < 0.1 && Math.abs(p.lon - closestToShip.lon) < 0.1
                );
                if (ht && ht.HT) {
                    document.getElementById('l2-ship-ht').textContent = (ht.HT / 1000).toFixed(1) + ' km';
                } else {
                    document.getElementById('l2-ship-ht').textContent = '‚òÄÔ∏è C√©u limpo';
                }
            }
        }
    }
    
    // =========================================================================
    // SISTEMA DE CORES COM GRADIENTE GRANULAR
    // =========================================================================
    
    // Interpola entre duas cores hex
    function interpolateColor(color1, color2, factor) {
        const hex = (c) => parseInt(c, 16);
        const r1 = hex(color1.slice(1, 3)), g1 = hex(color1.slice(3, 5)), b1 = hex(color1.slice(5, 7));
        const r2 = hex(color2.slice(1, 3)), g2 = hex(color2.slice(3, 5)), b2 = hex(color2.slice(5, 7));
        const r = Math.round(r1 + (r2 - r1) * factor);
        const g = Math.round(g1 + (g2 - g1) * factor);
        const b = Math.round(b1 + (b2 - b1) * factor);
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    // Paleta de cores expandida para CAPE
    const CAPE_COLORS = [
        { value: 0, color: '#004400' },      // Verde muito escuro
        { value: 50, color: '#006600' },     // Verde escuro
        { value: 100, color: '#008800' },    // Verde m√©dio-escuro
        { value: 150, color: '#00aa00' },    // Verde m√©dio
        { value: 200, color: '#00cc00' },    // Verde
        { value: 300, color: '#00ff00' },    // Verde claro
        { value: 400, color: '#66ff00' },    // Verde-amarelo claro
        { value: 500, color: '#99ff00' },    // Amarelo-verde
        { value: 600, color: '#ccff00' },    // Amarelo esverdeado
        { value: 700, color: '#e6e600' },    // Amarelo escuro
        { value: 800, color: '#ffff00' },    // Amarelo
        { value: 900, color: '#ffdd00' },    // Amarelo-laranja claro
        { value: 1000, color: '#ffcc00' },   // Laranja claro
        { value: 1200, color: '#ffaa00' },   // Laranja m√©dio-claro
        { value: 1400, color: '#ff9900' },   // Laranja
        { value: 1600, color: '#ff7700' },   // Laranja escuro
        { value: 1800, color: '#ff5500' },   // Laranja-vermelho
        { value: 2000, color: '#ff3300' },   // Vermelho-laranja
        { value: 2500, color: '#ff0000' },   // Vermelho
        { value: 3000, color: '#cc0000' },   // Vermelho escuro
        { value: 4000, color: '#990000' },   // Vermelho muito escuro
        { value: 5000, color: '#660033' }    // Roxo escuro
    ];
    
    // Paleta de cores para LI (Lifted Index) - valores negativos = inst√°vel
    const LI_COLORS = [
        { value: 6, color: '#004400' },      // Muito est√°vel - verde muito escuro
        { value: 4, color: '#006600' },      // Muito est√°vel - verde escuro
        { value: 2, color: '#00aa00' },      // Est√°vel - verde m√©dio
        { value: 1, color: '#00ff00' },      // Est√°vel - verde claro
        { value: 0, color: '#88ff00' },      // Marginalmente est√°vel - verde-amarelo
        { value: -1, color: '#ccff00' },     // Marginalmente inst√°vel - amarelo-verde
        { value: -2, color: '#ffff00' },     // Levemente inst√°vel - amarelo
        { value: -3, color: '#ffcc00' },     // Inst√°vel - laranja claro
        { value: -4, color: '#ff9900' },     // Moderadamente inst√°vel - laranja
        { value: -5, color: '#ff6600' },     // Muito inst√°vel - laranja escuro
        { value: -6, color: '#ff3300' },     // Muito inst√°vel - vermelho-laranja
        { value: -8, color: '#ff0000' },     // Extremamente inst√°vel - vermelho
        { value: -10, color: '#cc0000' }     // Extremamente inst√°vel - vermelho escuro
    ];
    
    // Paleta de cores para TPW (√°gua precipit√°vel)
    const TPW_COLORS = [
        { value: 0, color: '#001144' },      // Muito seco - azul muito escuro
        { value: 10, color: '#002288' },     // Seco - azul escuro
        { value: 20, color: '#0044cc' },     // Seco - azul m√©dio
        { value: 30, color: '#0088ff' },     // Normal - azul claro
        { value: 40, color: '#00ccff' },     // Normal - ciano
        { value: 50, color: '#00ffaa' },     // √ömido - verde-ciano
        { value: 60, color: '#88ff00' },     // √ömido - verde-amarelo
        { value: 70, color: '#ffff00' },     // Muito √∫mido - amarelo
        { value: 80, color: '#ff9900' },     // Muito √∫mido - laranja
        { value: 90, color: '#ff0000' },     // Extremamente √∫mido - vermelho
        { value: 100, color: '#990066' }     // Saturado - roxo
    ];
    
    // Paleta de cores para altura de nuvem
    const HT_COLORS = [
        { value: 0, color: '#004400' },      // Sem nuvem - verde muito escuro
        { value: 1000, color: '#00aa00' },   // Baixa - verde m√©dio
        { value: 2000, color: '#00ff00' },   // Baixa - verde claro
        { value: 3000, color: '#88ff00' },   // M√©dia-baixa - verde-amarelo
        { value: 4000, color: '#ccff00' },   // M√©dia - amarelo-verde
        { value: 5000, color: '#ffff00' },   // M√©dia - amarelo
        { value: 6000, color: '#ffcc00' },   // M√©dia-alta - laranja claro
        { value: 8000, color: '#ff9900' },   // Alta - laranja
        { value: 10000, color: '#ff5500' },  // Alta - laranja escuro
        { value: 12000, color: '#ff0000' },  // Muito alta - vermelho
        { value: 14000, color: '#cc0066' },  // Muito alta - magenta escuro
        { value: 16000, color: '#9900cc' }   // Extrema - roxo
    ];
    
    // Fun√ß√£o para obter cor do gradiente
    function getColorFromGradient(value, colorStops) {
        // Encontrar os dois pontos entre os quais o valor est√°
        let lower = colorStops[0];
        let upper = colorStops[colorStops.length - 1];
        
        for (let i = 0; i < colorStops.length - 1; i++) {
            if (value >= colorStops[i].value && value <= colorStops[i + 1].value) {
                lower = colorStops[i];
                upper = colorStops[i + 1];
                break;
            } else if (value < colorStops[i].value) {
                return colorStops[i].color;
            }
        }
        
        if (value >= upper.value) return upper.color;
        if (value <= lower.value) return lower.color;
        
        // Interpolar
        const factor = (value - lower.value) / (upper.value - lower.value);
        return interpolateColor(lower.color, upper.color, factor);
    }
    
    function getL2Color(variable, value) {
        switch(variable) {
            case 'CAPE':
                return getColorFromGradient(value, CAPE_COLORS);
            
            case 'LI':
                // LI usa escala invertida (valores altos primeiro)
                return getColorFromGradient(value, LI_COLORS.slice().sort((a, b) => b.value - a.value));
            
            case 'TPW':
                return getColorFromGradient(value, TPW_COLORS);
            
            case 'HT':
                return getColorFromGradient(value, HT_COLORS);
            
            case 'Phase':
                const phases = ['#00aaff', '#00ff00', '#00ffcc', '#ffff00', '#ff00ff', '#888888'];
                return phases[Math.floor(value)] || '#888888';
            
            default:
                return '#ffffff';
        }
    }
    
    function formatL2Value(variable, value) {
        switch(variable) {
            case 'CAPE':
                return value.toFixed(0);
            case 'LI':
                return value.toFixed(1);
            case 'TPW':
                return value.toFixed(0);
            case 'HT':
                return (value / 1000).toFixed(1);
            case 'Phase':
                const labels = ['‚òÄÔ∏è', 'üíß', '‚ùÑÔ∏è', 'üåÄ', 'üßä', '‚ùì'];
                return labels[Math.floor(value)] || '?';
            default:
                return value.toFixed(1);
        }
    }
    
    function createL2Marker(lat, lon, label, color, variable, point) {
        // Tamanho GRANDE para visualiza√ß√£o de 10m de dist√¢ncia
        const size = 50;
        
        const markerHtml = `
            <div style="
                width: ${size}px;
                height: ${size}px;
                background: ${color};
                border: 3px solid #000;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                font-weight: bold;
                color: #000;
                text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
            ">${label}</div>
        `;

        const icon = L.divIcon({
            className: 'l2-marker',
            html: markerHtml,
            iconSize: [size, size],
            iconAnchor: [size/2, size/2]
        });
        
        // Popup com todos os dados dispon√≠veis
        let popupContent = `<b>üìä Dados L2 (GOES)</b><br>`;
        popupContent += `<b>Lat:</b> ${lat.toFixed(3)}¬∞<br>`;
        popupContent += `<b>Lon:</b> ${lon.toFixed(3)}¬∞<br>`;
        popupContent += `<hr style="margin:4px 0;border-color:#444;">`;
        
        // Adicionar dados espec√≠ficos do ponto
        if (point.CAPE !== undefined) popupContent += `<b>‚ö° CAPE:</b> ${point.CAPE.toFixed(0)} J/kg<br>`;
        if (point.LI !== undefined) popupContent += `<b>üå°Ô∏è LI:</b> ${point.LI.toFixed(1)} K<br>`;
        if (point.KI !== undefined) popupContent += `<b>üìà K-Index:</b> ${point.KI.toFixed(1)}<br>`;
        if (point.TT !== undefined) popupContent += `<b>üìä TT-Index:</b> ${point.TT.toFixed(1)}<br>`;
        if (point.TPW !== undefined) popupContent += `<b>üíß TPW:</b> ${point.TPW.toFixed(1)} mm<br>`;
        if (point.HT !== undefined) popupContent += `<b>‚òÅÔ∏è Altura:</b> ${(point.HT/1000).toFixed(1)} km<br>`;
        if (point.Phase !== undefined) {
            const phaseLabels = ['C√©u Limpo', '√Ågua', 'Super-resfriada', 'Mista', 'Gelo', 'Incerto'];
            popupContent += `<b>üßä Fase:</b> ${phaseLabels[Math.floor(point.Phase)] || 'N/A'}<br>`;
        }
        if (point.DQF !== undefined) {
            const dqfLabels = ['‚úÖ √ìtimo', '‚ö†Ô∏è Degradado', '‚ùå Ruim'];
            popupContent += `<b>üìã DQF:</b> ${dqfLabels[point.DQF] || point.DQF}<br>`;
        }

        return L.marker([lat, lon], { icon: icon })
            .bindPopup(popupContent);
    }

    // =========================================================================
    // RENDERIZA√á√ÉO DE √ÅREA UNIFICADA COM GRADIENTE (Canvas Overlay)
    // =========================================================================
    
    // Extens√£o do Leaflet para Canvas Layer
    L.CanvasLayer = L.Layer.extend({
        initialize: function(options) {
            L.setOptions(this, options);
            this._canvas = null;
            this._ctx = null;
        },
        
        onAdd: function(map) {
            this._map = map;
            
            // Criar canvas
            this._canvas = L.DomUtil.create('canvas', 'leaflet-canvas-layer');
            const size = map.getSize();
            this._canvas.width = size.x;
            this._canvas.height = size.y;
            this._canvas.style.position = 'absolute';
            this._canvas.style.top = '0';
            this._canvas.style.left = '0';
            this._canvas.style.pointerEvents = 'none';
            this._canvas.style.zIndex = '250';
            
            this._ctx = this._canvas.getContext('2d');
            
            map.getPanes().overlayPane.appendChild(this._canvas);
            
            map.on('moveend', this._reset, this);
            map.on('zoomend', this._reset, this);
            map.on('resize', this._resize, this);
            
            this._reset();
        },
        
        onRemove: function(map) {
            L.DomUtil.remove(this._canvas);
            map.off('moveend', this._reset, this);
            map.off('zoomend', this._reset, this);
            map.off('resize', this._resize, this);
        },
        
        _resize: function() {
            const size = this._map.getSize();
            this._canvas.width = size.x;
            this._canvas.height = size.y;
            this._reset();
        },
        
        _reset: function() {
            const topLeft = this._map.containerPointToLayerPoint([0, 0]);
            L.DomUtil.setPosition(this._canvas, topLeft);
            this.draw();
        },
        
        draw: function() {
            if (this.options.drawCallback) {
                this.options.drawCallback(this._canvas, this._ctx, this._map);
            }
        },
        
        getCanvas: function() {
            return this._canvas;
        },
        
        getContext: function() {
            return this._ctx;
        }
    });
    
    // Interpola√ß√£o IDW (Inverse Distance Weighting)
    function idwInterpolation(x, y, points, variable, power = 2) {
        let numerator = 0;
        let denominator = 0;
        
        for (const point of points) {
            const value = point[variable];
            if (value === undefined || value === null) continue;
            
            const dx = x - point.lon;
            const dy = y - point.lat;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 0.0001) {
                return value; // Ponto exato
            }
            
            const weight = 1 / Math.pow(dist, power);
            numerator += weight * value;
            denominator += weight;
        }
        
        return denominator > 0 ? numerator / denominator : null;
    }
    
    // Desenhar √°rea com gradiente usando IDW
    function drawL2GradientArea(canvas, ctx, map) {
        if (!l2Data || !l2Enabled) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
        }
        
        const selectedVar = document.getElementById('l2-variable').value;
        
        // Encontrar produto correto
        let productKey = null;
        if (selectedVar === 'CAPE' || selectedVar === 'LI' || selectedVar === 'KI' || selectedVar === 'TT' || selectedVar === 'SI') {
            productKey = 'DSIF';
        } else if (selectedVar === 'TPW') {
            productKey = 'TPWF';
        } else if (selectedVar === 'HT') {
            productKey = 'ACHAF';
        } else if (selectedVar === 'Phase') {
            productKey = 'ACTPF';
        }
        
        if (!productKey || !l2Data.products[productKey] || !l2Data.products[productKey].data) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
        }
        
        const points = l2Data.products[productKey].data;
        if (points.length === 0) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
        }
        
        // Limpar canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Definir bounds baseado no c√≠rculo de interesse
        const centerLat = CONFIG.shipLat;
        const centerLon = CONFIG.shipLon;
        const radiusDeg = RAIO_VISUAL_GRAUS;
        
        // Resolu√ß√£o do grid para interpola√ß√£o (quanto menor, mais suave)
        const resolution = 4; // pixels por c√©lula
        
        // Criar imagem de dados
        const imageData = ctx.createImageData(canvas.width, canvas.height);
        const data = imageData.data;
        
        // Para cada pixel do canvas
        for (let py = 0; py < canvas.height; py += resolution) {
            for (let px = 0; px < canvas.width; px += resolution) {
                // Converter pixel para lat/lon
                const point = map.containerPointToLatLng([px, py]);
                const lat = point.lat;
                const lon = point.lng;
                
                // Verificar se est√° dentro do c√≠rculo de interesse
                const distFromCenter = Math.sqrt(
                    Math.pow(lat - centerLat, 2) + 
                    Math.pow(lon - centerLon, 2)
                );
                
                if (distFromCenter > radiusDeg * 1.1) continue; // Fora do c√≠rculo
                
                // Interpolar valor neste ponto
                const value = idwInterpolation(lon, lat, points, selectedVar, 2);
                
                if (value === null) continue;
                
                // Debug: log alguns valores para verificar interpola√ß√£o
                if (Math.random() < 0.001) {
                    console.log(`[L2 Canvas] ${selectedVar} em (${lat.toFixed(2)}, ${lon.toFixed(2)}): valor=${value.toFixed(1)}`);
                }
                
                // Obter cor do gradiente
                const color = getL2Color(selectedVar, value);
                
                // Extrair RGB da cor
                let r, g, b;
                if (color.startsWith('rgb')) {
                    const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (match) {
                        r = parseInt(match[1]);
                        g = parseInt(match[2]);
                        b = parseInt(match[3]);
                    }
                } else if (color.startsWith('#')) {
                    r = parseInt(color.slice(1, 3), 16);
                    g = parseInt(color.slice(3, 5), 16);
                    b = parseInt(color.slice(5, 7), 16);
                }
                
                if (r === undefined) continue;
                
                // Calcular opacidade baseada no slider e dist√¢ncia do centro (fade nas bordas)
                const baseAlpha = Math.round(l2Opacity * 2.55); // Converter 0-100 para 0-255
                let alpha = baseAlpha;
                if (distFromCenter > radiusDeg * 0.8) {
                    const fadeFactor = (radiusDeg * 1.1 - distFromCenter) / (radiusDeg * 0.3);
                    alpha = Math.max(0, Math.min(baseAlpha, baseAlpha * fadeFactor));
                }
                
                // Preencher bloco de pixels
                for (let dy = 0; dy < resolution && py + dy < canvas.height; dy++) {
                    for (let dx = 0; dx < resolution && px + dx < canvas.width; dx++) {
                        const idx = ((py + dy) * canvas.width + (px + dx)) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = alpha;
                    }
                }
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Desenhar borda do c√≠rculo
        const centerPoint = map.latLngToContainerPoint([centerLat, centerLon]);
        const edgePoint = map.latLngToContainerPoint([centerLat + radiusDeg, centerLon]);
        const radiusPixels = Math.abs(edgePoint.y - centerPoint.y);
        
        ctx.beginPath();
        ctx.arc(centerPoint.x, centerPoint.y, radiusPixels, 0, 2 * Math.PI);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Criar ou atualizar canvas layer
    function updateL2CanvasLayer() {
        if (!l2Enabled || l2DisplayMode !== 'area') {
            if (l2CanvasLayer) {
                map.removeLayer(l2CanvasLayer);
                l2CanvasLayer = null;
            }
            return;
        }
        
        if (!l2CanvasLayer) {
            l2CanvasLayer = new L.CanvasLayer({
                drawCallback: drawL2GradientArea
            });
            l2CanvasLayer.addTo(map);
        } else {
            l2CanvasLayer.draw();
        }
    }
    
    // Alternar modo de exibi√ß√£o
    function toggleL2DisplayMode(mode) {
        l2DisplayMode = mode;
        
        // Atualizar bot√µes
        document.getElementById('btn-l2-area').classList.toggle('active', mode === 'area');
        document.getElementById('btn-l2-markers').classList.toggle('active', mode === 'markers');
        
        if (mode === 'area') {
            // Limpar marcadores
            if (l2Layer) {
                l2Layer.clearLayers();
            }
            l2Markers = [];
            updateL2CanvasLayer();
            log('info', 'üé® L2: Modo √°rea com gradiente');
        } else {
            // Remover canvas
            if (l2CanvasLayer) {
                map.removeLayer(l2CanvasLayer);
                l2CanvasLayer = null;
            }
            updateL2Display();
            log('info', '‚≠ï L2: Modo marcadores');
        }
    }
    
    // Criar legenda din√¢mica para a vari√°vel selecionada
    function createL2Legend(variable) {
        const legendDiv = document.getElementById('l2-legend-cape');
        if (!legendDiv) return;
        
        let colorStops, title, unit;
        
        switch(variable) {
            case 'CAPE':
                colorStops = CAPE_COLORS;
                title = '‚ö° CAPE';
                unit = 'J/kg';
                break;
            case 'LI':
                colorStops = LI_COLORS;
                title = 'üå°Ô∏è Lifted Index';
                unit = 'K';
                break;
            case 'TPW':
                colorStops = TPW_COLORS;
                title = 'üíß TPW';
                unit = 'mm';
                break;
            case 'HT':
                colorStops = HT_COLORS;
                title = '‚òÅÔ∏è Altura';
                unit = 'm';
                break;
            default:
                legendDiv.style.display = 'none';
                return;
        }
        
        // Criar gradiente CSS
        const gradientColors = colorStops.map((stop, i) => {
            const percent = (i / (colorStops.length - 1)) * 100;
            return `${stop.color} ${percent}%`;
        }).join(', ');
        
        legendDiv.innerHTML = `
            <div style="background:#111; padding:8px; border-radius:4px; margin-top:8px; border:1px solid #333;">
                <div style="font-size:10px; color:#888; margin-bottom:4px;">${title} (${unit})</div>
                <div style="display:flex; align-items:center; gap:6px;">
                    <span style="font-size:9px; color:#666;">${colorStops[0].value}</span>
                    <div style="flex:1; height:12px; background: linear-gradient(to right, ${gradientColors}); border-radius:2px;"></div>
                    <span style="font-size:9px; color:#666;">${colorStops[colorStops.length-1].value}</span>
                </div>
            </div>
        `;
        legendDiv.style.display = 'block';
    }

    // Fun√ß√£o para ligar/desligar auto-extra√ß√£o
    function toggleAutoExtract(enabled) {
        autoExtractEnabled = enabled;
        
        // Atualizar bot√µes
        document.getElementById('btn-autoextract-on').classList.toggle('active', enabled);
        document.getElementById('btn-autoextract-off').classList.toggle('active', !enabled);
        
        if (enabled) {
            log('success', '‚úÖ Auto-extra√ß√£o de sat√©lite LIGADA (verifica a cada 5 min)');
        } else {
            log('warning', '‚ùå Auto-extra√ß√£o de sat√©lite DESLIGADA');
        }
    }
    
    function selectSatellite(satId) {
        currentSatellite = satId;
        
        // Atualizar bot√µes
        document.querySelectorAll('.toggle-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById('btn-' + satId).classList.add('active');
        
        // Atualizar nome no t√≠tulo
        const nameEl = document.getElementById('satellite-name');
        if (nameEl) {
            nameEl.textContent = satId === 'goes19' ? 'GOES-19' : 'GOES-16';
        }
        
        // Carregar novo sat√©lite
        loadSatelliteLayer();
        log('info', `üõ∞Ô∏è Sat√©lite alterado para ${satId.toUpperCase()}`);
    }
    
    // =========================================================================
    // REPROJE√á√ÉO REAL - GOES Full Disk para Web Mercator
    // =========================================================================
    
    // REPROJECTION_BOUNDS j√° definido acima, pr√≥ximo ao CONFIG
    
    // Fun√ß√£o para gerar URL da imagem Full Disk
    function getFullDiskUrl(satellite, product) {
        const sat = satellite.toUpperCase();
        return `https://cdn.star.nesdis.noaa.gov/${sat}/ABI/FD/${product}/5424x5424.jpg`;
    }
    
    // FUN√á√ïES DE PROJE√á√ÉO WEB MERCATOR (EPSG:3857)
    const EARTH_RADIUS = 6378137;
    
    function lonToMercatorX(lon) {
        return lon * Math.PI / 180 * EARTH_RADIUS;
    }
    
    function latToMercatorY(lat) {
        const latClamped = Math.max(-85, Math.min(85, lat));
        const latRad = latClamped * Math.PI / 180;
        return Math.log(Math.tan(Math.PI / 4 + latRad / 2)) * EARTH_RADIUS;
    }
    
    function mercatorXToLon(x) {
        return x / EARTH_RADIUS * 180 / Math.PI;
    }
    
    function mercatorYToLat(y) {
        return (2 * Math.atan(Math.exp(y / EARTH_RADIUS)) - Math.PI / 2) * 180 / Math.PI;
    }
    
    // GOES-R ABI Fixed Grid - converte lat/lon para coordenadas de scan
    function latLonToScan(lat, lon, sat_lon) {
        const DEG2RAD = Math.PI / 180;
        const req = 6378137.0;
        const rpol = 6356752.31414;
        const H = 42164160.0;
        const e2 = 1 - (rpol * rpol) / (req * req);
        
        const lat_rad = lat * DEG2RAD;
        const lon_rad = lon * DEG2RAD;
        const sat_lon_rad = sat_lon * DEG2RAD;
        
        const lat_geo = Math.atan((rpol * rpol / (req * req)) * Math.tan(lat_rad));
        const rc = rpol / Math.sqrt(1 - e2 * Math.cos(lat_geo) * Math.cos(lat_geo));
        const dlon = lon_rad - sat_lon_rad;
        
        const sx = H - rc * Math.cos(lat_geo) * Math.cos(dlon);
        const sy = -rc * Math.cos(lat_geo) * Math.sin(dlon);
        const sz = rc * Math.sin(lat_geo);
        
        const dlon_deg = Math.abs(lon - sat_lon);
        if (dlon_deg > 81 || Math.abs(lat) > 81) return null;
        
        const sn = Math.sqrt(sx * sx + sy * sy + sz * sz);
        const x = Math.asin(-sy / sn);
        const y = Math.atan(sz / sx);
        
        return { x, y };
    }
    
    // Interpola√ß√£o bilinear para qualidade
    function bilinearInterpolate(srcData, x, y) {
        const x0 = Math.floor(x);
        const y0 = Math.floor(y);
        const x1 = Math.min(x0 + 1, srcData.width - 1);
        const y1 = Math.min(y0 + 1, srcData.height - 1);
        
        const fx = x - x0;
        const fy = y - y0;
        
        const w00 = (1 - fx) * (1 - fy);
        const w10 = fx * (1 - fy);
        const w01 = (1 - fx) * fy;
        const w11 = fx * fy;
        
        const i00 = (y0 * srcData.width + x0) * 4;
        const i10 = (y0 * srcData.width + x1) * 4;
        const i01 = (y1 * srcData.width + x0) * 4;
        const i11 = (y1 * srcData.width + x1) * 4;
        
        return {
            r: Math.round(srcData.data[i00] * w00 + srcData.data[i10] * w10 + srcData.data[i01] * w01 + srcData.data[i11] * w11),
            g: Math.round(srcData.data[i00+1] * w00 + srcData.data[i10+1] * w10 + srcData.data[i01+1] * w01 + srcData.data[i11+1] * w11),
            b: Math.round(srcData.data[i00+2] * w00 + srcData.data[i10+2] * w10 + srcData.data[i01+2] * w01 + srcData.data[i11+2] * w11)
        };
    }
    
    // Carregar imagem com Promise
    function loadImageAsync(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error('Falha ao carregar imagem'));
            img.src = url;
        });
    }
    
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    
    function setReprojectionProgress(pct, text) {
        const bar = document.getElementById('satellite-progress-bar');
        const txt = document.getElementById('satellite-progress-text');
        const container = document.getElementById('satellite-progress');
        if (bar) bar.style.width = pct + '%';
        if (txt) txt.textContent = text || (Math.round(pct) + '%');
        if (container) container.style.display = 'block';
    }
    
    function hideReprojectionProgress() {
        const container = document.getElementById('satellite-progress');
        if (container) container.style.display = 'none';
    }
    
    // Fun√ß√£o para verificar timestamp da imagem no servidor
    async function checkSatelliteTimestamp(satellite, product) {
        try {
            const url = getFullDiskUrl(satellite, product);
            // Fazer HEAD request para pegar Last-Modified
            const response = await fetch(url, { method: 'HEAD', mode: 'cors' });
            const lastModified = response.headers.get('Last-Modified');
            if (lastModified) {
                return new Date(lastModified);
            }
            // Fallback: usar timestamp atual
            return new Date();
        } catch (e) {
            console.warn('N√£o foi poss√≠vel verificar timestamp:', e);
            return null;
        }
    }
    
    // Fun√ß√£o para verificar se precisa atualizar a imagem
    async function shouldLoadSatellite(forceLoad = false) {
        if (forceLoad) return true;
        if (!satelliteLayer) return true;  // N√£o tem imagem carregada
        if (!currentSatelliteTimestamp) return true;  // N√£o sabe o hor√°rio
        
        const satId = currentSatellite;
        const product = document.getElementById('satellite-product')?.value || 'GEOCOLOR';
        
        try {
            const serverTimestamp = await checkSatelliteTimestamp(satId, product);
            if (serverTimestamp && serverTimestamp > currentSatelliteTimestamp) {
                log('info', `üîÑ Nova imagem dispon√≠vel: ${serverTimestamp.toLocaleTimeString()}`);
                return true;
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    // FUN√á√ÉO PRINCIPAL: Carregar sat√©lite com reproje√ß√£o real
    async function loadSatelliteWithReprojection(forceLoad = true) {
        // Verificar se j√° est√° carregando
        if (isLoadingSatellite) {
            log('warning', '‚è≥ J√° existe um carregamento em andamento...');
            return;
        }
        
        // Verificar se precisa carregar (a menos que seja for√ßado)
        if (!forceLoad) {
            const needsLoad = await shouldLoadSatellite(false);
            if (!needsLoad) {
                log('info', '‚úì Imagem de sat√©lite est√° atualizada');
                return;
            }
        }
        
        const satId = currentSatellite;
        const product = document.getElementById('satellite-product')?.value || 'GEOCOLOR';
        const quality = document.getElementById('satellite-quality')?.value || 'medium';
        const opacity = (document.getElementById('satellite-opacity')?.value || 75) / 100;
        
        isLoadingSatellite = true;
        setStatus('satellite-status', 'loading');
        log('info', `üõ∞Ô∏è Iniciando reproje√ß√£o REAL: ${satId.toUpperCase()} - ${product}`);
        setReprojectionProgress(5, 'Iniciando...');
        
        try {
            // N√ÉO remover camada anterior - manter vis√≠vel enquanto carrega nova
            
            // URL da imagem Full Disk
            const url = getFullDiskUrl(satId, product);
            log('info', `üì° Carregando imagem Full Disk...`);
            setReprojectionProgress(10, 'Baixando imagem...');
            
            // Carregar imagem
            const img = await loadImageAsync(url + '?t=' + Date.now());
            log('info', `‚úÖ Imagem carregada: ${img.width}x${img.height}`);
            setReprojectionProgress(30, 'Imagem carregada');
            
            // Configura√ß√µes de qualidade
            const qualitySettings = {
                low: { width: 600, interpolate: false },
                medium: { width: 1200, interpolate: true },
                high: { width: 2400, interpolate: true },
                max: { width: 4800, interpolate: true }
            };
            const settings = qualitySettings[quality] || qualitySettings.medium;
            
            log('info', `üîÑ Reprojetando (${quality}: ${settings.width}px)...`);
            setReprojectionProgress(35, `Reprojetando (${quality})...`);
            
            // Bounds para reproje√ß√£o
            const bounds = REPROJECTION_BOUNDS;
            
            // Converter bounds para Web Mercator
            const mercBounds = {
                minX: lonToMercatorX(bounds.west),
                maxX: lonToMercatorX(bounds.east),
                minY: latToMercatorY(bounds.south),
                maxY: latToMercatorY(bounds.north)
            };
            
            // Canvas de sa√≠da
            const outWidth = settings.width;
            const outHeight = Math.round(outWidth * (mercBounds.maxY - mercBounds.minY) / (mercBounds.maxX - mercBounds.minX));
            
            const canvas = document.createElement('canvas');
            canvas.width = outWidth;
            canvas.height = outHeight;
            const ctx = canvas.getContext('2d');
            
            // Canvas fonte
            const srcCanvas = document.createElement('canvas');
            srcCanvas.width = img.width;
            srcCanvas.height = img.height;
            const srcCtx = srcCanvas.getContext('2d');
            srcCtx.drawImage(img, 0, 0);
            const srcData = srcCtx.getImageData(0, 0, img.width, img.height);
            
            // Canvas destino
            const outData = ctx.createImageData(outWidth, outHeight);
            
            // GOES-East longitude
            const sat_lon = -75.0;
            
            // Par√¢metros da imagem Full Disk
            const scanMax = 0.1518;
            const imgRadius = Math.min(img.width, img.height) / 2;
            const scale = imgRadius / scanMax;
            const centerX = img.width / 2;
            const centerY = img.height / 2;
            
            let pixelsVisible = 0;
            
            // Loop de reproje√ß√£o
            for (let y = 0; y < outHeight; y++) {
                for (let x = 0; x < outWidth; x++) {
                    const mercX = mercBounds.minX + (x / outWidth) * (mercBounds.maxX - mercBounds.minX);
                    const mercY = mercBounds.maxY - (y / outHeight) * (mercBounds.maxY - mercBounds.minY);
                    
                    const lon = mercatorXToLon(mercX);
                    const lat = mercatorYToLat(mercY);
                    
                    const scan = latLonToScan(lat, lon, sat_lon);
                    if (!scan) continue;
                    
                    const srcX = centerX + scan.x * scale;
                    const srcY = centerY - scan.y * scale;
                    
                    if (srcX < 0 || srcX >= img.width - 1 || srcY < 0 || srcY >= img.height - 1) continue;
                    
                    let r, g, b;
                    if (settings.interpolate) {
                        const pixel = bilinearInterpolate(srcData, srcX, srcY);
                        r = pixel.r; g = pixel.g; b = pixel.b;
                    } else {
                        const sx = Math.floor(srcX);
                        const sy = Math.floor(srcY);
                        const srcIdx = (sy * srcData.width + sx) * 4;
                        r = srcData.data[srcIdx];
                        g = srcData.data[srcIdx + 1];
                        b = srcData.data[srcIdx + 2];
                    }
                    
                    const idx = (y * outWidth + x) * 4;
                    outData.data[idx] = r;
                    outData.data[idx + 1] = g;
                    outData.data[idx + 2] = b;
                    outData.data[idx + 3] = 255;
                    pixelsVisible++;
                }
                
                // Atualizar progresso
                if (y % 50 === 0) {
                    setReprojectionProgress(35 + (y / outHeight) * 60, `Reprojetando... ${Math.round(y / outHeight * 100)}%`);
                    await sleep(1);
                }
            }
            
            log('info', `üìä Reproje√ß√£o completa: ${pixelsVisible} pixels`);
            setReprojectionProgress(95, 'Finalizando...');
            
            ctx.putImageData(outData, 0, 0);
            
            // Criar overlay (em mem√≥ria primeiro)
            const dataUrl = canvas.toDataURL('image/png');
            const leafletBounds = [[bounds.south, bounds.west], [bounds.north, bounds.east]];
            
            // Criar nova camada em background
            const newLayer = L.imageOverlay(dataUrl, leafletBounds, {
                opacity: opacity,
                zIndex: 1
            });
            
            // Pr√©-carregar imagem antes de exibir
            const preloadImg = new Image();
            preloadImg.src = dataUrl;
            await new Promise((resolve) => {
                preloadImg.onload = resolve;
                preloadImg.onerror = resolve;
            });
            
            // Capturar timestamp da imagem
            const imageTimestamp = new Date();
            try {
                const serverTs = await checkSatelliteTimestamp(satId, product);
                if (serverTs) currentSatelliteTimestamp = serverTs;
                else currentSatelliteTimestamp = imageTimestamp;
            } catch (e) {
                currentSatelliteTimestamp = imageTimestamp;
            }
            
            // AGORA sim: remover camada antiga e adicionar nova (troca suave)
            if (satelliteLayer) {
                map.removeLayer(satelliteLayer);
            }
            satelliteLayer = newLayer;
            satelliteLayer.addTo(map);
            
            setReprojectionProgress(100, 'Conclu√≠do!');
            setTimeout(hideReprojectionProgress, 1000);
            
            // Atualizar info com timestamp do arquivo
            const infoEl = document.getElementById('satellite-info');
            const timestampStr = currentSatelliteTimestamp ? 
                currentSatelliteTimestamp.toLocaleString('pt-BR', { 
                    day: '2-digit', month: '2-digit', year: 'numeric',
                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                }) : 'N/A';
            if (infoEl) {
                infoEl.innerHTML = `üì° ${satId.toUpperCase()} ${product}<br>üîÑ Reproje√ß√£o REAL (${quality})<br>üìä ${pixelsVisible.toLocaleString()} pixels<br>üïê Arquivo: ${timestampStr}<br>‚è∞ Carregado: ${new Date().toLocaleTimeString()}`;
            }
            
            log('success', `‚úÖ Reproje√ß√£o conclu√≠da: ${satId.toUpperCase()} ${product}`);
            log('info', `üïê Hor√°rio do arquivo: ${timestampStr}`);
            setStatus('satellite-status', 'active');
            isLoadingSatellite = false;  // Liberar flag
            
        } catch (error) {
            log('error', `‚ùå Erro: ${error.message}`);
            console.error('‚ùå [REPROJECTION] Erro:', error);
            setStatus('satellite-status', 'error');
            hideReprojectionProgress();
            isLoadingSatellite = false;  // Liberar flag em caso de erro
        }
    }
    
    // Fun√ß√£o legada para compatibilidade - carrega s√≥ se necess√°rio ou se n√£o tiver imagem
    async function loadSatelliteLayer() {
        // Na inicializa√ß√£o, carregar se n√£o tiver imagem
        if (!satelliteLayer) {
            await loadSatelliteWithReprojection(true);
        } else {
            // Verificar se h√° imagem mais recente
            await loadSatelliteWithReprojection(false);
        }
    }
    
    function updateSatelliteOpacity(value) {
        document.getElementById('opacity-value').textContent = value + '%';
        if (satelliteLayer) {
            satelliteLayer.setOpacity(value / 100);
        }
    }
    
    function toggleSatelliteLayer() {
        satelliteEnabled = !satelliteEnabled;
        if (satelliteEnabled) {
            loadSatelliteLayer();
            log('info', 'üõ∞Ô∏è Camada de sat√©lite ativada');
        } else {
            if (satelliteLayer) map.removeLayer(satelliteLayer);
            setStatus('satellite-status', '');
            log('info', 'üõ∞Ô∏è Camada de sat√©lite desativada');
        }
    }
    
    // =========================================================================
    // GRADE DE COORDENADAS
    // =========================================================================
    function createGrid() {
        for (let lat = -30; lat <= -15; lat += 1) {
            L.polyline([[lat, CONFIG.lonMin - 2], [lat, CONFIG.lonMax + 2]], {
                color: '#333',
                weight: 1,
                opacity: 0.5
            }).addTo(gridLayer);
            
            L.marker([lat, CONFIG.lonMin - 1], {
                icon: L.divIcon({
                    className: 'grid-label',
                    html: `<span style="color:#666;font-size:10px">${lat}¬∞</span>`
                })
            }).addTo(gridLayer);
        }
        
        for (let lon = -50; lon <= -35; lon += 1) {
            L.polyline([[CONFIG.latMin - 2, lon], [CONFIG.latMax + 2, lon]], {
                color: '#333',
                weight: 1,
                opacity: 0.5
            }).addTo(gridLayer);
        }
    }
    
    // =========================================================================
    // TOGGLE DE CAMADAS
    // =========================================================================
    function toggleLayer(layer) {
        const checkbox = document.getElementById(`layer-${layer}`);
        switch(layer) {
            case 'arrows':
                if (checkbox.checked) windLayerGroup.addTo(map);
                else map.removeLayer(windLayerGroup);
                break;
            case 'grid':
                if (checkbox.checked) gridLayer.addTo(map);
                else map.removeLayer(gridLayer);
                break;
        }
    }
    
    // =========================================================================
    // BUSCAR DADOS - NOAA ERDDAP (GRATUITO!)
    // =========================================================================
    
    // Lista de datasets NOAA ERDDAP dispon√≠veis (em ordem de prefer√™ncia)
    const NOAA_DATASETS = [
        {
            id: 'erdQCwindproducts1day',
            name: 'MetOp-C ASCAT 1-Day (2020-presente)',
            vars: ['wind_speed', 'wind_direction']
        },
        {
            id: 'erdQCwindproducts3day',
            name: 'MetOp-C ASCAT 3-Day Composite',
            vars: ['wind_speed', 'wind_direction']
        },
        {
            id: 'erdNavgem05D10mWind',
            name: 'NAVGEM 0.5¬∞ 10m Wind (modelo)',
            vars: ['u_wind', 'v_wind']
        }
    ];
    
    async function fetchNOAAData() {
        setStatus('noaa-status', 'loading');
        log('info', 'üì° Buscando dados NOAA ERDDAP (ASCAT Metop-C)...');
        
        const baseUrl = 'https://coastwatch.pfeg.noaa.gov/erddap/griddap';
        
        // Tentar datasets em ordem de prefer√™ncia
        for (const dataset of NOAA_DATASETS) {
            log('info', `üîç Tentando: ${dataset.name}...`);
            
            // Dados de sat√©lite t√™m atraso de ~24h no processamento
            // Buscar de 4 dias atr√°s at√© 1 dia atr√°s
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000);
            const fourDaysAgo = new Date(now.getTime() - 4 * 24 * 60 * 60 * 1000);
            
            const startTime = fourDaysAgo.toISOString().split('.')[0] + 'Z';
            const endTime = oneDayAgo.toISOString().split('.')[0] + 'Z';
            
            // Construir URL baseado nas vari√°veis do dataset
            // Nota: erdQCwindproducts tem dimens√£o altitude (10m)
            let erddapUrl;
            if (dataset.vars.includes('wind_speed')) {
                // Dataset com wind_speed e wind_direction diretos (com altitude)
                erddapUrl = `${baseUrl}/${dataset.id}.json?` +
                    `wind_speed[(${startTime}):1:(${endTime})]` +
                    `[(10.0)]` +  // altitude 10m
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]` +
                    `,wind_direction[(${startTime}):1:(${endTime})]` +
                    `[(10.0)]` +  // altitude 10m
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]`;
            } else {
                // Dataset com componentes u/v (pode ter altitude ou n√£o)
                erddapUrl = `${baseUrl}/${dataset.id}.json?` +
                    `${dataset.vars[0]}[(${startTime}):1:(${endTime})]` +
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]` +
                    `,${dataset.vars[1]}[(${startTime}):1:(${endTime})]` +
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]`;
            }
            
            try {
                // Usar proxy local para evitar CORS
                const url = `/api/noaa?url=${encodeURIComponent(erddapUrl)}`;
                log('info', 'Buscando via proxy local...');
                
                const response = await fetch(url, { timeout: 30000 });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    log('warning', `Dataset ${dataset.id} indispon√≠vel: ${response.status} - ${errorData.reason || ''}`);
                    continue; // Tentar pr√≥ximo dataset
                }
                
                const data = await response.json();
                
                // Verificar se h√° dados v√°lidos
                if (data && data.table && data.table.rows && data.table.rows.length > 0) {
                    log('success', `‚úÖ Dados obtidos de ${dataset.name}: ${data.table.rows.length} pontos`);
                    processNOAAData(data, dataset.vars.includes('wind_speed'));
                    setStatus('noaa-status', 'active');
                    return; // Sucesso!
                } else {
                    log('warning', `Dataset ${dataset.id} sem dados para a √°rea/per√≠odo`);
                }
                
            } catch (error) {
                log('warning', `Erro no dataset ${dataset.id}: ${error.message}`);
                continue; // Tentar pr√≥ximo
            }
        }
        
        // Se todos falharam, usar Open-Meteo como fallback
        log('warning', '‚ö†Ô∏è Nenhum dataset NOAA dispon√≠vel, usando Open-Meteo como fallback');
        setStatus('noaa-status', 'error');
        await fetchOpenMeteoWindGrid();
    }
    
    // Fallback: buscar grid de vento do Open-Meteo
    async function fetchOpenMeteoWindGrid() {
        log('info', 'üîÑ Buscando grid de vento Open-Meteo...');
        
        // Criar grid de pontos na √°rea
        const lats = [];
        const lons = [];
        const step = 0.5;
        
        for (let lat = CONFIG.latMin; lat <= CONFIG.latMax; lat += step) {
            lats.push(lat.toFixed(2));
        }
        for (let lon = CONFIG.lonMin; lon <= CONFIG.lonMax; lon += step) {
            lons.push(lon.toFixed(2));
        }
        
        // Criar todas as combina√ß√µes
        const queryLats = [];
        const queryLons = [];
        for (const lat of lats) {
            for (const lon of lons) {
                queryLats.push(lat);
                queryLons.push(lon);
            }
        }
        
        // Limitar a 50 pontos (limite da API)
        const maxPoints = 50;
        const selectedLats = queryLats.slice(0, maxPoints);
        const selectedLons = queryLons.slice(0, maxPoints);
        
        const url = `https://api.open-meteo.com/v1/forecast?` +
            `latitude=${selectedLats.join(',')}&` +
            `longitude=${selectedLons.join(',')}&` +
            `current=wind_speed_10m,wind_direction_10m&` +
            `wind_speed_unit=kn`;
        
        try {
            const response = await fetch(url);
            const data = await response.json();
            
            let count = 0;
            if (Array.isArray(data)) {
                data.forEach(point => {
                    if (point.current) {
                        addWindPoint({
                            lat: point.latitude,
                            lon: point.longitude,
                            speed: point.current.wind_speed_10m,
                            direction: point.current.wind_direction_10m,
                            time: new Date(),
                            source: 'Open-Meteo Grid'
                        });
                        count++;
                    }
                });
            } else if (data.current) {
                addWindPoint({
                    lat: data.latitude,
                    lon: data.longitude,
                    speed: data.current.wind_speed_10m,
                    direction: data.current.wind_direction_10m,
                    time: new Date(),
                    source: 'Open-Meteo Grid'
                });
                count = 1;
            }
            
            log('success', `‚úÖ Grid Open-Meteo: ${count} pontos`);
            updateWindDisplay();
            setStatus('noaa-status', 'active');
            
        } catch (error) {
            log('error', `Erro Open-Meteo Grid: ${error.message}`);
        }
    }
    
    // =========================================================================
    // OPEN-METEO (MULTI-MODELO) COM PESOS DIN√ÇMICOS
    // =========================================================================
    
    // Lista de modelos dispon√≠veis
    const MODELS = ['gfs_seamless', 'ecmwf_ifs025', 'icon_seamless', 'meteofrance_seamless', 'jma_seamless'];
    const MODEL_NAMES = {
        'gfs_seamless': 'GFS',
        'ecmwf_ifs025': 'ECMWF', 
        'icon_seamless': 'ICON',
        'meteofrance_seamless': 'MeteoFR',
        'jma_seamless': 'JMA'
    };
    
    // Armazena dados de todos os modelos
    let modelData = {};
    MODELS.forEach(m => modelData[m] = { speed: null, direction: null });
    
    // Pesos din√¢micos (iniciam iguais)
    let modelWeights = {};
    MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
    
    // Hist√≥rico de previs√µes para compara√ß√£o
    let forecastHistory = [];
    
    // Carregar hist√≥rico do localStorage
    function loadForecastHistory() {
        try {
            const saved = localStorage.getItem('forecastHistoryMulti');
            if (saved) {
                forecastHistory = JSON.parse(saved);
                const cutoff = Date.now() - 24 * 60 * 60 * 1000;
                forecastHistory = forecastHistory.filter(h => h.timestamp > cutoff);
                log('info', `üìä Hist√≥rico carregado: ${forecastHistory.length} registros`);
                calculateDynamicWeights();
            }
        } catch (e) {
            forecastHistory = [];
        }
    }
    
    function saveForecastHistory() {
        try {
            localStorage.setItem('forecastHistoryMulti', JSON.stringify(forecastHistory));
        } catch (e) {}
    }
    
    function directionError(predicted, actual) {
        if (predicted === null || actual === null) return 180;
        let diff = Math.abs(predicted - actual);
        if (diff > 180) diff = 360 - diff;
        return diff;
    }
    
    // Calcular pesos baseado no erro hist√≥rico de TODOS os modelos
    function calculateDynamicWeights() {
        if (forecastHistory.length < 2) {
            MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
            const weightReasonEl = document.getElementById('weight-reason');
            if (weightReasonEl) weightReasonEl.textContent = 'Pesos iguais (hist√≥rico insuficiente)';
            return;
        }
        
        let modelErrors = {};
        MODELS.forEach(m => modelErrors[m] = 0);
        let comparisons = 0;
        
        for (let i = 1; i < forecastHistory.length; i++) {
            const prev = forecastHistory[i - 1];
            const curr = forecastHistory[i];
            
            MODELS.forEach(model => {
                if (prev[model] && curr[model] && prev[model].speed !== null && curr[model].speed !== null) {
                    const speedErr = Math.abs(prev[model].speed - curr[model].speed) / 20;
                    const dirErr = directionError(prev[model].direction, curr[model].direction) / 180;
                    modelErrors[model] += (speedErr + dirErr) / 2;
                }
            });
            comparisons++;
        }
        
        if (comparisons === 0) {
            MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
            return;
        }
        
        // Normalizar erros
        MODELS.forEach(m => modelErrors[m] /= comparisons);
        
        // Converter erros em pesos (menor erro = maior peso)
        let totalInvError = 0;
        MODELS.forEach(m => {
            const invErr = 1 / (modelErrors[m] + 0.01); // +0.01 para evitar divis√£o por zero
            modelWeights[m] = invErr;
            totalInvError += invErr;
        });
        
        // Normalizar pesos
        MODELS.forEach(m => modelWeights[m] /= totalInvError);
        
        // Limitar entre 5% e 40%
        MODELS.forEach(m => {
            modelWeights[m] = Math.max(0.05, Math.min(0.40, modelWeights[m]));
        });
        
        // Renormalizar
        let sum = 0;
        MODELS.forEach(m => sum += modelWeights[m]);
        MODELS.forEach(m => modelWeights[m] /= sum);
        
        // Encontrar melhor modelo
        let bestModel = MODELS[0];
        let lowestError = modelErrors[MODELS[0]];
        MODELS.forEach(m => {
            if (modelErrors[m] < lowestError) {
                lowestError = modelErrors[m];
                bestModel = m;
            }
        });
        
        const weightReasonEl = document.getElementById('weight-reason');
        if (weightReasonEl) {
            weightReasonEl.innerHTML = 
                `‚öñÔ∏è ${comparisons} compara√ß√µes | Melhor: <span style="color:#00ff00;">${MODEL_NAMES[bestModel]}</span>`;
        }
        
        log('info', `‚öñÔ∏è Pesos: ${MODELS.map(m => MODEL_NAMES[m] + ':' + (modelWeights[m]*100).toFixed(0) + '%').join(' | ')}`);
    }
    
    function addToForecastHistory(data) {
        const record = { timestamp: Date.now() };
        MODELS.forEach(m => {
            record[m] = data[m] ? { speed: data[m].speed, direction: data[m].direction } : { speed: null, direction: null };
        });
        
        forecastHistory.push(record);
        if (forecastHistory.length > 96) forecastHistory = forecastHistory.slice(-96);
        
        saveForecastHistory();
        calculateDynamicWeights();
    }
    
    async function fetchOpenMeteoData() {
        setStatus('openmeteo-status', 'loading');
        log('info', 'üåê Buscando 5 modelos (Open-Meteo)...');
        console.log('[OpenMeteo] Iniciando busca de dados de vento...');
        
        try {
            if (forecastHistory.length === 0) loadForecastHistory();
            
            // Limpar dados anteriores
            windDataPoints = windDataPoints.filter(p => 
                !p.source.includes('GFS') && !p.source.includes('ECMWF') && 
                !p.source.includes('ICON') && !p.source.includes('MeteoFR') && 
                !p.source.includes('JMA') && p.source !== 'Open-Meteo'
            );
            
            // Usar endpoint /forecast com par√¢metro models para todos
            // Isso garante dados 'current' dispon√≠veis para todos os modelos
            let successCount = 0;
            const promises = MODELS.map(async model => {
                try {
                    // Endpoint unificado com par√¢metro models
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.shipLat}&longitude=${CONFIG.shipLon}&current=wind_speed_10m,wind_direction_10m&models=${model}&wind_speed_unit=kn`;
                    console.log(`[OpenMeteo] Buscando ${model}: ${url}`);
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    console.log(`[OpenMeteo] ${model} resposta:`, data);
                    
                    if (data.current && data.current.wind_speed_10m !== undefined) {
                        modelData[model] = {
                            speed: data.current.wind_speed_10m,
                            direction: data.current.wind_direction_10m
                        };
                        successCount++;
                        log('info', `  ‚úì ${MODEL_NAMES[model]}: ${data.current.wind_speed_10m.toFixed(1)} kn`);
                    } else if (data.error) {
                        log('warning', `  ‚úó ${MODEL_NAMES[model]}: ${data.reason || data.error}`);
                        console.error(`[OpenMeteo] ${model} erro:`, data);
                    } else {
                        log('warning', `  ‚úó ${MODEL_NAMES[model]}: sem dados current`);
                    }
                } catch (e) {
                    console.error(`[OpenMeteo] ${model} exce√ß√£o:`, e);
                    log('warning', `  ‚úó ${MODEL_NAMES[model]}: ${e.message}`);
                }
            });
            
            await Promise.all(promises);
            
            // Adicionar ao hist√≥rico
            addToForecastHistory(modelData);
            
            // Atualizar display
            updateModelAverage();
            
            // Carregar previs√£o hor√°ria
            await fetchForecastData();
            
            updateWindDisplay();
            setStatus('openmeteo-status', 'active');
            
            const activeModels = MODELS.filter(m => modelData[m].speed !== null).length;
            log('success', `‚úÖ ${activeModels} modelos carregados - Pr√≥xima atualiza√ß√£o em 15 min`);
            
        } catch (error) {
            log('error', '‚ùå Erro: ' + error.message);
            setStatus('openmeteo-status', 'error');
        }
    }
    
    // =========================================================================
    // SISTEMA DE PREVIS√ÉO MULTI-MODELO (24h/48h/72h)
    // =========================================================================
    let forecastPeriod = 24;  // Per√≠odo selecionado (24, 48, 72)
    let forecastHour = 0;     // Hora selecionada dentro do per√≠odo
    let allForecastData = {}; // Dados de previs√£o de todos os modelos
    let forecastRefreshInterval = null;
    
    function selectForecastPeriod(period) {
        forecastPeriod = period;
        forecastHour = 0;  // Reset para primeira hora
        
        // Atualizar bot√µes
        document.querySelectorAll('.forecast-period-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Reconstruir timeline
        buildForecastTimeline();
        
        // Recarregar dados
        fetchForecastData();
        
        log('info', `üìÖ Per√≠odo de previs√£o: ${period}h`);
    }
    
    // Fun√ß√£o para obter classe de cor baseada na velocidade do vento (em kn)
    // Escala ajustada: amarelo > 25kn, vermelho > 35kn
    function getWindColorClass(speed) {
        if (speed < 10) return 'wind-calm';       // Verde escuro: 0-10 kn
        if (speed < 15) return 'wind-light';      // Verde claro: 10-15 kn
        if (speed < 20) return 'wind-moderate';   // Verde-amarelo: 15-20 kn
        if (speed < 25) return 'wind-fresh';      // Amarelo esverdeado: 20-25 kn
        if (speed < 30) return 'wind-strong';     // Amarelo: 25-30 kn
        if (speed < 35) return 'wind-gale';       // Laranja: 30-35 kn
        if (speed < 45) return 'wind-storm';      // Vermelho: 35-45 kn
        return 'wind-violent';                    // Roxo: > 45 kn
    }
    
    // Fun√ß√£o para obter seta de dire√ß√£o
    function getDirectionArrow(deg) {
        const arrows = ['‚Üì', '‚Üô', '‚Üê', '‚Üñ', '‚Üë', '‚Üó', '‚Üí', '‚Üò'];
        const index = Math.round(deg / 45) % 8;
        return arrows[index];
    }
    
    function buildForecastTimeline() {
        const hoursContainer = document.getElementById('forecast-hours');
        const windsContainer = document.getElementById('forecast-winds');
        const gustsContainer = document.getElementById('forecast-gusts');
        const dirsContainer = document.getElementById('forecast-dirs');
        
        if (!hoursContainer || !windsContainer || !gustsContainer || !dirsContainer) {
            console.warn('[buildForecastTimeline] Containers n√£o encontrados');
            return;
        }
        
        hoursContainer.innerHTML = '';
        windsContainer.innerHTML = '';
        gustsContainer.innerHTML = '';
        dirsContainer.innerHTML = '';
        
        // Intervalo baseado no per√≠odo
        let interval;
        if (forecastPeriod === 24) interval = 1;
        else if (forecastPeriod === 48) interval = 3;
        else interval = 6;
        
        const now = new Date();
        
        for (let h = 0; h <= forecastPeriod; h += interval) {
            const forecastTime = new Date(now.getTime() + h * 60 * 60 * 1000);
            const hourNum = forecastTime.getHours();
            
            // C√©lula de Hora
            const hourCell = document.createElement('div');
            hourCell.className = 'forecast-cell hour';
            hourCell.textContent = hourNum;
            hourCell.dataset.hour = h;
            hourCell.onclick = function() { selectForecastHour(parseInt(this.dataset.hour), this); };
            hoursContainer.appendChild(hourCell);
            
            // Calcular dados para esta hora (m√©dia ponderada)
            const hourData = calculateHourData(h);
            
            // C√©lula de Vento
            const windCell = document.createElement('div');
            windCell.className = 'forecast-cell ' + getWindColorClass(hourData.speed);
            windCell.textContent = hourData.speed !== null ? Math.round(hourData.speed) : '--';
            windCell.dataset.hour = h;
            windCell.onclick = function() { selectForecastHour(parseInt(this.dataset.hour), this); };
            windsContainer.appendChild(windCell);
            
            // C√©lula de Rajada
            const gustCell = document.createElement('div');
            gustCell.className = 'forecast-cell ' + getWindColorClass(hourData.gust);
            gustCell.textContent = hourData.gust !== null ? Math.round(hourData.gust) : '--';
            gustCell.dataset.hour = h;
            gustCell.onclick = function() { selectForecastHour(parseInt(this.dataset.hour), this); };
            gustsContainer.appendChild(gustCell);
            
            // C√©lula de Dire√ß√£o (valor num√©rico em graus)
            const dirCell = document.createElement('div');
            dirCell.className = 'forecast-cell direction';
            dirCell.textContent = hourData.dir !== null ? Math.round(hourData.dir) + '¬∞' : '--';
            dirCell.dataset.hour = h;
            dirCell.onclick = function() { selectForecastHour(parseInt(this.dataset.hour), this); };
            dirsContainer.appendChild(dirCell);
        }
        
        // Selecionar primeira hora por padr√£o
        selectForecastHour(0, document.querySelector('.forecast-cell.hour'));
    }
    
    // Calcular dados de uma hora espec√≠fica (m√©dia ponderada)
    function calculateHourData(hourOffset) {
        // hourOffset √© o offset em horas (0, 1, 2, 3... ou 0, 3, 6... dependendo do per√≠odo)
        // Os dados da API v√™m em intervalos de 1 hora, ent√£o usamos hourOffset diretamente
        const hourIndex = hourOffset;
        
        let availableModels = [];
        let totalWeight = 0;
        
        MODELS.forEach(model => {
            const data = allForecastData[model];
            if (data && data.speeds && data.speeds[hourIndex] !== null && data.speeds[hourIndex] !== undefined) {
                availableModels.push(model);
                totalWeight += modelWeights[model];
            }
        });
        
        if (availableModels.length === 0) {
            return { speed: null, gust: null, dir: null };
        }
        
        let normalizedWeights = {};
        availableModels.forEach(model => {
            normalizedWeights[model] = modelWeights[model] / totalWeight;
        });
        
        let weightedSpeed = 0;
        let weightedGust = 0;
        let weightedDirX = 0;
        let weightedDirY = 0;
        
        availableModels.forEach(model => {
            const data = allForecastData[model];
            const weight = normalizedWeights[model];
            
            const speed = data.speeds[hourIndex];
            const dir = data.directions[hourIndex];
            // Verificar se gust existe E tem valor v√°lido para esta hora
            let gust = null;
            if (data.gusts && data.gusts[hourIndex] !== null && data.gusts[hourIndex] !== undefined) {
                gust = data.gusts[hourIndex];
            } else {
                // Fallback: estimar rajada como 30% maior que velocidade
                gust = speed * 1.3;
            }
            
            weightedSpeed += speed * weight;
            weightedGust += gust * weight;
            
            const rad = dir * Math.PI / 180;
            weightedDirX += Math.cos(rad) * weight;
            weightedDirY += Math.sin(rad) * weight;
        });
        
        let avgDir = Math.atan2(weightedDirY, weightedDirX) * 180 / Math.PI;
        if (avgDir < 0) avgDir += 360;
        
        return { speed: weightedSpeed, gust: weightedGust, dir: avgDir };
    }
    
    function selectForecastHour(hour, btnElement) {
        forecastHour = hour;
        
        // Remover sele√ß√£o de todas as c√©lulas
        document.querySelectorAll('.forecast-cell').forEach(cell => {
            cell.classList.remove('selected');
        });
        
        // Marcar todas as c√©lulas da coluna selecionada
        document.querySelectorAll(`.forecast-cell[data-hour="${hour}"]`).forEach(cell => {
            cell.classList.add('selected');
        });
        
        // Atualizar display com dados do hor√°rio selecionado
        updateForecastDisplay();
    }
    
    async function fetchForecastData() {
        log('info', `üåä Buscando previs√£o ${forecastPeriod}h (5 modelos)...`);
        
        try {
            // Limpar dados anteriores
            allForecastData = {};
            
            // Buscar dados de todos os modelos
            const promises = MODELS.map(async model => {
                try {
                    // Calcular horas necess√°rias
                    const hours = [];
                    let interval = forecastPeriod === 24 ? 1 : (forecastPeriod === 48 ? 3 : 6);
                    for (let h = 0; h <= forecastPeriod; h += interval) {
                        hours.push(h);
                    }
                    
                    const url = `https://api.open-meteo.com/v1/forecast?` +
                        `latitude=${CONFIG.shipLat}&longitude=${CONFIG.shipLon}&` +
                        `hourly=wind_speed_10m,wind_direction_10m,wind_gusts_10m&` +
                        `models=${model}&wind_speed_unit=kn&` +
                        `forecast_hours=${forecastPeriod + 1}`;
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.hourly) {
                        allForecastData[model] = {
                            times: data.hourly.time,
                            speeds: data.hourly.wind_speed_10m,
                            directions: data.hourly.wind_direction_10m,
                            gusts: data.hourly.wind_gusts_10m
                        };
                        log('info', `  ‚úì ${MODEL_NAMES[model]}: ${data.hourly.time.length} horas`);
                    }
                } catch (e) {
                    log('warning', `  ‚úó ${MODEL_NAMES[model]}: ${e.message}`);
                }
            });
            
            await Promise.all(promises);
            
            // Reconstruir tabela com dados atualizados
            buildForecastTimeline();
            
            // Atualizar display da hora selecionada
            updateForecastDisplay();
            
            // Atualizar status
            const now = new Date();
            const nextUpdate = new Date(now.getTime() + 15 * 60 * 1000);
            const forecastStatusEl = document.getElementById('forecast-status');
            if (forecastStatusEl) {
                forecastStatusEl.textContent = 
                    `‚è∞ ${nextUpdate.toLocaleTimeString('pt-BR', {hour:'2-digit', minute:'2-digit'})}`;
            }
            
            log('success', `‚úÖ Previs√£o ${forecastPeriod}h carregada`);
            
        } catch (error) {
            log('error', `‚ùå Erro previs√£o: ${error.message}`);
        }
    }
    
    function updateForecastDisplay() {
        // Calcular √≠ndice da hora no array
        const interval = forecastPeriod === 24 ? 1 : (forecastPeriod === 48 ? 3 : 6);
        const hourIndex = forecastHour;  // Index direto para dados hourly (0, 1, 2, ...)
        
        // =====================================================================
        // M√âDIA PONDERADA DIN√ÇMICA - MESMO M√âTODO DO PAINEL PRINCIPAL
        // =====================================================================
        // Passo 1: Identificar quais modelos t√™m dados para este hor√°rio
        let availableModels = [];
        let totalWeight = 0;
        
        MODELS.forEach(model => {
            const data = allForecastData[model];
            if (data && data.speeds && data.speeds[hourIndex] !== null && data.speeds[hourIndex] !== undefined) {
                availableModels.push(model);
                totalWeight += modelWeights[model];
            }
        });
        
        if (availableModels.length === 0) {
            const fSpeed = document.getElementById('forecast-speed');
            const fDir = document.getElementById('forecast-dir');
            const fGust = document.getElementById('forecast-gust');
            if (fSpeed) fSpeed.textContent = '--';
            if (fDir) fDir.textContent = '--';
            if (fGust) fGust.textContent = '--';
            return;
        }
        
        // Passo 2: Renormalizar pesos para os modelos dispon√≠veis (soma = 1)
        let normalizedWeights = {};
        availableModels.forEach(model => {
            normalizedWeights[model] = modelWeights[model] / totalWeight;
        });
        
        // Passo 3: Calcular m√©dia ponderada
        let weightedSpeed = 0;
        let weightedGust = 0;
        let weightedDirX = 0;
        let weightedDirY = 0;
        
        availableModels.forEach(model => {
            const data = allForecastData[model];
            const weight = normalizedWeights[model];
            
            const speed = data.speeds[hourIndex];
            const dir = data.directions[hourIndex];
            // Verificar se gust existe E tem valor v√°lido para esta hora
            let gust = null;
            if (data.gusts && data.gusts[hourIndex] !== null && data.gusts[hourIndex] !== undefined) {
                gust = data.gusts[hourIndex];
            } else {
                // Fallback: estimar rajada como 30% maior que velocidade
                gust = speed * 1.3;
            }
            
            weightedSpeed += speed * weight;
            weightedGust += gust * weight;
            
            // Dire√ß√£o: usar componentes vetoriais para m√©dia correta
            const rad = dir * Math.PI / 180;
            weightedDirX += Math.cos(rad) * weight;
            weightedDirY += Math.sin(rad) * weight;
        });
        
        // Calcular dire√ß√£o resultante
        let avgDir = Math.atan2(weightedDirY, weightedDirX) * 180 / Math.PI;
        if (avgDir < 0) avgDir += 360;
        
        // Calcular hor√°rio da previs√£o
        const now = new Date();
        const forecastTime = new Date(now.getTime() + forecastHour * 60 * 60 * 1000);
        const dateTimeStr = forecastTime.toLocaleString('pt-BR', { 
            day: '2-digit', month: '2-digit', 
            hour: '2-digit', minute: '2-digit' 
        });
        
        // Atualizar display
        const fDatetime = document.getElementById('forecast-datetime');
        const fSpeed = document.getElementById('forecast-speed');
        const fDir = document.getElementById('forecast-dir');
        const fGust = document.getElementById('forecast-gust');
        
        if (fDatetime) fDatetime.textContent = dateTimeStr;
        if (fSpeed) fSpeed.textContent = weightedSpeed.toFixed(1);
        if (fDir) fDir.textContent = avgDir.toFixed(0) + '¬∞';
        if (fGust) fGust.textContent = weightedGust.toFixed(1);
        
        // Atualizar pesos na interface
        const uiMap = {
            'gfs_seamless': 'gfs',
            'ecmwf_ifs025': 'ecmwf',
            'icon_seamless': 'icon',
            'meteofrance_seamless': 'meteofr',
            'jma_seamless': 'jma'
        };
        
        MODELS.forEach(model => {
            const uiKey = uiMap[model];
            const el = document.getElementById(`fw-${uiKey}`);
            if (el) {
                if (normalizedWeights[model] !== undefined) {
                    el.textContent = (normalizedWeights[model] * 100).toFixed(0) + '%';
                    el.style.fontWeight = 'bold';
                } else {
                    el.textContent = '--';
                    el.style.fontWeight = 'normal';
                }
            }
        });
        
        // Log para debug (apenas quando muda de hora)
        if (hourIndex === 0) {
            const weightsStr = availableModels.map(m => 
                `${MODEL_NAMES[m]}:${(normalizedWeights[m]*100).toFixed(0)}%`
            ).join(' | ');
            log('info', `üìä Previs√£o h+${forecastHour}: ${weightedSpeed.toFixed(1)}kn ${avgDir.toFixed(0)}¬∞ [${weightsStr}]`);
        }
    }
    
    // Iniciar atualiza√ß√£o autom√°tica de previs√£o a cada 15 minutos
    function startForecastAutoRefresh() {
        if (forecastRefreshInterval) clearInterval(forecastRefreshInterval);
        
        forecastRefreshInterval = setInterval(() => {
            log('info', '‚è∞ Atualizando previs√£o (15 min)...');
            fetchForecastData();
        }, 15 * 60 * 1000);  // 15 minutos
    }
    
    // Construir timeline inicial
    buildForecastTimeline();
    startForecastAutoRefresh();
    
    function updateModelAverage() {
        // Atualizar valores individuais na UI
        const uiMap = {
            'gfs_seamless': 'gfs',
            'ecmwf_ifs025': 'ecmwf',
            'icon_seamless': 'icon',
            'meteofrance_seamless': 'meteofr',
            'jma_seamless': 'jma'
        };
        
        console.log('[updateModelAverage] modelData:', JSON.stringify(modelData));
        
        let validModels = 0;
        let weightedSpeed = 0;
        let weightedDirX = 0;
        let weightedDirY = 0;
        
        MODELS.forEach(model => {
            const uiKey = uiMap[model];
            const data = modelData[model];
            const weight = modelWeights[model];
            
            console.log(`[updateModelAverage] ${model}: speed=${data?.speed}, dir=${data?.direction}`);
            
            // Atualizar UI (se elementos existirem)
            const valEl = document.getElementById(`${uiKey}-value`);
            const weightEl = document.getElementById(`${uiKey}-weight`);
            
            if (data && data.speed !== null) {
                if (valEl) valEl.textContent = `${data.speed.toFixed(1)} kn / ${data.direction.toFixed(0)}¬∞`;
                if (weightEl) weightEl.textContent = `(${(weight * 100).toFixed(0)}%)`;
                
                // Acumular para m√©dia ponderada
                weightedSpeed += data.speed * weight;
                const rad = data.direction * Math.PI / 180;
                weightedDirX += Math.cos(rad) * weight;
                weightedDirY += Math.sin(rad) * weight;
                validModels++;
            } else {
                if (valEl) valEl.textContent = '--';
                if (weightEl) weightEl.textContent = '';
            }
        });
        
        // Calcular m√©dia ponderada
        if (validModels > 0) {
            let avgDir = Math.atan2(weightedDirY, weightedDirX) * 180 / Math.PI;
            if (avgDir < 0) avgDir += 360;
            
            const avgSpeedEl = document.getElementById('avg-model-speed');
            const avgDirEl = document.getElementById('avg-model-dir');
            if (avgSpeedEl) avgSpeedEl.textContent = weightedSpeed.toFixed(1);
            if (avgDirEl) avgDirEl.textContent = avgDir.toFixed(0) + '¬∞';
            
            log('info', `üåç M√©dia Ponderada (${validModels} modelos): ${weightedSpeed.toFixed(1)} kn de ${avgDir.toFixed(0)}¬∞`);
        }
    }
    
    function clearOpenMeteoData() {
        windDataPoints = windDataPoints.filter(p => 
            !p.source.includes('GFS') && !p.source.includes('ECMWF') && 
            !p.source.includes('ICON') && p.source !== 'Open-Meteo'
        );
        MODELS.forEach(m => modelData[m] = { speed: null, direction: null });
        allForecastData = {};
        
        const avgSpeedEl = document.getElementById('avg-model-speed');
        const avgDirEl = document.getElementById('avg-model-dir');
        const forecastSpeedEl = document.getElementById('forecast-speed');
        const forecastDirEl = document.getElementById('forecast-dir');
        const forecastGustEl = document.getElementById('forecast-gust');
        
        if (avgSpeedEl) avgSpeedEl.textContent = '--';
        if (avgDirEl) avgDirEl.textContent = '--';
        if (forecastSpeedEl) forecastSpeedEl.textContent = '--';
        if (forecastDirEl) forecastDirEl.textContent = '--';
        if (forecastGustEl) forecastGustEl.textContent = '--';
        
        updateWindDisplay();
        setStatus('openmeteo-status', '');
        log('info', 'üóëÔ∏è Dados de modelos removidos');
    }
    
    function processNOAAData(data, hasDirectSpeed = false) {
        if (!data.table || !data.table.rows) {
            log('warning', 'Dados NOAA vazios');
            return;
        }
        
        const rows = data.table.rows;
        const columnNames = data.table.columnNames || [];
        let count = 0;
        
        // Detectar formato das colunas
        const hasWindSpeed = columnNames.includes('wind_speed');
        const hasWindDirection = columnNames.includes('wind_direction');
        
        rows.forEach(row => {
            // Detectar estrutura baseado no n√∫mero de colunas
            // Com altitude: [time, altitude, lat, lon, wind_speed, wind_direction]
            // Sem altitude: [time, lat, lon, wind_speed, wind_direction]
            const hasAltitude = columnNames.includes('altitude');
            const offset = hasAltitude ? 1 : 0;
            
            const time = new Date(row[0]);
            const lat = row[1 + offset];
            const lon = row[2 + offset];
            
            let speed, direction;
            
            if (hasDirectSpeed || hasWindSpeed) {
                // Formato com wind_speed e wind_direction diretos
                speed = row[3 + offset];  // j√° em m/s
                direction = row[4 + offset];  // j√° em graus
                
                if (speed !== null && direction !== null) {
                    speed = speed * 1.94384;  // m/s para knots
                }
            } else {
                // Formato com componentes u/v
                const u = row[3 + offset];  // componente x
                const v = row[4 + offset];  // componente y
                
                if (u !== null && v !== null) {
                    // Calcular velocidade e dire√ß√£o
                    speed = Math.sqrt(u*u + v*v) * 1.94384;  // m/s para knots
                    direction = (Math.atan2(-u, -v) * 180 / Math.PI + 360) % 360;
                }
            }
            
            if (speed !== null && direction !== null && !isNaN(speed) && !isNaN(direction)) {
                addWindPoint({
                    lat: lat,
                    lon: lon,
                    speed: speed,
                    direction: direction,
                    time: time,
                    source: 'NOAA ASCAT'
                });
                count++;
            }
        });
        
        updateWindDisplay();
        log('success', `‚úÖ NOAA: ${count} pontos carregados`);
    }
    
    // =========================================================================
    // BUSCAR DADOS - COPERNICUS MARINE
    // =========================================================================
    async function fetchCopernicusData() {
        const user = document.getElementById('cmems-user').value;
        const pass = document.getElementById('cmems-pass').value;
        
        if (!user || !pass) {
            log('warning', 'CMEMS: Insira usu√°rio e senha');
            return;
        }
        
        setStatus('cmems-status', 'loading');
        log('info', 'Buscando dados Copernicus Marine...');
        
        // CMEMS usa WMS/WCS - precisamos de uma abordagem diferente
        // Para uso real, seria necess√°rio usar o copernicusmarine Python client
        // Aqui vamos mostrar como seria a URL
        
        const datasetId = 'WIND_GLO_PHY_L4_NRT_012_004';  // Global wind L4
        
        log('info', `Dataset: ${datasetId}`);
        log('warning', 'CMEMS requer autentica√ß√£o OAuth - use o Python client');
        log('info', 'Comando: pip install copernicusmarine');
        log('info', 'copernicusmarine subset -i ' + datasetId);
        
        // Mostrar instru√ß√µes
        alert(`Para acessar dados Copernicus Marine:

1. Instale o cliente Python:
   pip install copernicusmarine

2. Configure credenciais:
   copernicusmarine login

3. Baixe dados de vento:
   copernicusmarine subset \
     --dataset-id WIND_GLO_PHY_L4_NRT_012_004 \
     --variable eastward_wind \
     --variable northward_wind \
     --minimum-longitude ${CONFIG.lonMin} \
     --maximum-longitude ${CONFIG.lonMax} \
     --minimum-latitude ${CONFIG.latMin} \
     --maximum-latitude ${CONFIG.latMax}`);
        
        setStatus('cmems-status', 'error');
    }
    
    // =========================================================================
    // BUSCAR DADOS - NASA EARTHDATA
    // =========================================================================
    async function fetchNASAData() {
        const user = document.getElementById('nasa-user').value;
        const pass = document.getElementById('nasa-pass').value;
        
        if (!user || !pass) {
            log('warning', 'NASA: Insira usu√°rio e senha');
            return;
        }
        
        setStatus('nasa-status', 'loading');
        log('info', 'Buscando dados NASA Earthdata (CYGNSS)...');
        
        // NASA Earthdata tamb√©m requer autentica√ß√£o especial
        // CYGNSS √© um constela√ß√£o de 8 sat√©lites que mede vento oce√¢nico
        
        log('info', 'Datasets dispon√≠veis:');
        log('info', '- CYGNSS L2 Ocean Surface Wind Speed');
        log('info', '- QuikSCAT Level 2B (hist√≥rico)');
        log('info', '- RapidSCAT Level 2B (hist√≥rico)');
        
        log('warning', 'NASA Earthdata requer token de autentica√ß√£o');
        log('info', 'Use: https://search.earthdata.nasa.gov');
        
        setStatus('nasa-status', 'error');
    }
    
    // =========================================================================
    // FUN√á√ïES DE VISUALIZA√á√ÉO
    // =========================================================================
    function addWindPoint(point) {
        windDataPoints.push(point);
    }
    
    function updateWindDisplay() {
        windLayerGroup.clearLayers();
        
        if (windDataPoints.length === 0) return;
        
        const now = new Date();
        const maxAgeMs = MAX_DATA_AGE_MINUTES * 60 * 1000;  // Converter para milissegundos
        
        // FILTRAR dados que est√£o dentro do limite de idade (60 min)
        const recentPoints = windDataPoints.filter(point => {
            const ageMs = now - point.time;
            return ageMs <= maxAgeMs;
        });
        
        // Contar quantos foram descartados
        const discardedCount = windDataPoints.length - recentPoints.length;
        if (discardedCount > 0) {
            log('warning', `‚ö†Ô∏è ${discardedCount} pontos descartados (mais de ${MAX_DATA_AGE_MINUTES} min de atraso)`);
        }
        
        // Atualizar array global apenas com dados recentes
        windDataPoints = recentPoints;
        
        if (windDataPoints.length === 0) {
            log('warning', `‚ùå Nenhum dado com menos de ${MAX_DATA_AGE_MINUTES} min de idade`);
            document.getElementById('avg-wind').textContent = '--';
            document.getElementById('max-wind').textContent = '--';
            document.getElementById('data-points').textContent = '0';
            document.getElementById('data-age').textContent = '--';
            setStatus('wind-status', 'error');
            return;
        }
        
        let totalSpeed = 0;
        let maxSpeed = 0;
        let latestTime = new Date(0);
        
        windDataPoints.forEach(point => {
            // Desenhar seta
            drawWindArrow(point.lat, point.lon, point.direction, point.speed, point.source);
            
            // Estat√≠sticas
            totalSpeed += point.speed;
            if (point.speed > maxSpeed) maxSpeed = point.speed;
            if (point.time > latestTime) latestTime = point.time;
        });
        
        // Atualizar painel
        const avgSpeed = totalSpeed / windDataPoints.length;
        const ageMinutes = (now - latestTime) / (1000 * 60);  // Idade em minutos
        
        document.getElementById('avg-wind').textContent = avgSpeed.toFixed(1);
        document.getElementById('max-wind').textContent = maxSpeed.toFixed(1);
        document.getElementById('data-points').textContent = windDataPoints.length;
        document.getElementById('data-age').textContent = ageMinutes.toFixed(0) + ' min';
        
        // Status baseado na idade
        if (ageMinutes <= 30) {
            setStatus('wind-status', 'active');
        } else if (ageMinutes <= MAX_DATA_AGE_MINUTES) {
            setStatus('wind-status', 'loading');  // Amarelo para dados entre 30-60 min
        } else {
            setStatus('wind-status', 'error');
        }
    }
    
    function drawWindArrow(lat, lon, direction, speed, source) {
        // Cor baseada na velocidade - ESCALA UNIFICADA (igual ao DMW)
        let color;
        if (speed < 10) color = '#00ff00';       // Verde - Calmo (0-10 kn)
        else if (speed < 15) color = '#88ff00'; // Verde claro - Leve (10-15 kn)
        else if (speed < 20) color = '#ffff00'; // Amarelo - Moderado (15-20 kn)
        else if (speed < 25) color = '#ff9900'; // Laranja - Fresco (20-25 kn)
        else if (speed < 30) color = '#ff0000'; // Vermelho - Forte (25-30 kn)
        else color = '#ff00ff';                  // Roxo/Magenta - Muito forte (>30 kn)
        
        // ESCATER√îMETROS: √≠cone maior, borda destacada, zIndex alto
        const isScatterometer = source.includes('ASCAT') || source.includes('NOAA') || 
                                source.includes('CYGNSS') || source.includes('Copernicus') ||
                                source.includes('Scatterometer');
        
        const size = isScatterometer ? 36 : 22;
        const fontSize = isScatterometer ? '11px' : '9px';
        const borderStyle = isScatterometer ? `border: 2px solid ${color}; border-radius: 50%; background: rgba(0,0,0,0.7); padding: 3px;` : '';
        const zIndex = isScatterometer ? 1000 : 100;
        
        // DIRE√á√ÉO: Valor indica DE ONDE o vento vem (conven√ß√£o meteorol√≥gica)
        // Seta aponta PARA ONDE o vento vai (rota√ß√£o +180¬∞)
        // Ex: Vento de 0¬∞ (Norte) -> seta aponta para Sul (180¬∞)
        const arrowRotation = (direction + 180) % 360;  // Rotaciona 180¬∞
        
        const arrowHtml = `
            <div style="${borderStyle} transform: rotate(${arrowRotation}deg); width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center;">
                <svg viewBox="0 0 24 24" width="${size - 8}" height="${size - 8}">
                    <path fill="${color}" stroke="${isScatterometer ? '#fff' : 'none'}" stroke-width="${isScatterometer ? 1 : 0}" d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
                </svg>
            </div>
            <div style="text-align:center; font-size:${fontSize}; font-weight:bold; color:${color}; text-shadow: 1px 1px 2px black;">
                ${speed.toFixed(0)}${isScatterometer ? '‚óÜ' : ''}
            </div>
        `;

        const icon = L.divIcon({
            className: 'wind-arrow' + (isScatterometer ? ' scatterometer' : ' openmeteo'),
            html: arrowHtml,
            iconSize: [size, size + 12],
            iconAnchor: [size/2, (size + 12)/2]
        });

        L.marker([lat, lon], { icon: icon, zIndexOffset: zIndex })
            .bindPopup(`
                <b>Dados de Vento</b><br>
                Velocidade: ${speed.toFixed(1)} kn<br>
                Dire√ß√£o: ${direction.toFixed(0)}¬∞<br>
                Fonte: ${source}<br>
                Lat: ${lat.toFixed(3)}<br>
                Lon: ${lon.toFixed(3)}
            `)
            .addTo(windLayerGroup);
    }
    
    // =========================================================================
    // FUN√á√ïES AUXILIARES
    // =========================================================================
    function log(type, message) {
        const logArea = document.getElementById('log-area');
        const time = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${time}] ${message}`;
        logArea.appendChild(entry);
        logArea.scrollTop = logArea.scrollHeight;
    }
    
    function setStatus(elementId, status) {
        const el = document.getElementById(elementId);
        if (el) {
            el.className = 'status-indicator ' + status;
        }
    }
    
    function saveCmemsCredentials() {
        const user = document.getElementById('cmems-user').value;
        const pass = document.getElementById('cmems-pass').value;
        localStorage.setItem('cmems-user', user);
        localStorage.setItem('cmems-pass', pass);
        log('success', 'Credenciais CMEMS salvas');
    }
    
    function saveNasaCredentials() {
        const user = document.getElementById('nasa-user').value;
        const pass = document.getElementById('nasa-pass').value;
        localStorage.setItem('nasa-user', user);
        localStorage.setItem('nasa-pass', pass);
        log('success', 'Credenciais NASA salvas');
    }
    
    function loadSavedCredentials() {
        // Credenciais desabilitadas - escater√¥metros t√™m atraso > 60 min
        // Apenas Open-Meteo (tempo real) est√° habilitado
    }
    
    function fetchAllSources() {
        log('info', `‚è±Ô∏è Limite de idade: ${MAX_DATA_AGE_MINUTES} minutos`);
        log('info', 'üåê Buscando dados em TEMPO REAL...');
        
        // Atualizar dados de vento Open-Meteo
        fetchOpenMeteoData();
        
        // Atualizar imagem de sat√©lite se habilitado
        if (satelliteEnabled) {
            loadSatelliteLayer();
        }
        
        // Atualizar dados DMW (ventos derivados de movimento) se habilitado
        if (dmwEnabled) {
            loadDMWWinds();
        }
        
        // Atualizar dados L2 (CAPE, LI, TPW) se habilitado
        if (l2Enabled) {
            loadL2Data();
        }
        
        log('info', '‚úÖ Fontes atualizadas: Open-Meteo, Sat√©lite, DMW, L2');
    }
    
    function clearData() {
        windDataPoints = [];
        windLayerGroup.clearLayers();
        document.getElementById('avg-wind').textContent = '--';
        document.getElementById('max-wind').textContent = '--';
        document.getElementById('data-points').textContent = '--';
        document.getElementById('data-age').textContent = '--';
        setStatus('wind-status', '');
        log('info', 'Dados limpos');
    }
    
    function exportData() {
        if (windDataPoints.length === 0) {
            log('warning', 'Nenhum dado para exportar');
            return;
        }
        
        let csv = 'latitude,longitude,wind_speed_kn,wind_direction,source,timestamp\n';
        windDataPoints.forEach(p => {
            csv += `${p.lat},${p.lon},${p.speed.toFixed(2)},${p.direction.toFixed(1)},${p.source},${p.time.toISOString()}\n`;
        });
        
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `scatterometer_data_${new Date().toISOString().slice(0,10)}.csv`;
        a.click();
        
        log('success', 'Dados exportados para CSV');
    }
    
    // =========================================================================
    // INICIAR
    // =========================================================================
    initMap();
</script>

</body>
</html>
