
<!DOCTYPE html>
<html>
<head>
    <title>Monitor de Vento - Tempo Real - Deepwater Aquila</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; padding: 0; 
            background: #0a0a0a; 
            font-family: 'Consolas', 'Monaco', monospace; 
            color: #e0e0e0; 
        }
        
        /* Layout Principal */
        .container {
            display: flex;
            height: 100vh;
        }
        
        /* Painel Lateral */
        .sidebar {
            width: 380px;
            background: #111;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 15px;
        }
        
        /* Mapa */
        #map { 
            flex: 1;
            height: 100vh;
        }
        
        /* Estilos do Painel */
        h1 {
            font-size: 16px;
            color: #00ffcc;
            border-bottom: 2px solid #00ffcc;
            padding-bottom: 10px;
            margin: 0 0 15px 0;
        }
        
        h2 {
            font-size: 13px;
            color: #ff9900;
            margin: 20px 0 10px 0;
            text-transform: uppercase;
        }
        
        .section {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .section-title {
            font-size: 12px;
            color: #00ffcc;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .status-indicator.active { background: #00ff00; }
        .status-indicator.loading { background: #ffff00; animation: pulse 1s infinite; }
        .status-indicator.error { background: #ff0000; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Inputs */
        label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
        }
        
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 3px;
            font-family: inherit;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        input:focus {
            outline: none;
            border-color: #00ffcc;
        }
        
        button {
            padding: 8px 16px;
            background: #00ffcc;
            color: #000;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        button:hover {
            background: #00ddaa;
        }
        
        button.secondary {
            background: #444;
            color: #fff;
        }
        
        button.secondary:hover {
            background: #555;
        }
        
        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        /* Toggle Button para Sat√©lite */
        .toggle-btn {
            flex: 1;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #555;
            color: #888;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        
        .toggle-btn:hover {
            background: #444;
            color: #ccc;
        }
        
        .toggle-btn.active {
            background: #00cc99;
            border-color: #00ffcc;
            color: #000;
        }
        
        /* Log de Status */
        .log-area {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-size: 11px;
            border-radius: 3px;
        }
        
        .log-entry {
            margin-bottom: 4px;
            padding-left: 10px;
            border-left: 2px solid #444;
        }
        
        .log-entry.info { border-left-color: #00ffcc; }
        .log-entry.success { border-left-color: #00ff00; }
        .log-entry.error { border-left-color: #ff0000; }
        .log-entry.warning { border-left-color: #ffff00; }
        
        /* Dados de Vento */
        .wind-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .stat-box {
            background: #222;
            padding: 10px;
            text-align: center;
            border-radius: 3px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #00ffcc;
        }
        
        .stat-label {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        /* Legenda */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        /* Checkbox customizado */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .checkbox-item input {
            width: 16px;
            height: 16px;
        }
        
        /* Fonte info */
        .source-info {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }
        
        .source-info a {
            color: #00aaff;
        }
        
        /* Info Icon com Tooltip */
        .input-with-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .input-with-info input {
            flex: 1;
            margin-bottom: 0;
        }
        
        .info-icon {
            width: 20px;
            height: 20px;
            background: #0088ff;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            position: relative;
            flex-shrink: 0;
        }
        
        .info-icon:hover {
            background: #00aaff;
        }
        
        .info-tooltip {
            display: none;
            position: absolute;
            left: 30px;
            top: -10px;
            background: #222;
            border: 1px solid #00aaff;
            border-radius: 6px;
            padding: 12px;
            width: 280px;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        .info-icon:hover .info-tooltip {
            display: block;
        }
        
        .info-tooltip h4 {
            color: #00ffcc;
            margin: 0 0 8px 0;
            font-size: 12px;
        }
        
        .info-tooltip p {
            color: #ccc;
            font-size: 11px;
            margin: 6px 0;
            line-height: 1.4;
        }
        
        .info-tooltip ol {
            color: #aaa;
            font-size: 11px;
            margin: 8px 0;
            padding-left: 16px;
            line-height: 1.6;
        }
        
        .info-tooltip a {
            color: #00aaff;
            text-decoration: underline;
        }
        
        .info-tooltip .highlight {
            background: #333;
            padding: 4px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #ffcc00;
        }
    </style>
</head>
<body>

<div class="container">
    <!-- PAINEL LATERAL -->
    <div class="sidebar">
        <h1>üõ∞Ô∏è SCATTEROMETER MONITOR</h1>
        
        <!-- BOT√ÉO ALINHADOR -->
        <a href="image_alignment_tool.html" target="_blank" style="display:block; margin-bottom:10px;">
            <button style="width:100%; background:linear-gradient(135deg, #e94560, #c23a51); padding:12px; font-size:13px;">
                üîß ALINHADOR DE SAT√âLITE
            </button>
        </a>
        
        <!-- BOT√ÉO REPROJE√á√ÉO DE SAT√âLITE -->
        <a href="docs/satellite_reprojection_viewer.html" target="_blank" style="display:block; margin-bottom:15px;">
            <button style="width:100%; background:linear-gradient(135deg, #00d4ff, #0099cc); padding:12px; font-size:13px;">
                üåç REPROJE√á√ÉO DE SAT√âLITE
            </button>
        </a>
        
        <!-- POSI√á√ÉO DO NAVIO -->
        <div class="section">
            <div class="section-title">
                <span class="status-indicator active"></span>
                POSI√á√ÉO: Deepwater Aquila
            </div>
            <div class="wind-stats">
                <div class="stat-box">
                    <div class="stat-value">-22.5¬∞</div>
                    <div class="stat-label">LATITUDE</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">-40.5¬∞</div>
                    <div class="stat-label">LONGITUDE</div>
                </div>
            </div>
        </div>
        
        <!-- ESTAT√çSTICAS DE VENTO -->
        <div class="section">
            <div class="section-title">
                <span class="status-indicator" id="wind-status"></span>
                DADOS DE VENTO
            </div>
            
            <!-- M√©dia Multi-Modelo com Pesos Din√¢micos -->
            <div style="background:#1a2a1a; border:1px solid #00aa00; border-radius:4px; padding:10px; margin-bottom:10px;">
                <div style="font-size:10px; color:#00ff00; margin-bottom:5px;">üåç M√âDIA PONDERADA (5 MODELOS)</div>
                <div style="display:flex; gap:10px; align-items:center;">
                    <div style="text-align:center;">
                        <div style="font-size:24px; font-weight:bold; color:#00ffcc;" id="avg-model-speed">--</div>
                        <div style="font-size:9px; color:#888;">Velocidade (kn)</div>
                    </div>
                    <div style="text-align:center;">
                        <div style="font-size:24px; font-weight:bold; color:#00ffcc;" id="avg-model-dir">--</div>
                        <div style="font-size:9px; color:#888;">Dire√ß√£o (¬∞)</div>
                    </div>
                </div>
                
                <!-- Valores individuais dos modelos -->
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; font-size:9px;">
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:3px;">
                        <div><span style="color:#4488ff;">GFS:</span> <span id="gfs-value">--</span> <span id="gfs-weight" style="color:#ffaa00;"></span></div>
                        <div><span style="color:#ff8844;">ECMWF:</span> <span id="ecmwf-value">--</span> <span id="ecmwf-weight" style="color:#ffaa00;"></span></div>
                        <div><span style="color:#44ff88;">ICON:</span> <span id="icon-value">--</span> <span id="icon-weight" style="color:#ffaa00;"></span></div>
                        <div><span style="color:#ff44ff;">MeteoFR:</span> <span id="meteofr-value">--</span> <span id="meteofr-weight" style="color:#ffaa00;"></span></div>
                        <div><span style="color:#ffff44;">JMA:</span> <span id="jma-value">--</span> <span id="jma-weight" style="color:#ffaa00;"></span></div>
                    </div>
                    <div style="margin-top:5px; font-size:9px; color:#666;" id="weight-reason">
                        Pesos iguais (sem hist√≥rico)
                    </div>
                </div>
            </div>
            
            <div class="wind-stats">
                <div class="stat-box">
                    <div class="stat-value" id="avg-wind">--</div>
                    <div class="stat-label">VENTO M√âDIO (kn)</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="max-wind">--</div>
                    <div class="stat-label">VENTO M√ÅX (kn)</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="data-points">--</div>
                    <div class="stat-label">PONTOS</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="data-age">--</div>
                    <div class="stat-label">IDADE</div>
                </div>
            </div>
            
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#00ff00"></div> &lt;10 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#88ff00"></div> 10-15 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#ffff00"></div> 15-20 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff9900"></div> 20-25 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff0000"></div> 25-30 kn</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff00ff"></div> &gt;30 kn</div>
            </div>
            <div style="margin-top:10px; font-size:10px; color:#888; border-top:1px solid #333; padding-top:8px;">
                <div>‚óÜ = Dado de Escater√¥metro (sat√©lite)</div>
                <div style="margin-top:4px;">Escater√¥metros: √≠cone maior com borda</div>
                <div>Open-Meteo: √≠cone menor (modelo)</div>
            </div>
        </div>
        
        <!-- FONTES DE DADOS -->
        <h2>üì° FONTES DE DADOS</h2>
        
        <!-- Open-Meteo (Background - Modelo) -->
        <div class="section" style="border-left: 3px solid #666;">
            <div class="section-title">
                <span class="status-indicator" id="openmeteo-status"></span>
                OPEN-METEO (Modelo)
            </div>
            <p class="source-info">‚úÖ GRATUITO - Dados de fundo, atualiza a cada 15 min</p>
            <p class="source-info">√çcones menores - Modelo num√©rico (n√£o sat√©lite)</p>
            <button onclick="fetchOpenMeteoData()">üîÑ Atualizar Open-Meteo</button>
            <button class="secondary" onclick="clearOpenMeteoData()">üóëÔ∏è Limpar</button>
        </div>
        
        <h2>ÔøΩ TEMPO REAL (< 60 min)</h2>
        
        <!-- Aviso sobre escater√¥metros -->
        <div class="section" style="border-left: 3px solid #ff6600; background: #1a1000;">
            <div class="section-title" style="color: #ff9900;">
                ‚ö†Ô∏è Sobre Escater√¥metros
            </div>
            <p class="source-info" style="color: #ff9900;">Dados de sat√©lite (ASCAT, CYGNSS) t√™m atraso de 2-6h.</p>
            <p class="source-info">Para dados em tempo real usamos:</p>
            <p class="source-info">‚Ä¢ <strong>Open-Meteo</strong> - Modelos meteorol√≥gicos (acima)</p>
            <p class="source-info">‚ö†Ô∏è Escater√¥metros removidos (atraso > 60min)</p>
        </div>
        
        <!-- Escater√¥metros - DESABILITADO (atraso > 60min) -->
        <!-- 
        <div class="section" style="border-left: 3px solid #333; opacity: 0.5;">
            <div class="section-title">
                <span class="status-indicator" id="cmems-status"></span>
                COPERNICUS MARINE (CMEMS) - ATRASO 2-6h
            </div>
            <p class="source-info">Desabilitado: dados de sat√©lite t√™m atraso > 60 min</p>
        </div>
        -->
        
        <!-- NASA Earthdata - DESABILITADO (atraso > 60min) -->
        <!--
        <div class="section" style="border-left: 3px solid #333; opacity: 0.5;">
            <div class="section-title">
                <span class="status-indicator" id="nasa-status"></span>
                NASA EARTHDATA (CYGNSS) - ATRASO 2-6h
            </div>
            <p class="source-info">Desabilitado: dados de sat√©lite t√™m atraso > 60 min</p>
        </div>
        -->
        
        <!-- Camadas do Mapa -->
        <h2>ÔøΩÔ∏è CAMADAS</h2>
        <div class="section">
            <div class="checkbox-group">
                <label class="checkbox-item">
                    <input type="checkbox" id="layer-arrows" checked onchange="toggleLayer('arrows')">
                    Setas de Vento
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" id="layer-grid" onchange="toggleLayer('grid')">
                    Grade de Coordenadas
                </label>
            </div>
        </div>
        
        <!-- Sat√©lite em Tempo Real -->
        <h2>üõ∞Ô∏è SAT√âLITE (100 NM)</h2>
        <div class="section" style="border-left: 3px solid #00ff00;">
            <div class="section-title">
                <span class="status-indicator" id="satellite-status"></span>
                <span id="satellite-name">GOES-19</span> IR (Recortado)
            </div>
            <p class="source-info">‚úÖ √Årea de 100 NM processada</p>
            <p class="source-info">Band 13 (IR) - Infravermelho</p>
            
            <!-- Toggle de Sat√©lite -->
            <label>Sat√©lite:</label>
            <div class="toggle-container" style="display:flex; gap:5px; margin-bottom:10px;">
                <button id="btn-goes19" class="toggle-btn active" onclick="selectSatellite('goes19')">GOES-19</button>
                <button id="btn-goes16" class="toggle-btn" onclick="selectSatellite('goes16')">GOES-16</button>
            </div>
            
            <label>Opacidade: <span id="opacity-value">60%</span></label>
            <input type="range" id="satellite-opacity" min="0" max="100" value="60" 
                   style="width:100%; margin-bottom:8px;" 
                   oninput="updateSatelliteOpacity(this.value)">
            
            <div style="display:flex; gap:5px; margin-top:5px;">
                <button onclick="loadSatelliteLayer()">üîÑ Atualizar</button>
                <button class="secondary" onclick="toggleSatelliteLayer()">üëÅÔ∏è On/Off</button>
            </div>
            
            <div id="satellite-info" style="margin-top:8px; font-size:10px; color:#888;"></div>
        </div>
        
        <!-- Log -->
        <h2>üìã LOG</h2>
        <div class="log-area" id="log-area">
            <div class="log-entry info">Sistema iniciado...</div>
        </div>
        
        <!-- A√ß√µes -->
        <div style="margin-top: 15px;">
            <button onclick="fetchAllSources()">üîÑ BUSCAR TODOS</button>
            <button class="secondary" onclick="clearData()">üóëÔ∏è Limpar</button>
            <button class="secondary" onclick="exportData()">üì• Exportar CSV</button>
        </div>
        
    </div>
    
    <!-- MAPA -->
    <div id="map"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
    // =========================================================================
    // CONFIGURA√á√ÉO
    // =========================================================================
    // Raio para visualiza√ß√£o do mapa (c√≠rculo visual)
    const RAIO_VISUAL_NM = 100;  // Raio do c√≠rculo visual no mapa
    const RAIO_VISUAL_GRAUS = RAIO_VISUAL_NM / 60;
    
    // Raio para busca de dados Open-Meteo (menor para economizar API)
    const RAIO_NM = 50;  // Raio em milhas n√°uticas para busca de dados
    const RAIO_GRAUS = RAIO_NM / 60;  // 1 grau = 60 NM
    
    // IMPORTANTE: Idade m√°xima dos dados em MINUTOS
    // Dados com mais de 60 min ser√£o descartados
    const MAX_DATA_AGE_MINUTES = 60;
    
    const CONFIG = {
        shipLat: -22.5,
        shipLon: -40.5,
        latMin: -22.5 - RAIO_GRAUS,
        latMax: -22.5 + RAIO_GRAUS,
        lonMin: -40.5 - RAIO_GRAUS,
        lonMax: -40.5 + RAIO_GRAUS,
        shipName: "Deepwater Aquila"
    };
    
    let map;
    let windDataPoints = [];  // Armazena todos os dados de vento
    let windLayerGroup;
    let gridLayer;
    
    // =========================================================================
    // INICIALIZA√á√ÉO DO MAPA
    // =========================================================================
    function initMap() {
        map = L.map('map', {
            center: [CONFIG.shipLat, CONFIG.shipLon],
            zoom: 7,
            zoomControl: false
        });

        L.control.zoom({ position: 'topright' }).addTo(map);
        L.control.scale({ position: 'bottomright', imperial: false }).addTo(map);

        // Mapa Base Escuro
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19
        }).addTo(map);
        
        // Grupos de camadas
        windLayerGroup = L.layerGroup().addTo(map);
        gridLayer = L.layerGroup();
        
        log('info', 'üìç Adicionando √≠cone do navio...');

        // √çcone do Navio
        const shipIcon = L.divIcon({
            className: 'ship-icon',
            html: `<svg viewBox="0 0 24 24" width="50" height="50">
                <circle cx="12" cy="12" r="10" fill="rgba(0,255,204,0.3)" stroke="#00ffcc" stroke-width="2"/>
                <circle cx="12" cy="12" r="4" fill="#00ffcc"/>
            </svg>`,
            iconSize: [50, 50],
            iconAnchor: [25, 25]
        });
        L.marker([CONFIG.shipLat, CONFIG.shipLon], { icon: shipIcon })
            .bindPopup(`<b>${CONFIG.shipName}</b><br>Lat: ${CONFIG.shipLat}<br>Lon: ${CONFIG.shipLon}`)
            .addTo(map);
        
        // √Årea de interesse (C√çRCULO VISUAL - 100 NM)
        L.circle([CONFIG.shipLat, CONFIG.shipLon], {
            radius: RAIO_VISUAL_NM * 1852,  // Converter NM para metros
            color: "#00ffcc",
            weight: 1,
            fillOpacity: 0.05,
            dashArray: '5, 5'
        }).addTo(map);
        
        log('info', 'üó∫Ô∏è Mapa base carregado');
        
        // Criar grade
        createGrid();
        
        // Carregar credenciais salvas
        loadSavedCredentials();
        
        log('success', '‚úÖ Mapa inicializado');
        log('info', `üìè √Årea visual: ${RAIO_VISUAL_NM} NM | Grid dados: ${RAIO_NM} NM`);
        
        // Carregar sat√©lite primeiro (500ms)
        log('info', 'üõ∞Ô∏è Iniciando carregamento de sat√©lite...');
        setTimeout(() => loadSatelliteLayer(), 500);
        
        // Buscar dados Open-Meteo (1 segundo)
        log('info', 'üå¨Ô∏è Iniciando busca de dados de vento...');
        setTimeout(() => fetchOpenMeteoData(), 1500);
        
        // Atualiza√ß√£o autom√°tica do Open-Meteo a cada 15 minutos
        setInterval(() => {
            log('info', '‚è∞ Atualiza√ß√£o autom√°tica (15 min)...');
            fetchOpenMeteoData();
        }, 15 * 60 * 1000);  // 15 minutos
    }
    
    // =========================================================================
    // CAMADA DE SAT√âLITE (Imagem pr√©-processada)
    // =========================================================================
    let satelliteEnabled = true;
    let satelliteLayer = null;
    let satelliteRefreshInterval = null;
    let satelliteData = null;
    let currentSatellite = 'goes19';  // Sat√©lite padr√£o
    
    function selectSatellite(satId) {
        currentSatellite = satId;
        
        // Atualizar bot√µes
        document.querySelectorAll('.toggle-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById('btn-' + satId).classList.add('active');
        
        // Atualizar nome no t√≠tulo
        const nameEl = document.getElementById('satellite-name');
        if (nameEl) {
            nameEl.textContent = satId === 'goes19' ? 'GOES-19' : 'GOES-16';
        }
        
        // Carregar novo sat√©lite
        loadSatelliteLayer();
        log('info', `üõ∞Ô∏è Sat√©lite alterado para ${satId.toUpperCase()}`);
    }
    
    // Configura√ß√£o dos sat√©lites GOES (direto da NOAA)
    // A imagem est√° em PROJE√á√ÉO GEOESTACION√ÅRIA - precisa reprojetar para Web Mercator
    const SATELLITE_CONFIG = {
        goes19: {
            name: 'GOES-19',
            url: 'https://cdn.star.nesdis.noaa.gov/GOES19/ABI/SECTOR/ssa/13/latest.jpg'
        },
        goes16: {
            name: 'GOES-16',
            url: 'https://cdn.star.nesdis.noaa.gov/GOES16/ABI/SECTOR/ssa/13/latest.jpg'
        }
    };
    
    // Constantes da proje√ß√£o geoestacion√°ria GOES
    const GOES_PARAMS = {
        satLon: -75.2,        // Longitude do sat√©lite (graus)
        satHeight: 35786023,  // Altura do sat√©lite (m)
        earthRadius: 6378137, // Raio equatorial (m)
        earthRadiusPolar: 6356752.31414, // Raio polar (m)
        
        // Scan angles calibrados para a imagem SSA (radianos)
        scanXMin: -0.08365403,
        scanXMax: 0.13199896,
        scanYMin: -0.14002762,
        scanYMax: 0.04996900,
        
        // Dimens√µes da imagem original
        imgWidth: 7200,
        imgHeight: 4320
    };
    
    // Converte pixel na imagem GOES para lat/lon
    function goesPixelToLatLon(px, py) {
        const p = GOES_PARAMS;
        
        const x = p.scanXMin + (px / p.imgWidth) * (p.scanXMax - p.scanXMin);
        const y = p.scanYMax - (py / p.imgHeight) * (p.scanYMax - p.scanYMin);
        
        const H = p.satHeight + p.earthRadius;
        
        const a = Math.pow(Math.sin(x), 2) + Math.pow(Math.cos(x), 2) * 
                  (Math.pow(Math.cos(y), 2) + Math.pow(p.earthRadius/p.earthRadiusPolar, 2) * Math.pow(Math.sin(y), 2));
        const b = -2 * H * Math.cos(x) * Math.cos(y);
        const c = H*H - p.earthRadius*p.earthRadius;
        
        const discriminant = b*b - 4*a*c;
        if (discriminant < 0) return null;
        
        const rs = (-b - Math.sqrt(discriminant)) / (2*a);
        
        const sxp = rs * Math.cos(x) * Math.cos(y);
        const syp = -rs * Math.sin(x);
        const szp = rs * Math.cos(x) * Math.sin(y);
        
        const lat = Math.atan(Math.pow(p.earthRadius/p.earthRadiusPolar, 2) * szp / 
                    Math.sqrt(Math.pow(H-sxp, 2) + syp*syp)) * 180 / Math.PI;
        const lon = p.satLon - Math.atan(syp / (H - sxp)) * 180 / Math.PI;
        
        return [lat, lon];
    }
    
    // Converte lat/lon para pixel na imagem GOES
    function latLonToGoesPixel(lat, lon) {
        const p = GOES_PARAMS;
        const latRad = lat * Math.PI / 180;
        const lonRad = lon * Math.PI / 180;
        const satLonRad = p.satLon * Math.PI / 180;
        
        const H = p.satHeight + p.earthRadius;
        
        const phiC = Math.atan(Math.pow(p.earthRadiusPolar/p.earthRadius, 2) * Math.tan(latRad));
        const rc = p.earthRadiusPolar / Math.sqrt(1 - (Math.pow(p.earthRadius, 2) - Math.pow(p.earthRadiusPolar, 2)) / 
                   Math.pow(p.earthRadius, 2) * Math.pow(Math.cos(phiC), 2));
        
        const sx = H - rc * Math.cos(phiC) * Math.cos(lonRad - satLonRad);
        const sy = -rc * Math.cos(phiC) * Math.sin(lonRad - satLonRad);
        const sz = rc * Math.sin(phiC);
        
        if (sx * (sx - H) + sy*sy + sz*sz > 0) return null;
        
        const scanY = Math.atan(sz / sx);
        const scanX = Math.asin(-sy / Math.sqrt(sx*sx + sy*sy + sz*sz));
        
        const px = (scanX - p.scanXMin) / (p.scanXMax - p.scanXMin) * p.imgWidth;
        const py = (p.scanYMax - scanY) / (p.scanYMax - p.scanYMin) * p.imgHeight;
        
        return [px, py];
    }
    
    // Reprojeta imagem GOES de geoestacion√°ria para Web Mercator
    function reprojectGoesToMercator(srcImg, targetWidth, targetHeight, latMin, latMax, lonMin, lonMax) {
        const canvas = document.createElement('canvas');
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext('2d');
        
        // Desenhar imagem fonte em canvas tempor√°rio
        const srcCanvas = document.createElement('canvas');
        srcCanvas.width = srcImg.width;
        srcCanvas.height = srcImg.height;
        const srcCtx = srcCanvas.getContext('2d');
        srcCtx.drawImage(srcImg, 0, 0);
        const srcData = srcCtx.getImageData(0, 0, srcImg.width, srcImg.height).data;
        
        // Criar imagem de destino
        const destImageData = ctx.createImageData(targetWidth, targetHeight);
        const destData = destImageData.data;
        
        // Convers√£o Mercator
        const latToMercY = (lat) => Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI / 180) / 2));
        const mercYMin = latToMercY(latMin);
        const mercYMax = latToMercY(latMax);
        
        for (let destY = 0; destY < targetHeight; destY++) {
            // Posi√ß√£o Y no espa√ßo Mercator
            const t = destY / targetHeight;
            const mercY = mercYMax - t * (mercYMax - mercYMin);
            const lat = (2 * Math.atan(Math.exp(mercY)) - Math.PI / 2) * 180 / Math.PI;
            
            for (let destX = 0; destX < targetWidth; destX++) {
                const lon = lonMin + (destX / targetWidth) * (lonMax - lonMin);
                
                // Converter lat/lon para pixel na imagem GOES
                const srcPixel = latLonToGoesPixel(lat, lon);
                
                if (srcPixel) {
                    const [srcX, srcY] = srcPixel;
                    
                    if (srcX >= 0 && srcX < srcImg.width && srcY >= 0 && srcY < srcImg.height) {
                        // Interpola√ß√£o bilinear
                        const x0 = Math.floor(srcX);
                        const y0 = Math.floor(srcY);
                        const x1 = Math.min(x0 + 1, srcImg.width - 1);
                        const y1 = Math.min(y0 + 1, srcImg.height - 1);
                        const fx = srcX - x0;
                        const fy = srcY - y0;
                        
                        const destIdx = (destY * targetWidth + destX) * 4;
                        
                        for (let c = 0; c < 4; c++) {
                            const v00 = srcData[(y0 * srcImg.width + x0) * 4 + c];
                            const v10 = srcData[(y0 * srcImg.width + x1) * 4 + c];
                            const v01 = srcData[(y1 * srcImg.width + x0) * 4 + c];
                            const v11 = srcData[(y1 * srcImg.width + x1) * 4 + c];
                            
                            const v = v00 * (1-fx) * (1-fy) + v10 * fx * (1-fy) + 
                                     v01 * (1-fx) * fy + v11 * fx * fy;
                            destData[destIdx + c] = Math.round(v);
                        }
                    }
                }
            }
        }
        
        ctx.putImageData(destImageData, 0, 0);
        return canvas.toDataURL('image/jpeg', 0.85);
    }
    
    async function loadSatelliteLayer() {
        const opacity = (document.getElementById('satellite-opacity')?.value || 60) / 100;
        const satId = currentSatellite;  // 'goes19' ou 'goes16'
        
        setStatus('satellite-status', 'loading');
        log('info', `üõ∞Ô∏è Carregando ${satId.toUpperCase()}...`);
        console.log('üõ∞Ô∏è [SATELLITE] Iniciando carregamento:', satId);
        
        try {
            // Remover camada anterior
            if (satelliteLayer) {
                map.removeLayer(satelliteLayer);
                satelliteLayer = null;
                log('info', 'üóëÔ∏è Camada anterior removida');
            }
            
            // Usar imagem PR√â-PROCESSADA localmente (process_satellite.py)
            const imageUrl = `satellite_${satId}.png?t=${Date.now()}`;
            const jsonUrl = `satellite_${satId}.json?t=${Date.now()}`;
            
            console.log('üì° [SATELLITE] URLs:', { imageUrl, jsonUrl });
            log('info', `üì° Buscando: ${jsonUrl}`);
            
            // Buscar metadados do JSON
            let bounds = null;
            try {
                const response = await fetch(jsonUrl);
                console.log('üì° [SATELLITE] Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üì° [SATELLITE] JSON data:', data);
                
                if (data.leaflet_bounds) {
                    // Formato: [[latSouth, lonWest], [latNorth, lonEast]]
                    bounds = data.leaflet_bounds;
                    log('success', `üìç Bounds: [${bounds[0][0].toFixed(2)},${bounds[0][1].toFixed(2)}] a [${bounds[1][0].toFixed(2)},${bounds[1][1].toFixed(2)}]`);
                    console.log('üìç [SATELLITE] Bounds:', bounds);
                }
            } catch (e) {
                log('error', `‚ùå Erro ao ler JSON: ${e.message}`);
                console.error('‚ùå [SATELLITE] Erro JSON:', e);
            }
            
            // Se n√£o encontrou bounds no JSON, usar padr√£o (100NM ao redor do navio)
            if (!bounds) {
                const RAIO_NM = 100;
                const RAIO_GRAUS = RAIO_NM / 60;
                bounds = [
                    [CONFIG.shipLat - RAIO_GRAUS, CONFIG.shipLon - RAIO_GRAUS],  // [latSouth, lonWest]
                    [CONFIG.shipLat + RAIO_GRAUS, CONFIG.shipLon + RAIO_GRAUS]   // [latNorth, lonEast]
                ];
                log('warning', '‚ö†Ô∏è Usando bounds padr√£o (100NM)');
                console.warn('‚ö†Ô∏è [SATELLITE] Usando bounds padr√£o:', bounds);
            }
            
            console.log('üñºÔ∏è [SATELLITE] Adicionando imageOverlay:', { imageUrl, bounds, opacity });
            log('info', `üñºÔ∏è Carregando imagem: ${imageUrl}`);
            
            // Adicionar imagem processada ao mapa
            satelliteLayer = L.imageOverlay(imageUrl, bounds, {
                opacity: opacity,
                zIndex: 1,
                errorOverlayUrl: null,  // N√£o mostrar placeholder se falhar
                alt: `Sat√©lite ${satId.toUpperCase()}`
            });
            
            satelliteLayer.on('load', function() {
                log('success', `‚úÖ ${satId.toUpperCase()} carregado com sucesso!`);
                console.log('‚úÖ [SATELLITE] Imagem carregada com sucesso');
                setStatus('satellite-status', 'active');
            });
            
            satelliteLayer.on('error', function(e) {
                log('error', `‚ùå Erro ao carregar ${satId.toUpperCase()}: ${imageUrl}`);
                console.error('‚ùå [SATELLITE] Erro ao carregar imagem:', e);
                log('info', 'üí° Execute: python3 process_satellite.py');
                setStatus('satellite-status', 'error');
            });
            
            console.log('üó∫Ô∏è [SATELLITE] Adicionando camada ao mapa...');
            satelliteLayer.addTo(map);
            console.log('‚úÖ [SATELLITE] Camada adicionada ao mapa');
            
            // Atualizar info
            const infoEl = document.getElementById('satellite-info');
            if (infoEl) {
                infoEl.innerHTML = `üì° ${satId.toUpperCase()} IR Band 13<br>üõ∞Ô∏è √Årea: 100 NM recortada<br>üó∫Ô∏è Imagem pr√©-processada`;
            }
            
        } catch (error) {
            log('error', `‚ùå Erro sat√©lite: ${error.message}`);
            console.error('‚ùå [SATELLITE] Erro fatal:', error);
            log('info', 'üí° Execute: python3 process_satellite.py');
            setStatus('satellite-status', 'error');
        }
    }
    
    function updateSatelliteOpacity(value) {
        document.getElementById('opacity-value').textContent = value + '%';
        if (satelliteLayer) {
            satelliteLayer.setOpacity(value / 100);
        }
    }
    
    function toggleSatelliteLayer() {
        satelliteEnabled = !satelliteEnabled;
        if (satelliteEnabled) {
            loadSatelliteLayer();
            log('info', 'üõ∞Ô∏è Camada de sat√©lite ativada');
        } else {
            if (satelliteLayer) map.removeLayer(satelliteLayer);
            setStatus('satellite-status', '');
            log('info', 'üõ∞Ô∏è Camada de sat√©lite desativada');
        }
    }
    
    // =========================================================================
    // GRADE DE COORDENADAS
    // =========================================================================
    function createGrid() {
        for (let lat = -30; lat <= -15; lat += 1) {
            L.polyline([[lat, CONFIG.lonMin - 2], [lat, CONFIG.lonMax + 2]], {
                color: '#333',
                weight: 1,
                opacity: 0.5
            }).addTo(gridLayer);
            
            L.marker([lat, CONFIG.lonMin - 1], {
                icon: L.divIcon({
                    className: 'grid-label',
                    html: `<span style="color:#666;font-size:10px">${lat}¬∞</span>`
                })
            }).addTo(gridLayer);
        }
        
        for (let lon = -50; lon <= -35; lon += 1) {
            L.polyline([[CONFIG.latMin - 2, lon], [CONFIG.latMax + 2, lon]], {
                color: '#333',
                weight: 1,
                opacity: 0.5
            }).addTo(gridLayer);
        }
    }
    
    // =========================================================================
    // TOGGLE DE CAMADAS
    // =========================================================================
    function toggleLayer(layer) {
        const checkbox = document.getElementById(`layer-${layer}`);
        switch(layer) {
            case 'arrows':
                if (checkbox.checked) windLayerGroup.addTo(map);
                else map.removeLayer(windLayerGroup);
                break;
            case 'grid':
                if (checkbox.checked) gridLayer.addTo(map);
                else map.removeLayer(gridLayer);
                break;
        }
    }
    
    // =========================================================================
    // BUSCAR DADOS - NOAA ERDDAP (GRATUITO!)
    // =========================================================================
    
    // Lista de datasets NOAA ERDDAP dispon√≠veis (em ordem de prefer√™ncia)
    const NOAA_DATASETS = [
        {
            id: 'erdQCwindproducts1day',
            name: 'MetOp-C ASCAT 1-Day (2020-presente)',
            vars: ['wind_speed', 'wind_direction']
        },
        {
            id: 'erdQCwindproducts3day',
            name: 'MetOp-C ASCAT 3-Day Composite',
            vars: ['wind_speed', 'wind_direction']
        },
        {
            id: 'erdNavgem05D10mWind',
            name: 'NAVGEM 0.5¬∞ 10m Wind (modelo)',
            vars: ['u_wind', 'v_wind']
        }
    ];
    
    async function fetchNOAAData() {
        setStatus('noaa-status', 'loading');
        log('info', 'üì° Buscando dados NOAA ERDDAP (ASCAT Metop-C)...');
        
        const baseUrl = 'https://coastwatch.pfeg.noaa.gov/erddap/griddap';
        
        // Tentar datasets em ordem de prefer√™ncia
        for (const dataset of NOAA_DATASETS) {
            log('info', `üîç Tentando: ${dataset.name}...`);
            
            // Dados de sat√©lite t√™m atraso de ~24h no processamento
            // Buscar de 4 dias atr√°s at√© 1 dia atr√°s
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000);
            const fourDaysAgo = new Date(now.getTime() - 4 * 24 * 60 * 60 * 1000);
            
            const startTime = fourDaysAgo.toISOString().split('.')[0] + 'Z';
            const endTime = oneDayAgo.toISOString().split('.')[0] + 'Z';
            
            // Construir URL baseado nas vari√°veis do dataset
            // Nota: erdQCwindproducts tem dimens√£o altitude (10m)
            let erddapUrl;
            if (dataset.vars.includes('wind_speed')) {
                // Dataset com wind_speed e wind_direction diretos (com altitude)
                erddapUrl = `${baseUrl}/${dataset.id}.json?` +
                    `wind_speed[(${startTime}):1:(${endTime})]` +
                    `[(10.0)]` +  // altitude 10m
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]` +
                    `,wind_direction[(${startTime}):1:(${endTime})]` +
                    `[(10.0)]` +  // altitude 10m
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]`;
            } else {
                // Dataset com componentes u/v (pode ter altitude ou n√£o)
                erddapUrl = `${baseUrl}/${dataset.id}.json?` +
                    `${dataset.vars[0]}[(${startTime}):1:(${endTime})]` +
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]` +
                    `,${dataset.vars[1]}[(${startTime}):1:(${endTime})]` +
                    `[(${CONFIG.latMax}):1:(${CONFIG.latMin})]` +
                    `[(${CONFIG.lonMin}):1:(${CONFIG.lonMax})]`;
            }
            
            try {
                // Usar proxy local para evitar CORS
                const url = `/api/noaa?url=${encodeURIComponent(erddapUrl)}`;
                log('info', 'Buscando via proxy local...');
                
                const response = await fetch(url, { timeout: 30000 });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    log('warning', `Dataset ${dataset.id} indispon√≠vel: ${response.status} - ${errorData.reason || ''}`);
                    continue; // Tentar pr√≥ximo dataset
                }
                
                const data = await response.json();
                
                // Verificar se h√° dados v√°lidos
                if (data && data.table && data.table.rows && data.table.rows.length > 0) {
                    log('success', `‚úÖ Dados obtidos de ${dataset.name}: ${data.table.rows.length} pontos`);
                    processNOAAData(data, dataset.vars.includes('wind_speed'));
                    setStatus('noaa-status', 'active');
                    return; // Sucesso!
                } else {
                    log('warning', `Dataset ${dataset.id} sem dados para a √°rea/per√≠odo`);
                }
                
            } catch (error) {
                log('warning', `Erro no dataset ${dataset.id}: ${error.message}`);
                continue; // Tentar pr√≥ximo
            }
        }
        
        // Se todos falharam, usar Open-Meteo como fallback
        log('warning', '‚ö†Ô∏è Nenhum dataset NOAA dispon√≠vel, usando Open-Meteo como fallback');
        setStatus('noaa-status', 'error');
        await fetchOpenMeteoWindGrid();
    }
    
    // Fallback: buscar grid de vento do Open-Meteo
    async function fetchOpenMeteoWindGrid() {
        log('info', 'üîÑ Buscando grid de vento Open-Meteo...');
        
        // Criar grid de pontos na √°rea
        const lats = [];
        const lons = [];
        const step = 0.5;
        
        for (let lat = CONFIG.latMin; lat <= CONFIG.latMax; lat += step) {
            lats.push(lat.toFixed(2));
        }
        for (let lon = CONFIG.lonMin; lon <= CONFIG.lonMax; lon += step) {
            lons.push(lon.toFixed(2));
        }
        
        // Criar todas as combina√ß√µes
        const queryLats = [];
        const queryLons = [];
        for (const lat of lats) {
            for (const lon of lons) {
                queryLats.push(lat);
                queryLons.push(lon);
            }
        }
        
        // Limitar a 50 pontos (limite da API)
        const maxPoints = 50;
        const selectedLats = queryLats.slice(0, maxPoints);
        const selectedLons = queryLons.slice(0, maxPoints);
        
        const url = `https://api.open-meteo.com/v1/forecast?` +
            `latitude=${selectedLats.join(',')}&` +
            `longitude=${selectedLons.join(',')}&` +
            `current=wind_speed_10m,wind_direction_10m&` +
            `wind_speed_unit=kn`;
        
        try {
            const response = await fetch(url);
            const data = await response.json();
            
            let count = 0;
            if (Array.isArray(data)) {
                data.forEach(point => {
                    if (point.current) {
                        addWindPoint({
                            lat: point.latitude,
                            lon: point.longitude,
                            speed: point.current.wind_speed_10m,
                            direction: point.current.wind_direction_10m,
                            time: new Date(),
                            source: 'Open-Meteo Grid'
                        });
                        count++;
                    }
                });
            } else if (data.current) {
                addWindPoint({
                    lat: data.latitude,
                    lon: data.longitude,
                    speed: data.current.wind_speed_10m,
                    direction: data.current.wind_direction_10m,
                    time: new Date(),
                    source: 'Open-Meteo Grid'
                });
                count = 1;
            }
            
            log('success', `‚úÖ Grid Open-Meteo: ${count} pontos`);
            updateWindDisplay();
            setStatus('noaa-status', 'active');
            
        } catch (error) {
            log('error', `Erro Open-Meteo Grid: ${error.message}`);
        }
    }
    
    // =========================================================================
    // OPEN-METEO (MULTI-MODELO) COM PESOS DIN√ÇMICOS
    // =========================================================================
    
    // Lista de modelos dispon√≠veis
    const MODELS = ['gfs_seamless', 'ecmwf_ifs025', 'icon_seamless', 'meteofrance_seamless', 'jma_seamless'];
    const MODEL_NAMES = {
        'gfs_seamless': 'GFS',
        'ecmwf_ifs025': 'ECMWF', 
        'icon_seamless': 'ICON',
        'meteofrance_seamless': 'MeteoFR',
        'jma_seamless': 'JMA'
    };
    
    // Armazena dados de todos os modelos
    let modelData = {};
    MODELS.forEach(m => modelData[m] = { speed: null, direction: null });
    
    // Pesos din√¢micos (iniciam iguais)
    let modelWeights = {};
    MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
    
    // Hist√≥rico de previs√µes para compara√ß√£o
    let forecastHistory = [];
    
    // Carregar hist√≥rico do localStorage
    function loadForecastHistory() {
        try {
            const saved = localStorage.getItem('forecastHistoryMulti');
            if (saved) {
                forecastHistory = JSON.parse(saved);
                const cutoff = Date.now() - 24 * 60 * 60 * 1000;
                forecastHistory = forecastHistory.filter(h => h.timestamp > cutoff);
                log('info', `üìä Hist√≥rico carregado: ${forecastHistory.length} registros`);
                calculateDynamicWeights();
            }
        } catch (e) {
            forecastHistory = [];
        }
    }
    
    function saveForecastHistory() {
        try {
            localStorage.setItem('forecastHistoryMulti', JSON.stringify(forecastHistory));
        } catch (e) {}
    }
    
    function directionError(predicted, actual) {
        if (predicted === null || actual === null) return 180;
        let diff = Math.abs(predicted - actual);
        if (diff > 180) diff = 360 - diff;
        return diff;
    }
    
    // Calcular pesos baseado no erro hist√≥rico de TODOS os modelos
    function calculateDynamicWeights() {
        if (forecastHistory.length < 2) {
            MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
            document.getElementById('weight-reason').textContent = 'Pesos iguais (hist√≥rico insuficiente)';
            return;
        }
        
        let modelErrors = {};
        MODELS.forEach(m => modelErrors[m] = 0);
        let comparisons = 0;
        
        for (let i = 1; i < forecastHistory.length; i++) {
            const prev = forecastHistory[i - 1];
            const curr = forecastHistory[i];
            
            MODELS.forEach(model => {
                if (prev[model] && curr[model] && prev[model].speed !== null && curr[model].speed !== null) {
                    const speedErr = Math.abs(prev[model].speed - curr[model].speed) / 20;
                    const dirErr = directionError(prev[model].direction, curr[model].direction) / 180;
                    modelErrors[model] += (speedErr + dirErr) / 2;
                }
            });
            comparisons++;
        }
        
        if (comparisons === 0) {
            MODELS.forEach(m => modelWeights[m] = 1 / MODELS.length);
            return;
        }
        
        // Normalizar erros
        MODELS.forEach(m => modelErrors[m] /= comparisons);
        
        // Converter erros em pesos (menor erro = maior peso)
        let totalInvError = 0;
        MODELS.forEach(m => {
            const invErr = 1 / (modelErrors[m] + 0.01); // +0.01 para evitar divis√£o por zero
            modelWeights[m] = invErr;
            totalInvError += invErr;
        });
        
        // Normalizar pesos
        MODELS.forEach(m => modelWeights[m] /= totalInvError);
        
        // Limitar entre 5% e 40%
        MODELS.forEach(m => {
            modelWeights[m] = Math.max(0.05, Math.min(0.40, modelWeights[m]));
        });
        
        // Renormalizar
        let sum = 0;
        MODELS.forEach(m => sum += modelWeights[m]);
        MODELS.forEach(m => modelWeights[m] /= sum);
        
        // Encontrar melhor modelo
        let bestModel = MODELS[0];
        let lowestError = modelErrors[MODELS[0]];
        MODELS.forEach(m => {
            if (modelErrors[m] < lowestError) {
                lowestError = modelErrors[m];
                bestModel = m;
            }
        });
        
        document.getElementById('weight-reason').innerHTML = 
            `‚öñÔ∏è ${comparisons} compara√ß√µes | Melhor: <span style="color:#00ff00;">${MODEL_NAMES[bestModel]}</span>`;
        
        log('info', `‚öñÔ∏è Pesos: ${MODELS.map(m => MODEL_NAMES[m] + ':' + (modelWeights[m]*100).toFixed(0) + '%').join(' | ')}`);
    }
    
    function addToForecastHistory(data) {
        const record = { timestamp: Date.now() };
        MODELS.forEach(m => {
            record[m] = data[m] ? { speed: data[m].speed, direction: data[m].direction } : { speed: null, direction: null };
        });
        
        forecastHistory.push(record);
        if (forecastHistory.length > 96) forecastHistory = forecastHistory.slice(-96);
        
        saveForecastHistory();
        calculateDynamicWeights();
    }
    
    async function fetchOpenMeteoData() {
        setStatus('openmeteo-status', 'loading');
        log('info', 'üåê Buscando 5 modelos (Open-Meteo)...');
        
        try {
            if (forecastHistory.length === 0) loadForecastHistory();
            
            // Limpar dados anteriores
            windDataPoints = windDataPoints.filter(p => 
                !p.source.includes('GFS') && !p.source.includes('ECMWF') && 
                !p.source.includes('ICON') && !p.source.includes('MeteoFR') && 
                !p.source.includes('JMA') && p.source !== 'Open-Meteo'
            );
            
            // Usar endpoint /forecast com par√¢metro models para todos
            // Isso garante dados 'current' dispon√≠veis para todos os modelos
            const promises = MODELS.map(async model => {
                try {
                    // Endpoint unificado com par√¢metro models
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.shipLat}&longitude=${CONFIG.shipLon}&current=wind_speed_10m,wind_direction_10m&models=${model}&wind_speed_unit=kn`;
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.current && data.current.wind_speed_10m !== undefined) {
                        modelData[model] = {
                            speed: data.current.wind_speed_10m,
                            direction: data.current.wind_direction_10m
                        };
                        log('info', `  ‚úì ${MODEL_NAMES[model]}: ${data.current.wind_speed_10m.toFixed(1)} kn`);
                    } else {
                        log('warning', `  ‚úó ${MODEL_NAMES[model]}: sem dados current`);
                    }
                } catch (e) {
                    log('warning', `  ‚úó ${MODEL_NAMES[model]}: ${e.message}`);
                }
            });
            
            await Promise.all(promises);
            
            // Adicionar ao hist√≥rico
            addToForecastHistory(modelData);
            
            // Atualizar display
            updateModelAverage();
            
            // Criar grid de pontos para o mapa (50 NM)
            await fetchGridPoints();
            
            updateWindDisplay();
            setStatus('openmeteo-status', 'active');
            
            const activeModels = MODELS.filter(m => modelData[m].speed !== null).length;
            log('success', `‚úÖ ${activeModels} modelos carregados - Pr√≥xima atualiza√ß√£o em 15 min`);
            
        } catch (error) {
            log('error', '‚ùå Erro: ' + error.message);
            setStatus('openmeteo-status', 'error');
        }
    }
    
    async function fetchGridPoints() {
        // Grid CIRCULAR usando o mesmo espa√ßamento do Open-Meteo (0.125¬∞)
        const step = 0.125;  // Grid nativo do Open-Meteo
        const raioGraus = RAIO_GRAUS;
        
        let queryLats = [];
        let queryLons = [];
        
        // Calcular quantos passos cabem no raio
        const numSteps = Math.floor(raioGraus / step);
        
        // Iterar de -numSteps a +numSteps (garante simetria perfeita)
        for (let i = -numSteps; i <= numSteps; i++) {
            for (let j = -numSteps; j <= numSteps; j++) {
                const lat = CONFIG.shipLat + (i * step);
                const lon = CONFIG.shipLon + (j * step);
                
                // Dist√¢ncia do centro em passos
                const dist = Math.sqrt(i*i + j*j) * step;
                
                // S√≥ incluir se dentro do c√≠rculo
                if (dist <= raioGraus) {
                    queryLats.push(lat.toFixed(3));
                    queryLons.push(lon.toFixed(3));
                }
            }
        }
        
        log('info', `üìç Grid circular: ${queryLats.length} pontos (step ${step}¬∞, raio ${RAIO_NM} NM)`);
        
        // Usar forecast API com modelo padr√£o para o grid
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${queryLats.join(',')}&longitude=${queryLons.join(',')}&current=wind_speed_10m,wind_direction_10m&wind_speed_unit=kn`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        let addedCount = 0;
        
        if (Array.isArray(data)) {
            data.forEach((point, idx) => {
                // Usar coordenadas SOLICITADAS, n√£o as retornadas pela API
                const lat = parseFloat(queryLats[idx]);
                const lon = parseFloat(queryLons[idx]);
                
                if (point.current && point.current.wind_speed_10m !== null) {
                    addWindPoint({
                        lat: lat,
                        lon: lon,
                        speed: point.current.wind_speed_10m,
                        direction: point.current.wind_direction_10m,
                        time: new Date(),
                        source: 'Modelo (Open-Meteo)'
                    });
                    addedCount++;
                }
            });
        } else if (data.current && data.current.wind_speed_10m !== null) {
            addWindPoint({
                lat: parseFloat(queryLats[0]),
                lon: parseFloat(queryLons[0]),
                speed: data.current.wind_speed_10m,
                direction: data.current.wind_direction_10m,
                time: new Date(),
                source: 'Modelo (Open-Meteo)'
            });
            addedCount++;
        }
        
        log('info', `üìç Pontos adicionados: ${addedCount}/${queryLats.length}`);
    }
    
    function updateModelAverage() {
        // Atualizar valores individuais na UI
        const uiMap = {
            'gfs_seamless': 'gfs',
            'ecmwf_ifs025': 'ecmwf',
            'icon_seamless': 'icon',
            'meteofrance_seamless': 'meteofr',
            'jma_seamless': 'jma'
        };
        
        let validModels = 0;
        let weightedSpeed = 0;
        let weightedDirX = 0;
        let weightedDirY = 0;
        
        MODELS.forEach(model => {
            const uiKey = uiMap[model];
            const data = modelData[model];
            const weight = modelWeights[model];
            
            // Atualizar UI
            const valEl = document.getElementById(`${uiKey}-value`);
            const weightEl = document.getElementById(`${uiKey}-weight`);
            
            if (data && data.speed !== null) {
                valEl.textContent = `${data.speed.toFixed(1)} kn / ${data.direction.toFixed(0)}¬∞`;
                weightEl.textContent = `(${(weight * 100).toFixed(0)}%)`;
                
                // Acumular para m√©dia ponderada
                weightedSpeed += data.speed * weight;
                const rad = data.direction * Math.PI / 180;
                weightedDirX += Math.cos(rad) * weight;
                weightedDirY += Math.sin(rad) * weight;
                validModels++;
            } else {
                valEl.textContent = '--';
                weightEl.textContent = '';
            }
        });
        
        // Calcular m√©dia ponderada
        if (validModels > 0) {
            let avgDir = Math.atan2(weightedDirY, weightedDirX) * 180 / Math.PI;
            if (avgDir < 0) avgDir += 360;
            
            document.getElementById('avg-model-speed').textContent = weightedSpeed.toFixed(1);
            document.getElementById('avg-model-dir').textContent = avgDir.toFixed(0) + '¬∞';
            
            log('info', `üåç M√©dia Ponderada (${validModels} modelos): ${weightedSpeed.toFixed(1)} kn de ${avgDir.toFixed(0)}¬∞`);
        }
    }
    
    function clearOpenMeteoData() {
        windDataPoints = windDataPoints.filter(p => 
            !p.source.includes('GFS') && !p.source.includes('ECMWF') && 
            !p.source.includes('ICON') && !p.source.includes('Modelo') && 
            p.source !== 'Open-Meteo'
        );
        MODELS.forEach(m => modelData[m] = { speed: null, direction: null });
        document.getElementById('avg-model-speed').textContent = '--';
        document.getElementById('avg-model-dir').textContent = '--';
        updateWindDisplay();
        setStatus('openmeteo-status', '');
        log('info', 'üóëÔ∏è Dados de modelos removidos');
    }
    
    function processNOAAData(data, hasDirectSpeed = false) {
        if (!data.table || !data.table.rows) {
            log('warning', 'Dados NOAA vazios');
            return;
        }
        
        const rows = data.table.rows;
        const columnNames = data.table.columnNames || [];
        let count = 0;
        
        // Detectar formato das colunas
        const hasWindSpeed = columnNames.includes('wind_speed');
        const hasWindDirection = columnNames.includes('wind_direction');
        
        rows.forEach(row => {
            // Detectar estrutura baseado no n√∫mero de colunas
            // Com altitude: [time, altitude, lat, lon, wind_speed, wind_direction]
            // Sem altitude: [time, lat, lon, wind_speed, wind_direction]
            const hasAltitude = columnNames.includes('altitude');
            const offset = hasAltitude ? 1 : 0;
            
            const time = new Date(row[0]);
            const lat = row[1 + offset];
            const lon = row[2 + offset];
            
            let speed, direction;
            
            if (hasDirectSpeed || hasWindSpeed) {
                // Formato com wind_speed e wind_direction diretos
                speed = row[3 + offset];  // j√° em m/s
                direction = row[4 + offset];  // j√° em graus
                
                if (speed !== null && direction !== null) {
                    speed = speed * 1.94384;  // m/s para knots
                }
            } else {
                // Formato com componentes u/v
                const u = row[3 + offset];  // componente x
                const v = row[4 + offset];  // componente y
                
                if (u !== null && v !== null) {
                    // Calcular velocidade e dire√ß√£o
                    speed = Math.sqrt(u*u + v*v) * 1.94384;  // m/s para knots
                    direction = (Math.atan2(-u, -v) * 180 / Math.PI + 360) % 360;
                }
            }
            
            if (speed !== null && direction !== null && !isNaN(speed) && !isNaN(direction)) {
                addWindPoint({
                    lat: lat,
                    lon: lon,
                    speed: speed,
                    direction: direction,
                    time: time,
                    source: 'NOAA ASCAT'
                });
                count++;
            }
        });
        
        updateWindDisplay();
        log('success', `‚úÖ NOAA: ${count} pontos carregados`);
    }
    
    // =========================================================================
    // BUSCAR DADOS - COPERNICUS MARINE
    // =========================================================================
    async function fetchCopernicusData() {
        const user = document.getElementById('cmems-user').value;
        const pass = document.getElementById('cmems-pass').value;
        
        if (!user || !pass) {
            log('warning', 'CMEMS: Insira usu√°rio e senha');
            return;
        }
        
        setStatus('cmems-status', 'loading');
        log('info', 'Buscando dados Copernicus Marine...');
        
        // CMEMS usa WMS/WCS - precisamos de uma abordagem diferente
        // Para uso real, seria necess√°rio usar o copernicusmarine Python client
        // Aqui vamos mostrar como seria a URL
        
        const datasetId = 'WIND_GLO_PHY_L4_NRT_012_004';  // Global wind L4
        
        log('info', `Dataset: ${datasetId}`);
        log('warning', 'CMEMS requer autentica√ß√£o OAuth - use o Python client');
        log('info', 'Comando: pip install copernicusmarine');
        log('info', 'copernicusmarine subset -i ' + datasetId);
        
        // Mostrar instru√ß√µes
        alert(`Para acessar dados Copernicus Marine:

1. Instale o cliente Python:
   pip install copernicusmarine

2. Configure credenciais:
   copernicusmarine login

3. Baixe dados de vento:
   copernicusmarine subset \
     --dataset-id WIND_GLO_PHY_L4_NRT_012_004 \
     --variable eastward_wind \
     --variable northward_wind \
     --minimum-longitude ${CONFIG.lonMin} \
     --maximum-longitude ${CONFIG.lonMax} \
     --minimum-latitude ${CONFIG.latMin} \
     --maximum-latitude ${CONFIG.latMax}`);
        
        setStatus('cmems-status', 'error');
    }
    
    // =========================================================================
    // BUSCAR DADOS - NASA EARTHDATA
    // =========================================================================
    async function fetchNASAData() {
        const user = document.getElementById('nasa-user').value;
        const pass = document.getElementById('nasa-pass').value;
        
        if (!user || !pass) {
            log('warning', 'NASA: Insira usu√°rio e senha');
            return;
        }
        
        setStatus('nasa-status', 'loading');
        log('info', 'Buscando dados NASA Earthdata (CYGNSS)...');
        
        // NASA Earthdata tamb√©m requer autentica√ß√£o especial
        // CYGNSS √© um constela√ß√£o de 8 sat√©lites que mede vento oce√¢nico
        
        log('info', 'Datasets dispon√≠veis:');
        log('info', '- CYGNSS L2 Ocean Surface Wind Speed');
        log('info', '- QuikSCAT Level 2B (hist√≥rico)');
        log('info', '- RapidSCAT Level 2B (hist√≥rico)');
        
        log('warning', 'NASA Earthdata requer token de autentica√ß√£o');
        log('info', 'Use: https://search.earthdata.nasa.gov');
        
        setStatus('nasa-status', 'error');
    }
    
    // =========================================================================
    // FUN√á√ïES DE VISUALIZA√á√ÉO
    // =========================================================================
    function addWindPoint(point) {
        windDataPoints.push(point);
    }
    
    function updateWindDisplay() {
        windLayerGroup.clearLayers();
        
        if (windDataPoints.length === 0) return;
        
        const now = new Date();
        const maxAgeMs = MAX_DATA_AGE_MINUTES * 60 * 1000;  // Converter para milissegundos
        
        // FILTRAR dados que est√£o dentro do limite de idade (60 min)
        const recentPoints = windDataPoints.filter(point => {
            const ageMs = now - point.time;
            return ageMs <= maxAgeMs;
        });
        
        // Contar quantos foram descartados
        const discardedCount = windDataPoints.length - recentPoints.length;
        if (discardedCount > 0) {
            log('warning', `‚ö†Ô∏è ${discardedCount} pontos descartados (mais de ${MAX_DATA_AGE_MINUTES} min de atraso)`);
        }
        
        // Atualizar array global apenas com dados recentes
        windDataPoints = recentPoints;
        
        if (windDataPoints.length === 0) {
            log('warning', `‚ùå Nenhum dado com menos de ${MAX_DATA_AGE_MINUTES} min de idade`);
            document.getElementById('avg-wind').textContent = '--';
            document.getElementById('max-wind').textContent = '--';
            document.getElementById('data-points').textContent = '0';
            document.getElementById('data-age').textContent = '--';
            setStatus('wind-status', 'error');
            return;
        }
        
        let totalSpeed = 0;
        let maxSpeed = 0;
        let latestTime = new Date(0);
        
        windDataPoints.forEach(point => {
            // Desenhar seta
            drawWindArrow(point.lat, point.lon, point.direction, point.speed, point.source);
            
            // Estat√≠sticas
            totalSpeed += point.speed;
            if (point.speed > maxSpeed) maxSpeed = point.speed;
            if (point.time > latestTime) latestTime = point.time;
        });
        
        // Atualizar painel
        const avgSpeed = totalSpeed / windDataPoints.length;
        const ageMinutes = (now - latestTime) / (1000 * 60);  // Idade em minutos
        
        document.getElementById('avg-wind').textContent = avgSpeed.toFixed(1);
        document.getElementById('max-wind').textContent = maxSpeed.toFixed(1);
        document.getElementById('data-points').textContent = windDataPoints.length;
        document.getElementById('data-age').textContent = ageMinutes.toFixed(0) + ' min';
        
        // Status baseado na idade
        if (ageMinutes <= 30) {
            setStatus('wind-status', 'active');
        } else if (ageMinutes <= MAX_DATA_AGE_MINUTES) {
            setStatus('wind-status', 'loading');  // Amarelo para dados entre 30-60 min
        } else {
            setStatus('wind-status', 'error');
        }
    }
    
    function drawWindArrow(lat, lon, direction, speed, source) {
        // Cor baseada na velocidade
        let color;
        if (speed < 10) color = '#00ff00';
        else if (speed < 15) color = '#88ff00';
        else if (speed < 20) color = '#ffff00';
        else if (speed < 25) color = '#ff9900';
        else if (speed < 30) color = '#ff0000';
        else color = '#ff00ff';
        
        // ESCATER√îMETROS: √≠cone maior, borda destacada, zIndex alto
        const isScatterometer = source.includes('ASCAT') || source.includes('NOAA') || 
                                source.includes('CYGNSS') || source.includes('Copernicus') ||
                                source.includes('Scatterometer');
        
        const size = isScatterometer ? 36 : 22;
        const fontSize = isScatterometer ? '11px' : '9px';
        const borderStyle = isScatterometer ? `border: 2px solid ${color}; border-radius: 50%; background: rgba(0,0,0,0.7); padding: 3px;` : '';
        const zIndex = isScatterometer ? 1000 : 100;
        
        // DIRE√á√ÉO: Valor indica DE ONDE o vento vem (conven√ß√£o meteorol√≥gica)
        // Seta aponta PARA ONDE o vento vai (rota√ß√£o +180¬∞)
        // Ex: Vento de 0¬∞ (Norte) -> seta aponta para Sul (180¬∞)
        const arrowRotation = (direction + 180) % 360;  // Rotaciona 180¬∞
        
        const arrowHtml = `
            <div style="${borderStyle} transform: rotate(${arrowRotation}deg); width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center;">
                <svg viewBox="0 0 24 24" width="${size - 8}" height="${size - 8}">
                    <path fill="${color}" stroke="${isScatterometer ? '#fff' : 'none'}" stroke-width="${isScatterometer ? 1 : 0}" d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
                </svg>
            </div>
            <div style="text-align:center; font-size:${fontSize}; font-weight:bold; color:${color}; text-shadow: 1px 1px 2px black;">
                ${speed.toFixed(0)}${isScatterometer ? '‚óÜ' : ''}
            </div>
        `;

        const icon = L.divIcon({
            className: 'wind-arrow' + (isScatterometer ? ' scatterometer' : ' openmeteo'),
            html: arrowHtml,
            iconSize: [size, size + 12],
            iconAnchor: [size/2, (size + 12)/2]
        });

        L.marker([lat, lon], { icon: icon, zIndexOffset: zIndex })
            .bindPopup(`
                <b>Dados de Vento</b><br>
                Velocidade: ${speed.toFixed(1)} kn<br>
                Dire√ß√£o: ${direction.toFixed(0)}¬∞<br>
                Fonte: ${source}<br>
                Lat: ${lat.toFixed(3)}<br>
                Lon: ${lon.toFixed(3)}
            `)
            .addTo(windLayerGroup);
    }
    
    // =========================================================================
    // FUN√á√ïES AUXILIARES
    // =========================================================================
    function log(type, message) {
        const logArea = document.getElementById('log-area');
        const time = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${time}] ${message}`;
        logArea.appendChild(entry);
        logArea.scrollTop = logArea.scrollHeight;
    }
    
    function setStatus(elementId, status) {
        const el = document.getElementById(elementId);
        if (el) {
            el.className = 'status-indicator ' + status;
        }
    }
    
    function saveCmemsCredentials() {
        const user = document.getElementById('cmems-user').value;
        const pass = document.getElementById('cmems-pass').value;
        localStorage.setItem('cmems-user', user);
        localStorage.setItem('cmems-pass', pass);
        log('success', 'Credenciais CMEMS salvas');
    }
    
    function saveNasaCredentials() {
        const user = document.getElementById('nasa-user').value;
        const pass = document.getElementById('nasa-pass').value;
        localStorage.setItem('nasa-user', user);
        localStorage.setItem('nasa-pass', pass);
        log('success', 'Credenciais NASA salvas');
    }
    
    function loadSavedCredentials() {
        // Credenciais desabilitadas - escater√¥metros t√™m atraso > 60 min
        // Apenas Open-Meteo (tempo real) est√° habilitado
    }
    
    function fetchAllSources() {
        log('info', `‚è±Ô∏è Limite de idade: ${MAX_DATA_AGE_MINUTES} minutos`);
        log('info', 'üåê Buscando dados em TEMPO REAL...');
        fetchOpenMeteoData();
        // NOTA: Dados de escater√¥metro satelital (NOAA ASCAT, NASA CYGNSS, Copernicus)
        // t√™m atraso m√≠nimo de 2-6 horas no processamento.
        // Apenas Open-Meteo fornece dados com < 60 min de atraso.
        // NDBC B√≥ias n√£o cobrem costa brasileira (Bacia de Campos)
        log('info', '‚úÖ Fonte: Open-Meteo (tempo real)');
    }
    
    function clearData() {
        windDataPoints = [];
        windLayerGroup.clearLayers();
        document.getElementById('avg-wind').textContent = '--';
        document.getElementById('max-wind').textContent = '--';
        document.getElementById('data-points').textContent = '--';
        document.getElementById('data-age').textContent = '--';
        setStatus('wind-status', '');
        log('info', 'Dados limpos');
    }
    
    function exportData() {
        if (windDataPoints.length === 0) {
            log('warning', 'Nenhum dado para exportar');
            return;
        }
        
        let csv = 'latitude,longitude,wind_speed_kn,wind_direction,source,timestamp\n';
        windDataPoints.forEach(p => {
            csv += `${p.lat},${p.lon},${p.speed.toFixed(2)},${p.direction.toFixed(1)},${p.source},${p.time.toISOString()}\n`;
        });
        
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `scatterometer_data_${new Date().toISOString().slice(0,10)}.csv`;
        a.click();
        
        log('success', 'Dados exportados para CSV');
    }
    
    // =========================================================================
    // INICIAR
    // =========================================================================
    initMap();
</script>

</body>
</html>
